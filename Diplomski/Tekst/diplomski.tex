\documentclass[times, utf8, diplomski, numeric]{fer}
\usepackage{booktabs, url, hyperref}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

%dodatak za programski kod
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\small\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2
}
\renewcommand\lstlistingname{Algoritam}
%kraj dodatka za programski kod

\hypersetup{
   colorlinks,
   citecolor=black,
   filecolor=black,
   linkcolor=black,
   urlcolor=black
}


\newtheorem{definition}{Definicija}
\newtheorem{theorem}{Teorem}


\begin{document}

% TODO: Navedite broj rada.
\thesisnumber{656}

% TODO: Navedite naslov rada.
\title{Bojanje grafova prilagodljivim metaheurističkim postupcima}

% TODO: Navedite vaše ime i prezime.
\author{Dino Šantl}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
\izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}

U ovom radu obrađuje se jedna od inačica matematičkog problema poznatog pod nazivom bojanje grafa \engl{graph coloring}. Motivacija za rješavanje ovog problema dolazi iz domene telekomunikacija. Problem dodjelivanja frekvencija (k\^{o}dova) s ciljem da ne dolazi do međusobne interferencije može se lako prevesti u problem bojanja grafova. Bojanje grafova poznat je matematički problem i postoji više smjerova za njegovo rješavanje na računalu \cite{lit8}. Specifičnost ovog problema su zadana ograničenja. Za razliku od klasičnog bojanja grafa, ovaj problem modeliran je pomoću težinskog grafa. Cilj je isti, obojiti graf tako da dva susjedna čvora nemaju istu boju. Ograničenja koja se pojavljuju vezana su uz dostupnost boja za svaki čvor i dodatne informacije koje svaki čvor posjeduje. U radu se prvo analizira matematički problem. Kako je problem iz perspektive računarske teorije \emph{NP-težak} i nije poznato je li postoji deterministički algoritam koji bi mogao veće instance problema rješavati u kratkom vremenskom roku, proučavaju se različiti heuristički pristupi. Osim toga analiza problema je veoma važna kako bi se dobila mjera u kojoj je problem rješiv na računalu. Nakon teorijske obrade problema, obrađuju se metaheursitični postupci koji su korišteni u radu. Za ovaj rad posebno je izrađeno okruženje za razvoj algoritama i alata za analizu problema. U radu se daje pogled na izrađenu infrastrukturu. Na kraju obavljena su mjerenja te analiza rezultata. Kako se rad temelji na metaheurističnim postupcima važno je odrediti ponašanje parametara s različitim vrstama grafova, što daje temeljno znanje o konstrukciji samopodešavajućih metaheuristika. Nakon mjerenja donose se zaključci i smjernice za daljni rad na problemu.
U praksi potrebno je konstruirati algoritam koji zahtjeva malo vremenskih i memorijskih resursa. Grafovi koji se mogu pojaviti kao ulaz mogu biti veoma veliki i gusti, što znači da je uz samo ispitivanje ponašanja heuristika potrebno razmišljati i o konkretnim implementacijama. Neke heuristike već same po sebi zahtjevaju dosta resursa. Veoma važan dio rada je istražiti je li se isplati koristiti heuristike koje su malo zahtjevnije u cilju dobivanje boljeg rješenja. Ovaj rad je uvod u dizajniranje konačnog algoritma koji bi mogao biti primjenjiv u praksi. 

\section{Sažetci korištenih znanstvenih članaka}

\subsection*{An Efficient GA with Multipoint Guided Mutation for Graph Coloring Problems \cite{lit1}}

Rad opisuje rješavanje problema bojanja grafova pomoću genetskog algoritma.
Posebna pažnja posvećena je operatoru mutacije.
Jedinke su prikazane nizom cijelih brojeva. Svakom čvoru u grafu pridružen je jedinstveni cijeli broj - identifikacija.
Jedinka je prikazana nizom u kojem je svakoj identifikaciji (čvoru)
pridružen broj boje. Funkcija cilja je broj korištenih boja.
Inicijalna populacija generira se slučajnim dodjeljivanjem
boja svakom čvoru u grafu.
Dodatno se koristi operator ispravaka koji popravlja jedinku tako da izabere dva susjedna čvora koji imaju istu boju i zatim jednome od njih promjeni boju.
Mutacija se vrši nad jedinkom tako da se prvo reducira broj korištenih boja. To se može napraviti tako da se odaberu dva čvora i pridruži im se boja koja nije jedna od dvije odabrane.
Zatim se primijeni operator ispravaka nad tom jedinkom. To se sve ponavlja sve dok se ne generira legalno pobojani graf.
Rezultati su uspoređivani s klasičnim implementacijama genetskih algoritama i
dobiveni su bolji rezultati, ali u zaključku se navodi kako bi algoritam trebalo poboljšati da bi vrijeme
izvođenja na većim i kompleksnijim grafovima bilo bolje.
Ispitivanje se obavljalo nad nekim primjerima iz DIMACS baze.

\subsection*{Efficient Graph Coloring With Parallel Genetic Algorithms \cite{lit2}}

Koristi se paralelni genetski algoritam i to migracijski model. Osim toga,
definirani su i novi genetski operatori. Jedinka je prikazana pomoću 
particije skupa. 

Ispitivanje je vršeno nad DIMACS bazom.
Dobiveni su rezultati:
\begin{enumerate}
\item Uvijek je bolje koristiti migraciju od izolacije. Za neke se operatore može odrediti najbolji parametar, dok za većinu drugih to nije pronađeno.

\item U migraciji je bolje koristiti najbolje jedinke. Samo u nekim slučajevima kod CEX operatora je bolje koristiti slučajno odabrane jedinke.

\item First Fit je uvijek bolja mutacija od Transposition mutacije. First Fit najbolje se ponaša uz CEX i GPX operator. Transposition mutacija relativno dobro radi sa SPPX operatorom.

\item CEX i GPX operatori su bili najbolji uz korištenje First Fit mutacije.
Nakon toga slijedi USIX. SPPX je jako brz operator, ali da bi bio uspješan,
potrebno ga je izvršiti u više iteracija.

\item Najbrži operator križanja je CEX s First Fit mutacijom. Najsporji je UISX.
\end{enumerate}


\subsection*{An ACO Algorithm for the Graph Coloring Problem \cite{lit4}}

Opisuje se jedna inačica ACO \engl{Ant colony optimization} algoritma. Ideja je u svakom koraku bojati 
jednom bojom (odabiru se čvorovi koji će se bojati u zadanu boju). Radi se o 
proširenju ANTCOL-a. Uz kemijske se tragove dodaje heuristika (npr. 
broj čvorova koji su iste boje kao i trenutni korak). Graf koji mravi rješavaju
nije orginalni graf koji je zadan, već je to graf gdje su povezana dva čvora
koja u originalnom grafu nisu susjedna. Prema tome se računa vjerojatnost da 
se nekom čvoru pridoda neka boja. 


\subsection*{Breaking the Symmetry of the Graph Colouring Problem with Genetic Algorithms \cite{lit5}}

Razbija se simetrija u klasičnom problemu bojanja grafova. Različite jedinke mogu predstavljati isto pobojane grafove. Problem se pokušava rješitit tako  što se na početku fiksiraju boje za određene čvorove. U našem problemu, članak se može koristiti kod pristupa pri pohlepnom algoritmu.

\subsection*{New Graph Coloring Algorithms \cite{lit7}}

Članak koji opisuje heuristike koje se koriste u pohlepnim algoritmima. Članak donosi ideje koje se lako implementiraju i daju dobre rezultate. Neke vrste bojanja i neke vrste sortiranja ideje vuku iz ovog članka (npr. SDO-LDO).

\subsection*{Graph Coloring Algorithms for Assignment Problems in Radio Networks \cite{lit10}}

Problem koji je veoma sličan praktičnoj primjeni problema koji se rješava. Koriste se različiti algoritmi i uspoređuju se rezultati. Cilj rada je istražiti problem i pokazati koji algoritmi, tj. heuristike, su efikasne.

\subsection*{Evolutionary Algorithms for Real-World Instances of the Automatic Frequency Planning Problem in GSM Networks \cite{lit12}}

Rad koji je vrlo sličan problematici koja se rješava u diplomskom radu. U radu je primjećeno da operator križanja mora biti vrlo napredan ili ga uopće ne koristiti, te se predlaže korištenje evolucijske strategije $(\mu, \lambda)$ 

\subsection*{Optimization by Simulated Annealing: An Experimental Evaluation; Part II, Graph Coloring and Number Partitioning \cite{lit13}}

Opisuje se korištenje simuliranog kaljenja u optimizacijskim algoritmima. Pokazuje se osnovna struktura simuliranog kaljenja i predlažu se nadogradnje kako bi metaheuristika dala bolje rezultate.

\subsection*{Genetic Annealing Optimization: Design and Real World Applications \cite{lit18}}

Jedan od rijetkih članaka koji opisuje metaheuristiku - genetsko kaljenje. Analizira se metaheuristika u kojoj su uzete dobre strane genetskog algoritma i dobre strane simuliranog kaljenja. Algoritam pokazuje dobre rezultate, ali nedostatak može predstavljati velika populacija za koju je potrebno računati funkcije cilja čija je vremenska složenost velika.


\chapter{Formalni opis problema}

U ovom poglavlju opisuje se problem bojanja grafova i njegova primjena u području telekomunikacija. Opisuje se konkretan problem u telekomunikacijama uz pretpostavke i ograničenja. Zatim se isti problem opisuje pomoću matematičkog modela, tj. problema bojanja grafova. Kreće se od općenitog problema bojanja grafova, a zatim se matematički model prilagođava konkretnom telekomunikacijskom problemu.

\section{Tehnički opis problema}

Za opis problema dovoljno je pretpostaviti da postoji korisnikova oprema (što je najčešće mobilni uređaj) i bazna stanica. Bazne stanice geografski su statične, za razliku od mobilnih uređaja koji to nisu.
Ono što se u ovom radu naziva baznom stanicom je radijska pristupna mreža \engl{Radio Access Network} (\emph{RAN}). \emph{RAN} je dio telekomunikacijskog sustava i nalazi se između opreme korisnika i jezgre mreže. To je sloj u mreži koji je zaslužan za prenošenje komunikacije između mobilnog uređaja do antene i od antene do drugog mobilnog uređaja. 

Za što kvalitetniji rad mreže potrebno je optimirati parametre \emph{RAN}-a. Jedan od parametra je \emph{scrambling} k\^{o}d. \emph{Scrambling} k\^{o}d služi kako bi mobilni uređaj mogao razlikovati bazne stanice. Svakoj baznoj stanici potrebno je pridružiti različit k\^{o}d. Problem je u tome što je dostupno samo 512 različitih kodova. To znači da neke bazne stanice moraju imati isti k\^{o}d (ako se u sustavu nalazi više od 512 baznih stanica). Ako neke dvije bazne stanice imaju isti k\^{o}d i mobilni uređaj se nalazi u dosegu signala od obje stanice, tada uređaj ne može odrediti s kojom baznom stanicom komunicira. Tada može doći do prekida poziva, što uzrokuje pad kvalitete usluge.

Potrebno je dodijeliti \emph{scrambling} k\^{o}dove tako da dvije bazne stanice koje mogu biti istovremeno vezane za jedan mobilni uređaj nemaju isti k\^{o}d ili ako je to nemoguće, dodijeliti k\^{o}dove tako da je negativan utjecaj na kvalitetu usluge što manji. Postoje još neka tehnička ograničenja koja je potrebno uvažiti, a biti će navedena u nastavku.

Iako postoji 512 različitih k\^{o}dova, svaka bazna stanica ima ograničen skup k\^{o}dova koje može koristiti. Za svaku baznu stanicu zadan je skup mogućih k\^{o}dova. Za neke bazne stanice postoji svojstvo nepromjenjivost, što znači da k\^{o}d koji je trenutno zadan za tu baznu stanicu mora ostati takav. Takve se vrste baznih stanica nazivaju \textbf{nepromjenjivima}. Početno stanje mreže definirano je k\^{o}dovima koji su pridijeljeni nekoj baznoj stanici. Osim toga, za svaku baznu stanicu poznata je njezina vrsta. Vrsta može biti označena slovima: \emph{A, B ili C}. Bazne stanice različitih vrsta ne utječu jedna na drugu.

\subsection{Ulazni i izlazni podaci}

Ulaz algoritma je inicijalno stanje mreže. Za svaku baznu stanicu poznat je trenutni k\^{o}d koji koristi i sva pravila koja moraju biti zadovoljena. Izlaz algoritma je skup uređenih parova, gdje je prvi element identifikator bazne stanice, a drugi element pripadajući k\^{o}d. U navedenom popisu umjesto pojma bazne stanice koristi se čvor, a naziv će biti opravdan u nastavku.

\subsubsection{Ulazni podaci}

\begin{enumerate}
	\item Popis i definicija domene boja (skupova boja)
	\item Popis čvorova (baznih stanica).
		\begin{enumerate}
			\item Oznaka čvora
			\item Vrsta čvora (grupa) - A, B ili C
			\item Oznaka domene za boju čvora (koji skup boja koristi)
			\item Početna boja za čvor
			\item Oznaka je li je čvor nepromjenjiv
		\end{enumerate}
\end{enumerate} 

\subsubsection{Izlazni podaci}

Kao izlaz algoritma koristi se niz parova brojeva $(i, c)$ gdje je $i$ oznaka za baznu stanicu, a $c$ je k\^{o}d (boja) čvora.

\section{Matematički opis problema}

Potrebno je modelirati problem u kojem postoji \emph{bazna stanica} i veze između istih. Veze predstavljaju mjeru u kojoj jedna bazna stanica utječe na drugu. Jedan od mogućih modela je graf. Čvorovi će predstavljati bazne stanice, a jakost će između dvije bazne stanice biti modelirana pomoću težine brida. U nastavku, bazna stanica nazivat će se čvorom. Nad ovako postavljenim grafom problem je dodijeliti k\^{o}dove tako da nema bridova koji na svojim krajevima imaju čvor s istim k\^{o}dom. Problem je poznat pod nazivom \emph{bojanje grafa}. Kako je uobičajeno pričati o bojama čvora (a ne o k\^{o}dovima), od sad pa nadalje \emph{scrambling} k\^{o}d nazivat će se bojom čvora. U nastavku će prvo biti opisan klasičan problem bojanja grafova, gdje se promatraju bestežinski grafovi (oni čiji bridovi nemaju težine). Nakon toga problem se poopćuje na težinske grafove, čime se modelira prethodno opisan problem.

\subsection{Definicije za klasičan problem bojanja grafova}

Najprije se definiraju matematički pojmovi. Zatim se formalno opisuje problem bojanja grafova. Uz to se nadovezuje teorija izračunljivosti.

\subsubsection{Pojam grafa}

\begin{definition}
Jednostavni graf \textbf{G} sastoji se od nepraznog konačnog skupa \textbf{V(G)}, čije elemente nazivamo čvorovi grafa \textbf{G} i konačnog skupa \textbf{E(G)} različitih dvočlanih podskupova \textbf{V(G)} koje zovemo bridovi.
\end{definition}

\begin{definition}
Skup vrhova koji su susjedni vrhu \textbf{v} zovemo susjedstvo vrha \textbf{v} i označavamo s oznakom \textbf{H(v)}.
\end{definition}

\begin{definition}
Stupanj vrha \textbf{v} grafa \textbf{G} jednak je broju bridova koji su vezani na \textbf{v}. Označavamo ga s \textbf{d(v)}.
\end{definition}

\begin{definition}
Neka je \textbf{G} jednostavan graf i $\mathbf{\omega}$ funkcija $\mathbf{\omega : E \rightarrow \mathbb{R}}$. Par \textbf{(G, $\omega$)} naziva se težinski graf. Pri čemu funkcija $\omega$ svakom bridu iz \textbf{G} dodjeljuje jedan element iz skupa realnih brojeva. Neka je \textbf{e} neki brid grafa \textbf{G}, njegova težina označena je s $\omega(\mathbf{\mathit{e}})$.	 
\end{definition}


\subsubsection{Definicija bojanja grafova}

\begin{definition}
Definiramo funkciju $\phi : V(G) \rightarrow \mathbb{N}$, koja svakom čvoru u grafu pridružuje jedan prirodan broj koji $\mathbf{\phi(v)}$, gdje je $\mathbf{v}$ čvor u grafu $\mathbf{G}$. Broj $\mathbf{\phi(v)}$ nazivamo boja čvora, a funkciju $\phi$ nazivamo \textbf{bojanje grafa}. 
\end{definition}

\begin{definition}
Bojanje grafa s najviše \textbf{k} boja nazivamo \textbf{k-bojanje} grafa. 
\end{definition}

\begin{definition}
Ako se graf može obojiti s najviše \textbf{k} boja tada takvo bojanje nazivamo \textbf{legalno k-bojanje} grafa. 
\end{definition}

\begin{definition}
Graf je \textbf{k-obojiv} kako postoji legalno k-bojanje grafa.
\end{definition}


\begin{definition}
Ako je graf G \textbf{k}-obojiv, ali nije \textbf{(k-1)}-obojiv tada kažemo da je \textbf{k} kromatski broj grafa G, gdje se koristi oznaka $\chi(G)=k$  
\end{definition}


\begin{definition}
Podskup skupa V(G) nazivamo \textbf{nezavisni skup} ako u njemu ne postoje dva čvora koja su susjedna.  
\end{definition}

\begin{definition}
Brid koji spaja dva čvora iste boje nazivamo \textbf{konfliktni brid}.
\end{definition}

\begin{definition}
Dva čvora koja spaja konfliktni brid nazivamo \textbf{konfliktnim čvorovima}.
\end{definition}

\begin{definition}
Particiju skupa V(G) na k disjunktnih nepraznih podskupova $V_1,..., V_k$
 tako da vrijedi $V(G) = \bigcup_{j=1}^{k}V_j$ zovemo \textbf{k-dioba} grafa G. Ako su podskupovi  $V_1 ,..., V_k$  ujedno i nezavisni skupovi onda se to naziva \textbf{legalna k-dioba} grafa G.
\end{definition}

\begin{theorem}
\label{thm:dioba}
Graf \textbf{G} je \textbf{k-obojiv} kako postoji \textbf{legalna k-dioba} grafa \textbf{G}.
\end{theorem}

\begin{proof}
Pretpostavimo da je graf \emph{G} \textbf{k-obojiv}. Definiramo skupove $S_i$ tako da čvor grafa $\mathbf{v}$ pripada skupu $S_i$ ako je obojen bojom $\mathbf{i}$. Takvi skupovi su neprazni i disjunktni, te unija skupova $S_i$ čini skup svih vrhova grafa \emph{G}. Kako je G \textbf{k-obojiv} tada ne postoji boja zbog koje bi neki brid bio konfliktan pa sljedi da je podjela na skupove $S_i$ \textbf{legalna k-dioba} grafa G jer su skupovi $S_i$ nezavisni. 

Drugi smjer dokazuje se tako što se pretpostavi da postoji \textbf{legalna k-dioba} grafa \textbf{G} na skupove $S_i$. Kako je svaki skup indeksiran s indeksom \textbf{i}, tada svakom čvoru koji se nalazi u skupu $S_i$ dodijelimo boju \textbf{i}. Kako su skupovi $S_i$ prema pretpostavci disjunktni, neprazni i nezavisni, ne postoje dva čvora koja bi imala istu boju.
\end{proof}

\subsubsection{Definicije računske teorije složenosti}

\begin{definition}
\textbf{Problem odluke} je problem koji uvijek ima odgovor \textbf{da} ili \textbf{ne}. Primjerice, problem je li je graf točno \textbf{k-obojiv} je problem odluke. Problem traženja kromatskog broja grafa nije problem odluke, jer tražimo točan broj \textbf{k}.
\end{definition}

\begin{definition}
Problem odluke za koje postoje algoritmi koji daju odgovor, a čije vrijeme izvršavanje ovisi polinomno o veličini ulaznih podataka spadaju u \textbf{klasu P}.
\end{definition}

\begin{definition}
\textbf{Problem odluke} spada u klasu \textbf{NP problema} ako se točnost njegovog rješenja može ispitati u polinomnom vremenu. 
\end{definition}

\begin{definition}
\textbf{Problem odluke} spada u klasu \textbf{NP-potpunih problema} ako spada u \textbf{klasu NP} problema i koji ima svojstvo da se svaki drugi problem iz \textbf{klase NP} može polinomno reducirati na njega. 
\end{definition}

\begin{definition}
Kažemo da je problem \textbf{NP-težak} akko postoji \textbf{NP-potpun problem} koji se može polinomno reducirati na njega.
\end{definition}

Problem odluke za koji postoji algoritam čije trajanje ovisi polinomno o veličini ulaznih podataka je \textbf{P problem}. Ako za neki problem odluke ne možemo pronaći algoritam čije vrijeme izvođenja ovisi polinomno o veličini ulaznih podataka, ali točnost rješenja možemo provjeriti u polinomnom vremenu, tada je to \textbf{NP problem}. \textbf{NP-potpun problem} je problem odluke čiji algoritam možemo iskoristiti da bismo riješili sve \textbf{NP probleme} tako da koristimo polinomijalan broj poziva tog algoritma. Općeniti problemi (koji ne moraju biti problemi odluke) nazivaju se \textbf{NP-teški problemi} ako postoji problem u klasi \textbf{NP-potpunih problema} koji se može riješiti pomoću polinomnog broja poziva algoritma za promatrani \textbf{NP-teški} problem. Odnos \textbf{P} i \textbf{NP} klasa još je uvijek otvoren problem ($P=NP$ ili $P\subset NP$). Kada bi se moglo dokazati da je neki \textbf{NP-potpun} problem moguće riješiti u polinomnom vremenu, tada bi se svi \textbf{NP problemi} mogli riješiti u polinomnom vremenu, pa bi klase \textbf{P} i klase \textbf{NP} bile jednake. Ako se pak pokaže da za neki \textbf{NP} problem ne postoji algoritam čije izvršavanje ovisi polinomno o ulaznim podacima, tada bi klasa \textbf{P} bila pravi podskup od klase \textbf{NP}.

\subsubsection{\emph{No free lunch} teorem za optimizacijske algoritme}

\begin{definition}
\textbf{Optimizacija} je grana matematike koja proučava pronalaženje ekstrema funkcija.
\end{definition}

\begin{definition}
\textbf{Kombinatorna optimizacija} je grana optimizacije, gdje je domena funkcije skup s konačnim brojem elemenata.
\end{definition}

\begin{definition}
Konkretna funkcija koja se proučava naziva se \textbf{funkcija cilja}.
U radu se zbog semantike umjesto funkcije cilja često koristi pojam greške.
\end{definition}

\begin{definition}
Funkcije cilja koje se promatraju imaju diskretnu i konačnu domenu i kodomenu. Iako se kao elementi kodomene mogu pojaviti realni brojevi, zbog toga što su računala diskretni strojevi s konačno mnogo memorije, to je samo konačni podskup realnih brojeva.
\end{definition}

\begin{theorem}
Funkcija cilja definira se kao: $f : \mathbb{X} \rightarrow \mathbb{Y}$, gdje su skupovi $\mathbb{X}$ i $\mathbb{Y}$ diskretni i konačni. Tada je broj svih mogućih funkcija jednak $|\mathbb{F}| = |\mathbb{Y}|^{|\mathbb{X}|}$. 
\end{theorem}

\begin{proof}
Za svaki element domene možemo odabrati točno $|\mathbb{Y}|$ elemenata kodomene. 
\begin{equation}
|\mathbb{F}| = \prod_{j=1}^{|\mathbb{X}|} |\mathbb{Y}| =  |\mathbb{Y}|^{|\mathbb{X}|}
\end{equation}
\end{proof}

\begin{definition}
Vremenski niz $d_m$ je niz parova domene i kodomene.
\begin{equation}
d_m = \left \{ (d_m^x(1), d_m^y(1)), (d_m^x(2), d_m^y(2)), ..., (d_m^x(m), d_m^y(m))\right \}
\end{equation} 
Iz nekog niza $d_m$ može se izvući samo niz elemenata domene i to se označava s $\mathbf{d_m^x}$ ili samo niz elemenata kodomene što se označava s $\mathbf{d_m^y}$.
\end{definition}

\begin{definition}
Prostor svih vremenskih nizova veličine $m$: $\mathbb{D}_m = (\mathbb{X} \times \mathbb{Y})^m$, a prostor svih vremenskih nizova maksimalne veličine $m$ je: $\mathbb{D} = \bigcup_{m\ge0}\mathbb{D}_m$.
\end{definition}

\begin{definition}
Optimizacijski algoritam $a$ definira se kao: $a : d \in \mathbb{D} \rightarrow \left \{x | x \notin d_m^x \right \}$
\end{definition}

Optimizacijski algoritam preslikava neki vremenski niz (podatke iz prethodnih koraka izvođenja) u novu vrijednost domene, pod uvjetom da ta vrijednost domene ne smije biti već viđena. Ovo ograničenje koristi se u dokazu teorema, ali se u praksi često mogu javiti slučajevi gdje se više puta računa vrijednost funkcije za isti element domene.

\begin{definition}
\textbf{Heuristikom} se naziva optimizacijski algoritam koji ne mora kao rezultat dati globalni ekstrem \textbf{funkcije cilja}, ali daje dovoljno dobre rezultate u svrhu kraćeg vremenskog izvođenja. 
\end{definition}

\begin{definition}
\textbf{Metaheuristikom} naziva se familija optimizacijskih algoritama, čije konkretno izvođenje ovisi o njegovim parametrima.
\end{definition}

\begin{definition}
Skup svih dozvoljenih rješenja u optimizaciji nazivamo \textbf{prostor pretrage}.
\end{definition}

\begin{theorem}
\label{thm:nofreelunch}
\textbf{"No free lunch" teorem za optimizaciju} - Neka su $a_1$ i $a_2$ dva različita heuristička algoritma koji traže ekstrem funkcije. Funkcije su predstavljene crnom kutijom. Tada vrijedi ova jednakost:
\begin{equation}
	\sum_{f}P(d_m^y|f,m,a_1) = \sum_{f}P(d_m^y|f,m,a_2)
\end{equation}
\end{theorem}

Dokaz teorema može se pronaći u \cite{lit15}.

Kako se ne zna ništa više o funkcijama (npr. simbolički zapis), već samo ulazni i izlazni parovi, ne može se koristiti nikakvo unutarnje znanje koje bi nekom algoritmu dalo prednost. Ako je poznat broj koraka $m$ tada za bilo koji algoritam, sume vjerojatnosti su međusobno jednake, pri čemu se gleda vjerojatnost da se pojavio neki niz izlaznih vrijednosti funkcije $d_m^y$.
Iz niza izlaznih vrijednost $d_m^y$ može se lako izvući minimalna ili maksimalna vrijednost koja je tada konačan izlaz algoritma. Dakle, ne postoji algoritam koji bi bio dominantniji za sve funkcije cilja $f$. Zbog toga je potrebno svaki optimizacijski problem promatrati veoma usko i koristiti dodatne informacije o samoj funkciji $f$.

Prethodne definicije i teoremi služe kako bi se uskladili nazivi za matematičke pojmove koji će se koristiti u radu. Sve definicije uzete su iz \cite{lit16, lit15, lit19}, gdje se među ostalim mogu naći i druge definicije i teoremi vezani za teoriju grafova, računsku teoriju složenosti i "\emph{No free lunch}" teorem.

\subsection{Bojanje težinskih grafova}

Za navedeni telekomunikacijski problem potrebno je odabrati prikladan matematički model. Već je spomenuto da se bazne stanice modeliraju čvorovima u grafu. Postavlja se pitanje što predstavlja brid u tome grafu. Očigledno je da jedna bazna stanice utječe na drugu baznu stanicu, tj. mobilni uređaj istovremeno vidi više baznih stanica. To znači da bi brid mogao predstavljati relaciju vidi li neka bazna stanica drugu. Problem se može razviti i korak dalje. Nije svejedno na kojoj su udaljenosti bazne stanice te koja je njihova snaga. To znači da dvije bliže (ili jače vezane) bazne stanice više utječu jedna na drugo nego što to čine dvije udaljenije. Ideja je svakom bridu dodijeliti težinu koja predstavlja neku mjeru koliko jedna bazna stanica utječe na drugu. To znači da brid između dva čvora daje mjeru međusobnog utjecaja čvorova. Ako je utjecaj premali (tehnički nevidljiv), tada brid između ta dva čvora ne postoji.

Na tako zadanom težinskom grafu potrebno je napraviti bojanje grafa uz poštivanje svih tehničkih uvjeta. Zato se u ovom radu klasični problem bojanja grafova poopćuje:

\begin{definition}
Bojanje težinskog grafa je optimizacijski problem u kojem se minimizira funkcija cilja:
\begin{equation}
f(\phi) = 2\sum_{i=1}^{E(G)} \omega(e_i) \cdot R(e_i)
\end{equation}
, gdje je $\omega(e_i)$ težina brida, a $R$ funkcija koja ima vrijednost $1$ ako je $e_i$ konfliktan brid ili $0$ inače. Funkcija $f$ ovisi o bojanju grafa, tj. funkcija cilja jednaka je dvostrukoj sumi težina konfliktnih bridova.
\end{definition}

Konstanta $2$ koja množi sumu, matematički je nebitna, ali navodi se zbog implementacije funkcije na računalu. Zbog tehničkih ograničenja potrebno je uvesti nekoliko matematičkih detalja koji pokrivaju te slučajeve.

\begin{definition}
Funkcija $\phi$ definira se kao funkcija koja svakom ne nepromjenjivom čvoru $v$ grafa \textbf{G} pridružuje prirodan broj iz skupa dopuštenih boja za taj čvor.
\end{definition}

\begin{definition}
Ako su dva čvora \textbf{nepromjenjiva} spojena bridom i imaju iste boje, tada smatramo da taj brid nije \textbf{konfliktan}.
\end{definition}

Razlog ovakvoj definiciji je taj da se bridovi koji spajaju dva nepromjenjiva čvora različitih boja ne mogu nikada poboljšati, pa prema tome neovisni su o funkciji bojanja grafa $\phi$.

\begin{definition}
Ako su dva čvora koja pripadaju u suprotne vrste spojena bridom, tada takav brid ne smatramo \textbf{konfliktnim}.
\end{definition}

Tehnički, takva dva čvora ne utječu jedan na drugog pa nema potrebe  ugrađivati u funkciju cilja te bridove.

U slučaju da je čvor obojen bojom koja nije u njegovoj domeni, tada je potrebno dodati u funkciju cilja kaznu za takav slučaj. Iako po definiciji funkcije bojanja grafa to nije moguće, zbog inicijalnog stanja boja koje algoritam primi kao ulaz, može se dogoditi da boja čvora nije u njegovoj domeni. Stoga se definira proširena funkcija cilja kao:

\begin{definition}
\begin{equation}
\label{equ:funkcija_cilja}
f(\phi) = 2\sum_{i=1}^{E(G)} \omega(e_i) \cdot R(e_i) + \sum_{i=1}^{V(G)} C(v_i)
\end{equation}
Prva suma jednaka je već definiranoj funkciji cilja. Drugi član je suma funkcije $C$ po čvorovima, gdje funkcija $C$ ima vrijednost $\varepsilon$ ako je čvor $v_i$ krivo obojen ili $0$ ako je obojen bojom iz svoje domene.
\end{definition}

Za epsilon se odabire neki veliki pozitivan broj. U konkretnoj implementaciji koja se koristi u radu $\varepsilon=10000000$.

\begin{definition}
Smatra se da je bojanje \textbf{valjano} ako postotak promjene boja inicijalnog stanja ne prelazi prag od $\alpha$ posto.
\end{definition}

U konkretnom problemu $\alpha=66\%$.

Sažetak problema kojeg modeliramo pomoću težinskog grafa glasi:
\begin{itemize}
	\item Svaki čvor može poprimiti jednu boju iz skupa dopuštenih boja za taj čvor
	\item Svaki čvor spada u jednu grupu tj. vrstu (A, B ili C)
	\item Neki čvorovi su definirani kao nepromjenjivi, njima se boja nikad ne smije mijenjati
	\item Dodatan uvjet je da postotak promijenjenih čvorova naprema inicijalnom stanju ne smije biti veći od 66\%
	\item Optimizacija se provodi nad funkcijom cilja definiranom formulom (\ref{equ:funkcija_cilja}).
\end{itemize}

\section{Analiza problema bojanja težinskih grafova}

U ovom odjeljku analizirat ćese zadani matematički problem optimizacije. U svakom koraku analize uspoređuje se klasičan problem bojanja grafova i bojanje težinskih grafova. Kreće se od analize prostora pretrage. Zatim se dokazuje u kojoj se klasi problemi nalaze. Na kraju se pokazuje da "\emph{No free lunch}" teorem vrijedi i za bojanje grafova i kakve posljedice donosi.

\subsection{Prostor pretrage stanja}

Kod klasičnog problema bojanja grafova analiziraju se dva problema. Prvi je odrediti može li se graf može obojiti s najviše $k$ boja, a drugi problem je odrediti najmanji takav $k$. Pretpostavimo za početak da provjeravano je li graf \textbf{k-obojiv}. Pitanje je na koliko načina se graf može obojiti ako koristimo najviše \textbf{k} boja. Svaki čvor može poprimiti \textbf{k} boja. To znači da je ukupan broj bojanja $N$ jednak: 

\begin{equation}
N = k^{V(G)} 
\end{equation}

Valja primijetiti da u ovom brojanju veličine prostora stanja postoji više jednako vrijednih bojanja. U bojanju nije bitna točna boja, već je bitno da različiti skupovi čvorova imaju različite boje. Točno pitanje je na koliko načina možemo čvorove podijeliti u $k$ skupova (teorem \ref{thm:dioba}).  

\begin{equation}
N = \sum_{i=1}^{k} S(V(G), i)
\end{equation}

Oznaka $S(m,n)$ je za \emph{Stirlingov} broj druge vrste, gdje je $m$ broj različitih elemenata (čvorovi) koje smještamo u $n$ istovrsnih skupova boja, tako da svaka boja ima barem jedan čvor. Kako je dopušteno da skupovi mogu biti prazni, tada se problem pretvori u disjunktne probleme gdje se koristi samo $i$ skupova. 

Ako se zahtjeva da svaka od $k$ boja mora biti iskorištena, ekvivalentno da ni jedan od $k$ skupova ne smije biti prazan, tada je ukupan broj stanja nešto manji:

\begin{equation}
N = S(V(G), k) = \frac{1}{k!}\sum_{i=0}^{k} (-1)^i \binom{k}{i}(k-i)^{V(G)}  
\end{equation}

Ako se čvrsto zahtjeva da svaka boja mora biti barem na jednome čvoru, tada je to \emph{Stirlingov} broj druge vrste, gdje je i navedena formula za izračun $S(m,n)$.

Neka se promatra problem traženja kromatskog broja grafa $\chi(G)$, tj. minimalni broj boja $k$, a da se graf može legalno obojiti. Maksimalni broj za koji je to potrebno provjeriti je broj čvorova u grafu, jer je u tom slučaju svaki čvor povezan sa svakim drugim i svaki čvor mora imati svoju boju. Kromatski broj grafa je dakle ograničen odozgo brojem čvorova. Za svaki broj $k$ do $V(G)$ treba provjeriti je li je graf \textbf{k-obojiv}. Ukupan broj stanja je:

\begin{equation}
N = B(V(G)) = \sum_{i=0}^{V(G)} S(V(G), i)
\end{equation}

Broj $B(n)$ naziva se \emph{Bellov} broj i on predstavlja broj načina na koje se skup od $n$ članova može podijeliti u neprazne podskupove. Za bolji uvid koliko brzo \emph{Bellov} niz raste dane su nejednakosti (za $n\ge 8$): 

\begin{equation}
2^n \le B(n) \le n! 
\end{equation}

\emph{Bellov} broj brže raste od eksponencijalne funkcije, ali sporije od faktorijela. U ovom radu daje se dokaz za tu tvrdnju.

\begin{proof}
Prvo se pokazuje nejednakost: $2^n\le B(n), n \ge 5$.
Dokaz se provodi indukcijom. Koriste se razvoj binoma: 
\[ 2^n=(1+1)^n = \sum_{k=0}^{n}\binom{n}{k} \] 
i svojstvo Bellovog broja: 
\[ B(n+1)=\sum_{k=0}^{n}\binom{n}{k}B(k) \]
	\begin{align}
		2^n \le B(n) \\
		\textup{Baza indukcije: } n = 5, 2^5 \le B(5) \rightarrow 32 \le 52 \\
		\textup{Pretpostavka: } 2^n \le B(n) \\
		2^{(n+1)} \le B(n+1) \\
		2\cdot 2^n \le B(n+1) \\
		\sum_{k=0}^{n} 2\cdot \binom{n}{k} \le \sum_{k=0}^{n}\binom{n}{k}B(k)\\
		\sum_{k=0}^{3} 2\cdot \binom{n}{k} + \sum_{k=4}^{n} 2\cdot \binom{n}{k} \le \sum_{k=0}^{3}\binom{n}{k}B(k) + \sum_{k=4}^{n}\binom{n}{k}B(k) \\
		\textup{Prvo se dokazuje: } \sum_{k=0}^{3} 2\cdot \binom{n}{k} \le \sum_{k=0}^{3}\binom{n}{k}B(k) \\
		2\binom{n}{0} + 2\binom{n}{1} + 2\binom{n}{2} + 2\binom{n}{3} \le \\ \binom{n}{0}B(0) + \binom{n}{1}B(1) + \binom{n}{2}B(2) + \binom{n}{3}B(3) \\
		2+2n+\frac{n(n-1)}{2}2+\frac{1}{3}n(n-1)(n-2) \le \\1 + n + \frac{n(n-1)}{2}2+\frac{n(n-1)(n-2)}{6}5 \\
		1+n \le n(n-1)(n-2)(\frac{5}{6}-\frac{1}{3}) \\
		1+n \le \frac{n(n-1)(n-2)}{3} \\
		3+3n\le n^3 - 3n^2 +3n \\
		3n^2+3 \le n^3 \\
		3 \le n^3 - 3n^2 \\
		3 \le n^2 (n - 3), \textup{istina za } n\ge 5 \\
		\textup{Druge dvije sume: } \sum_{k=4}^{n} 2\cdot \binom{n}{k} \le \sum_{k=4}^{n}\binom{n}{k}B(k) \\
		\textup{Član po član sume: }\binom{n}{k} 2 \le \binom{n}{k} B(k) \\
		2 \le B(k), \textup{za } k \ge 4
	\end{align}
\end{proof}

\begin{proof}
	Potrebno je dokazati $B(n) \le n!$. Dokaz se provodi iz svojstava za Bellov broj \cite{lit20}:
	\[ B(n) \le \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \] 
	i svojstvo faktorijela koja slijedi iz analize Stirlingove aproksimacije: \[ n!\ge \left ( \frac{n}{e} \right )^n \]
	\begin{align}
		B(n) \le \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \le \left ( \frac{n}{e} \right )^n \le n! \\
		\textup{Dovoljno je pokazati: } \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \le \left ( \frac{n}{e} \right )^n \\
		\left [ \frac{0.792 n}{ln(1+n)} \right ] \le \left ( \frac{n}{e} \right ) \\
		0.792 n\cdot e \le n \cdot ln(n+1) \\
		0.792\cdot e \le ln(n+1) \\
		e^{0.792\cdot e} \le n+1 \\
		8.61 -1 \le n \\
		7.61 \le n
	\end{align}
\end{proof}

Zaključak prethodne analize je da za relativno veliki graf postoji velik broj stanja koje je nemoguće pretražiti pomoću \emph{iscrpne pretrage}. Analiza prostora stanja za zadani problem malo je drugačija. Kako svaki čvor ima konačan broj boja koje može poprimiti, ukupan broj stanja je:

\begin{equation}
N = \prod_{i=1}^{V(G)} K_i,
\end{equation}
gdje je oznaka $K_i$ ukupan broj boja koje može poprimiti čvor s indeksom $i$. Kako je moguće dodijeliti maksimalno samo $512$ boja, možemo ograničiti $K_i$:
\begin{equation}
K_i \le M = 512
\end{equation}
\begin{equation}
N = \prod_{i=1}^{V(G)} K_i \le \prod_{i=1}^{V(G)} M = M^{V(G)}
\end{equation}

Broj stanja eksponencijalno ovisi o broju čvorova, što je isto kao i za klasičan problem bojanja grafa, jako velik broj stanja. I u ovom je slučaju važno primijetiti da su neka stanja ekvivalentna. Broj jedinstvenih stanja broj je particija skupa čvorova u skupove boja, ali uz ograničenje da barem jedan čvor ima neku od zadanih $M$ boja, tada vrijedi ova nejednakost za broj različitih stanja:

\begin{equation}
N \le \sum_{i=1}^{M} S(V(G), i)
\end{equation}

Broj stanja je manji jer se poštuje ograničenje da čvorovi mogu poprimiti neku od boja u podskupu od ukupnog konstantnog broja boja $M$. Kada je $k\ge M$ tada je broj stanja optimizacijskog problema manji od broja stanja u problemu gdje se traži odgovor na pitanje je li je graf \textbf{k-obojiv}. Ovo će razmatranje biti zanimljivo i u sljedećem poglavlju, gdje se problem svrstava u klase računske teorije složenosti.

\subsection{Pozadina problema iz perspektive računske teorije složenosti}

Problem odluke je li je graf \textbf{k-obojiv} spada u klasu \textbf{NP-potpunih} problema. Traženje kromatskog broja grafa $\chi(G)$ spada u klasu \textbf{NP-teških} problema. Dokazi se mogu pronaći u \cite{lit16}. Potrebno je pokazati da postavljen optimizacijski problem bojanja grafa spada u klasu \textbf{NP-teških} problema. Problem sigurno ne može spadati u druge spomenute (P, NP, NP-potpun) klase jer to nije problem odluke.
Postupak dokazivanja da problem spada u klasu \textbf{NP-teških} problema ima nekoliko koraka. Prvi korak je pronalaženje nekog \textbf{NP-potpunog} ili \textbf{NP-teškog} problema koji će se koristiti u dokazu. Zatim se pokaže da je taj \emph{postojeći} problem moguće polinomno reducirati na problem za koji se dokazuje da je \textbf{NP-težak}. U ovom radu provodi se dokaz. 

\begin{proof}
Odaberemo \textbf{NP-potpun problem} koji ispituje je li je graf $G$ \textbf{k-obojiv}. Kako bismo riješili taj problem, koristimo zadani optimizacijski problem. Ulaz u optimizacijski algoritam među ostalim su graf $G$ i ograničenja boja za svaki od čvorova. Svakom čvoru daje se skup $\{1,2,...,k\}$ s bojama. Svim bridovima daje se težina $1$. Tada se pokreće jezgra s optimizacijskim problemom koja će riješiti taj problem. Ako je rezultat optimizacije tj. funkcije cilja $f=0$, tada je graf \textbf{k-obojiv}, inače nije. U konstantnom vremenu možemo reducirati problem, iz čega slijedi da je optimizacijski problem \textbf{NP-težak}.  
\end{proof}

Zanimljivo je primijetiti da \textbf{NP-potpun} problem k-obojivosti može imati više stanja od \textbf{NP-teškog} problema optimizacije što znači mogućnost kraćeg vremena izvođenja od vremena provjere k-obojivosti. Kako nije poznat odnos \emph{NP} i \emph{P} klase, za ovaj optimizacijski problem nameće se korištenje heuristika. U ovom tehničkom problemu nije potrebno do kraja minimizirati funkciju cilja, nego dobiti dovoljno malu vrijednost $f$ koja će uzrokovati bolju kvalitetu mobilne mreže. 

\subsection{Posljedica "\emph{No free lunch}" teorema}

U originalnom članku, gdje se dokazuje "\emph{No free lunch}" teorem \cite{lit15}, pretpostavlja se da sve funkcije cilja imaju iste domene i kodomene. Za problem bojanja grafova to nije tako, jer funkcija cilja nema istu kodomenu za sve grafove. Funkcija cilja definirana je kao: $f:\mathbb{X}^{V(G)} \rightarrow \mathbb{R}$, ali kako računalo ima konačnu memoriju, tada je funkcija zapravo definirana kao: $f:\mathbb{X}^{V(G)} \rightarrow \mathbb{Y}$, gdje je $\mathbb{Y}$ konačni podskup realnih brojeva koji se mogu prikazati na računalu, a $\mathbb{X}$ skup boja. Problem za "\emph{No free lunch}" teorem je taj da veličina domene funkcije cilja ovisi o broju čvorova grafa. Broj grafova je beskonačan jer možemo uzeti proizvoljan broj čvorova, što znači da postoji i beskonačan broj mogućih funkcija cilja. Teorem radi samo ako je broj funkcija cilja ograničen (teorem \ref{thm:nofreelunch}). Kako je na nekom računalu nemoguće prikazati proizvoljno veliki graf, broj čvorova može se ograničiti s nekom granicom $L$. Tada je moguće prebrojati sve funkcije cilja $f$, što je napravljeno u nastavku rada.

\begin{proof}
Pitanje je koliko funkcija postoji, ako je broj članova domene ograničen s $L$.
Broj funkcija koje imaju točno $k$ elemenata u domeni ima:
	\begin{equation}
		|\mathbb{F}_k| = |\mathbb{Y}|^k
	\end{equation}
Ukupan broj funkcija je suma po svim $k$ do granice $L$ (koristi se suma za geometrijski niz):
	\begin{equation}
		|\mathbb{F}| = \sum_{k=1}^{L}|\mathbb{F}_k| = \sum_{k=1}^{L} |\mathbb{Y}|^k = \frac{|\mathbb{Y}|^{L+1}-|\mathbb{Y}|}{|\mathbb{Y}|-1}
	\end{equation}
\end{proof} 

Ako se ograniči broj čvorova, dobije se konačan broj funkcija te je to lako ugraditi u teorem \ref{thm:nofreelunch}. Teorem govori o tome kako ne postoji nikakvo znanje o funkciji. U ovom problemu funkcija cilja direktno ovisi o grafu tj. strukturi i to je važna informacija koja treba biti iskorištena da bi se dobili bolji algoritmi. Glavna je posljedica ovog teorema razvoj pohlepnih algoritama koji koriste znanje o strukturi (grafu) i primjena tih algoritama u metaheurističkim postupcima. 
Važno je uočiti da svaki graf posjeduje vlastitu funkciju cilja. To znači da se korištenjem algoritama na slijepo koji rade na nekim grafovima ne može jamčiti efikasnost na drugim.

U članku \cite{lit9} opisuje se kako postoje slučajevi u kojima hiper-heuristike mogu imati "\emph{Free lunch}" svojstvo. Hiper-heuristike su algoritmi koji traže najbolji algoritam koji može riješiti neki problem, tj. pronaći ekstrem funkcije cilja. Kako je gore opisano, svaki graf ima svoju funkciju cilja. Ako je skup funkcija cilja dovoljno malen, moguće je da hiper-heuristika uvijek pronađe neki algoritam koji je bolji od svih ostalih za konkretnu funkciju cilja. Ovo nije dokazano za bojanje grafova (tako ni za optimizacijski problem bojanja), ali daje motivaciju u razvoju algoritama. U zadnjem dijelu opisa algoritama u ovom radu koriste se metode strojnog učenja kako bi se izvuklo znanje za primjenu u nekim pohlepnim algoritmima, tj. kako bi se odabrao najbolji pohlepan algoritam, što je zapravo jednostavan oblik hiper-heuristike. Osim toga, u implementaciji je otvoren prostor gdje se lako mogu donositi odluke i dinamički birati algoritmi koji u trenutnoj točci u prostoru stanja daju bolje rezultate od drugih algoritama.

\chapter{Algoritmi}

\section{Uvod}

Algoritmi koji su implementirani za ovaj problem podijeljeni su u dva dijela. Prva skupinu čine pohlepni pohlepni algoritmi, a drugi algoritmi s kojima se i rad bavi su metaheuristike. Proučavaju se četiri metaheuristike: agentski algoritam, simulirano kaljenje, genetski algoritam i genetsko kaljenje. Započinje se s konstruiranjem hiper-heuristike nad pohlepnim algoritmima, gdje se želi pokazati koji je pohlepni algoritam najbolji u raznim slučajevima. Pri ispitivanju algoritama treba biti veoma oprezan. Prethodna razmatranja upućuju na to da neki algoritam (metaheuristika s određenim parametrima) može dati bolje rezultate od drugih algoritama na nekim grafovima, dok je na nekim grafovima obrnuta situacija. To se može usporediti s pojmom \emph{prenaučenosti} iz strojnog učenja. Zbog toga je za ovaj problem potrebno graditi algoritme koji su prilagodljivi.

\subsection{Mogući problemi}

Mogući problemi mogu se podijeliti na dva dijela: problemi vezani uz ograničenja i problemi vezani uz implementaciju. Problemi vezani uz ograničenja su: velik broj čvorova i bridova koji se mogu pojaviti, velika razlika između težina bridova (razlika za više redova veličina), nepromjenjivi čvorovi koji su okruženi promjenjivim čvorovima. Velik broj čvorova i bridova uzrukuje i sporji rad algoritma. Razlika između težina bridova može kod algoritama koji koriste tu razliku uzrokovati neočekivano ponašanje (npr. dugo zadržavanje na manjim vrijednostima funkcije cilja). Neopromjenjivi čvorovi koji za susjede imaju promjenjive čvorove mogu uzrokovati sporu konvergenciju, a često je zbog takvh čvorova minimum funkcije cilja relativno velika vrijednost, pa je teško razlikovati lokalni od globalnog minimuma. 

Problemi vezani uz implementaciju su zapravo problemi dizajna algoritama i struktura podataka. S jedne je strane potrebno osigurati brze operacije nad grafom, a s druge strane grafovi mogu zauzimati velik dio memorijskog prostora. Zato je potrebno dizajnirati strukturu grafa koja ne zauzima previše memorijskog prostora, a omogućuje brze operacije. Moguće probleme stvaraju i populacijski algoritmi kod kojih je potrebno čuvati više rješenja. Zbog toga se jedinke ne čuvaju kao grafovi, već je svaka jedinka funkcija bojanja grafa (za svaki čvor zna se koja je njegova boja). Sama struktura (bridovi) sadržanja je u strukturi grafa, a jedinka posjeduje vezu na taj graf.

\section{Pohlepni algoritam}

Pojam pohlepnog algoritma u ovom radu podrazumijeva sortirati čvorove grafa po nekom svojstvu, zatim obilaziti čvorove tim redoslijedom i na svaki od njih primijeniti odabranu vrstu bojanja čvora. Vrsta bojanja čvora je način odabira boje za neki čvor. Pohlepni se algoritam koristi kao operator kod metaheuristika, tj. kao metoda koja usmjeruje pretragu.
U radu se koriste sljedeće metode za sortiranje i bojanje čvorova (za svaku od metoda koristi se specijalna oznaka):

Vrste sortiranja čvorova:

\begin{itemize}
	\item \emph{COL} - sortiranje čvorova prema koliziji (broj susjednih čvorova koji imaju istu boju kao i promatrani čvor)
	\item \emph{FIT} - sortiranje čvorova prema pogrešci koju generiraju (suma težina konfliktnih bridova iz tog čvora)
	\item \emph{LDO} - sortiranje prema stupnju čvora $H(v)$
	\item \emph{RND} - slučajan raspored čvorova
	\item \emph{SDO} - sortiranje prema zasićenju (broj različitih boja susjednih čvorova)
	\item \emph{SDOLDO} - sortiranje prema zasićenju, a ako dva čvora imaju isto zasićenje drugi kriterij je stupanj čvorova [članak]
	\item \emph{STDORD} - sortiranje prema oznaci čvora (čvorovi su numerirani)
\end{itemize}

Vrste bojanja čvorova su:

\begin{itemize}
	\item \emph{ABW} - susjedi čvora sortiraju se silazno prema težini brida, obilazi se svaki susjed i uzima se njegova boja. Ako je ta boja jedna od dopuštenih za promatrani čvor, ta boja više ne može biti odabrana. Kada na raspolaganju ostane samo jedna boja ili su svi susjedi posjećeni, uzima se jedna od boja koja je još uvijek na raspolaganju. 
	\item \emph{MC} - za svaku dopuštenu boju čvora može se izračunati vrijednost kolizije za promatrani čvor. Boja koja minimizira koliziju za neki čvor odabire se kao nova boja za taj čvor.
	\item \emph{MF} - isto kao i \emph{MC}, samo što se umjesto kolizije računa greška promatranog čvora (suma težina konfliktnih bridova vezanih za taj čvor)
	\item \emph{RND} - daje se slučajna dopuštena boja
	\item \emph{START} - čvoru se daje početna boja (ako je dopuštena) ili se boja ne mijenja ako u inicijalnom bojanju boja nije bila dopuštena
	\item \emph{SWAP} - čvoru se daje neka boja gdje apsolutno odstupanje od greške (sume konfliktnih bridova) naspram trenutne greške nije veće od nekog praga
	\item \emph{TRG} - čvoru se daje neka boja čija nova greška (suma konfliktnih bridova) ne prelazi neku fiksnu vrijednost. 
\end{itemize}

Način na koji se vrši lokalna pretraga, odnosno donosi odluka o bojanju čvora važan je dio rješavanja problema bojanja grafova. Jedan od takvih načina opisan je u radu \cite{lit11}, što daje motivaciju za proučavanje postupaka bojanja. Za svaki čvor može se reći da ima određen stupanj slobode. Stupanj slobode može se definirati kao mogućnost odabira boja za neki čvor. Svaki čvor ako odabire boju nekom heuristikom, npr. želi minimizirati svoj doprinos greške, odabire boju koja odgovara minimalnoj lokalnoj grešci. Ako čvor ima npr. velik broj susjeda tada je njegov stupanj slobode manji, jer može odabrati manji broj boja kako bi minimizirao lokalnu grešku. Zato se sortiranjem čvorova po svojstvu (svojstvo koje opisuje koliko je čvor slobodan) daje prednost prvenstva bojanja čvorovima koje je teže obojiti tj. imaju manji stupanj slobode. Time se pokušava usrednjiti vrijednost stupnjeva slobode, jer čvorovi koji kasnije odabiru boju mogu odabrati veći skup boja i time bolje se prilagoditi odluci susjeda koji imaju manji stupanj slobode. Takve analize mogu se pronaći u \cite{lit5, lit12}.

\subsection{Neispravnost pohlepnog algoritma}

Važno je pokazati kako pohlepni algoritam neće uvijek pronaći globalni minimum funkcije cilja. Neka je zadan graf na slici \ref{fig:greedy_alg}.
Slika \ref{fig:crown_empty} prikazuje graf koji je potrebno bojati korištenjem samo dvije boje. Neka su težine svih bridova jednake $1$. Slika \ref{fig:crown_normal} prikazuje 2-legalno obojen graf čija je vrijednost funkcije cilja u optimizaciji jednaka $0$. 
Neka pohlepni algoritam poreda prva tri čvora kako je to označeno na slici \ref{fig:crown_wrong}. Tim poretkom čvorovi biraju svoje boje. Čvor $1$ može odabrati proizvoljnu boju, čvor $2$ odabere istu boju kao i čvor $1$, a treći čvor koji je vezan na čvor $1$ odabire neku novu boju. Ostali čvorovi mogu proizvoljim redosljedom birati svoje boje, ali više ne postoji način na koji bi čvorovi odabrali boje, a da graf bude 2-legalno obojen. Greška se dogodila pri odabiru boje za čvor $2$, jer ni jedan susjed nije bio obojen i čvor $2$ imao je mogućnost odabira iste boje kao i čvor $1$.

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_empty.pdf}
                \caption{Neobojen graf}
                \label{fig:crown_empty}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_normal.pdf}
                \caption{2-legalno obojen graf}
                \label{fig:crown_normal}
        \end{subfigure}
         
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_wrong.pdf}
                \caption{Odabir prva tri čvora}
                \label{fig:crown_wrong}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_wrong_full.pdf}
                \caption{Pogrešno obojen graf}
                \label{fig:crown_wrong_full}
        \end{subfigure}
        \caption{Prikaz pravilno obojenog grafa i primjer pohlepnog algoritma}
        \label{fig:greedy_alg}
\end{figure}


Moguće bi rješenje navedenog problema moglo biti u pretraživanju susjednih čvorova. Neka su boje označene brojevima, gdje je prva boja označena s $1$. Prvi čvor odabere se slučajno. Za odabrani se čvor odabere boja s minimalnom oznakom, a nema je u susjednim čvorovima. Sljedeći će čvor biti neki od susjeda trenutnog čvora. Ako čvor nema susjeda za odabir, onda se traži čvor koji nije obojen ali ima obojenog susjeda (pretpostavka je da je graf povezan). Ovako opisan algoritam uvijek će dobro bojati graf na slici \ref{fig:crown_empty}. Potrebno je, ako ima, pronaći graf na kojem ovakav pohlepni algoritam koji se još i naziva \emph{uspinjanje na vrh} ne radi dobro. Primjer takvog grafa i odabir čvorova može se vidjeti na slici \ref{fig:hill_climbing}. Brojevi u čvorovima predstavljaju poredak obilaženja grafa. Na slici \ref{fig:hill_climbing_ok} odabir čvorova je takav da je ukupan broj boja, a da funkcija cilja bude $0$ jednak $3$. To je ujedno i minimalni broj boja, jer u grafu postoje tri čvora koja su međusobno povezana, što bi značilo da s manjim brojem boja nije moguće legalno bojati graf. Na slici \ref{fig:hill_climbing_wrong} odabir čvorova je bio takav da u zadnjem posjećenom čvoru $8$ bilo potrebno odabrati novu boju da bi graf bio legalno obojen. Kako se pokazalo da je graf moguće bojati s $3$ boje, zaključak je da algoritam ne daje uvijek točan rezultat.

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
                \includegraphics[width=\textwidth]{Slike/hill_climbing_ok.pdf}
                \caption{Dobar odabir čvorova}
                \label{fig:hill_climbing_ok}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.4\textwidth}
                \includegraphics[width=\textwidth]{Slike/hill_climbing_wrong.pdf}
                \caption{Loš odabir čvorova}
                \label{fig:hill_climbing_wrong}
        \end{subfigure}
        \caption{Isti algoritam uz drugačiji odabir čvorova daje različita k-legalna bojanja}
        \label{fig:hill_climbing}
\end{figure}



\section{Agentski algoritam}

Agentski algoritam inspiriran je dobrim rezultatima pohlepnog algoritma. Glavna jedinica algoritma je agent. Agenti se raspoređuju po grafu, gdje se neki agent postavlja na neki čvor grafa. \emph{Globalna iteracija} je jedna iteracija algoritma u kojoj svaki agent svome čvoru pridruži neku boju. Agenti se boduju i to tako da na početku svi imaju $0$ bodova, a nakon globalne iteracije broj bodova je za nekog agenta jednak maksimalnoj pogrešci nekog susjednog čvora, na koji se i agent pomakne. Zatim se agenti sortiraju prema bodovima i u sljedećoj globalnoj iteraciji pravo na bojanje prvo dobiva agent s najviše bodova. Slično kao i kod pohlepnog algoritma, prvo se obrađuju \emph{teški čvorovi}, a to je u ovom algoritmu modelirano pomoću bodovanja. Agenti se, osim akcije pomaka na \emph{najbolji} čvor, mogu se pomaknuti na slučajan susjedni čvor ili pak ostati na čvoru na kojem jesu, ali tada bodovi za agenta ostaju isti. Algoritam posjeća na mravlje algoritme \engl{ant colony optimization} \cite{lit3}, ali kako se algoritam daje lošije rezultate za klasični problem bojanja grafova u radu je odlučeno koristiti agentski algoritam.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Broj agenata - $N$
	\item Broj globalnih iteracija - $G$
	\item Način na koji agenti bojaju čvorove (vrsta bojanja) - $CS$
	\item Vjerojatnost ostajanja agenta na trenutnom čvoru - $PR\_NO\_MOVE$
	\item Vjerojatnost pomaka agenta na slučajni čvor u susjedstvu - $PR\_RND\_MOVE$
\end{enumerate}

\subsection{Detalji algoritma}

Koristi se pseudok\^{o}d kako bi se algoritam opisao formalno. U sustavu se nalazi $N$ agenata koje je prvo potrebno inicijalizirati, odnosno postaviti svakog agenta na neki od čvorova grafa. U svakoj se od $G$ globalnih iteracija, prolazi kroz populaciju agenata i svaki od njih prvo pridruži svome čvoru boju, a nakon toga radi funkciju pomaka. Nakon što se to obavi za svakog agenta, agenti se sortiraju prema bodovima koje su dobili u funkciji pomaka "\emph{MOVE}". U sljedećoj se iteraciji agenti obilaze po bodovima, od onog agenta koji ima najviše bodova do onog s najmanje bodova.

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d agentskog algoritma]
		ALGORITHM(N, G, CS, PR_NO_MOVE, PR_RND_MOVE):
			AGENT[N]
			FOR i = 1 TO N:
				init(AGENT[i])
			END FOR
			FOR j = 1 TO G:
				FOR i = 1 TO N:
					SETCOLOR(AGENT[i], CS)
					MOVE(AGENT[i], PR_NO_MOVE, PR_RND_MOVE)
				END FOR
				SORT(AGENT[N])
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}

Funkcija pomaka ovisi o promatranom agentu i parametrima tj. vjerojatnostima "$PR\_NO\_MOVE$" i "$PR\_RND\_MOVE$". Prvo se radi odabir ostaje li agent na istom čvoru ili ne. Ako ne ostaje, opet se stohastički određuje akcija ide li agent na čvor koji u susjedstvu radi najveću grešku ili ide na slučajnog susjeda. Ako agent odabire pomak prema najboljem susjedu, sljedeći čvor ne može biti isti onaj s kojeg je agent došao na trenutno promatrani, čime se sprječava titranje agenta.

\begin{singlespace}
	\begin{lstlisting}[caption=Detalji funkcije pomaka - MOVE]
		MOVE(AGENT, PR_NO_MOVE, PR_RND_MOVE):
			IF random() < PR_NO_MOVE THEN
				RETURN
			END IF
			NEXT_NODE = AGENT.NODE
			IF random() < PR_RND_MOVE THEN
				NEXT_NODE = AGENT.NODE.NEIGHBOUR[random()]
			ELSE
				FOR k = 1 TO AGENT.NODE.DEGREE:
					IF AGENT.NODE.NEIGHBOUR[k] = AGENT.BLOCK_NODE THEN
						CONTINUE
					ERROR = AGENT.NODE.NEIGHBOUR[k].ERROR
					IF ERROR > MAX_ERROR THEN
						MAX_ERROR = ERROR
						NEXT_NODE = AGENT.NODE.NEIGHBOUR[k]
					END IF
				END FOR
					AGENT.SCORE = MAX_ERROR
			END IF
			AGENT.BLOCK_NODE = AGENT.NODE
			AGENT.NODE = NEXT_NODE
		END MOVE
	\end{lstlisting}
\end{singlespace}

\subsection{Karakteristike algoritma}

Kako je algoritam temeljen na pohlepnom algoritmu ima nedostatak što lako zapinje u lokalnom minimumu. Dobra je strana algoritma što jedna globalna iteracija može vremenski trajati kraće od jedne iteracije pohlepnog algoritma, jer može posjedovati broj agenata manji od broja čvorova. Algoritam ima ugrađeno određeno znanje, tj. agent cilja na čvorove koje mora popraviti. Prednost dobivaju agenti koji moraju popraviti čvorove s većim greškama. Da bi se izbjegla brza konvergencija u legalni minimum, stohastički način odabira pomicanja omogućuje da agenti šetnjom dođu u područje koje bi trebalo popraviti. Ako je broj agenata veći od broja čvorova, to omogućuje fino traženje minimuma. U tom će slučaju jedan čvor biti više puta obojen (minimiziran), a to znači da mu se prvo može dati neka boja, zatim se bojaju susjedi i onda opet taj isti čvor dolazi na red. Taj efekt propitkivanja starog poteza (koji se u ovom slučaju implicitno događa) omogućuje bolju odluku za pridruživanje boje. Nedostatak je produljenje vremena trajanja globalne iteracije.

Vremenska složenost algoritma ovisi o broju agenata i broju globalnih iteracija. Vremenska složenost je: $O(G\cdot(N+Nlog(N))=O(G\cdot N+G\cdot Nlog(N))=O(G\cdot Nlog(N))$. Kao što je vidljivo, algoritam polinomno ovisi o $G$ i $N$. U ovoj analizi složenosti, kao i ostalim koje slijede zanemarena je složenost izračuna funkcije cilja. Svaki algoritam za svako rješenje koje pamti dodatno koristi broj koraka koji je proporcionalan broju bridova u grafu, jer je vremenska složenost funkcije cilja $O(E(G))$. 

\section{Algoritam evolucijske strategije}

Skupina evolucijskih algoritama veoma je popularna u rješavanju optimizacijskih problema. Takvi algoritmi spadaju u još veću skupini algoritama koji se nazivaju \emph{metaheuristike}, što znači da konkretno ponašanje algoritma ovisi o postavljenim parametrima. Svim evolucijskim algoritmima zajedničko je što posjeduju populaciju rješenja, te iz koraka u korak evoluiraju rješenje, što nužno ne mora značiti dobivanje boljeg rješenja, već algoritmi provode usmjereno pretraživanje prostora stanja. Evolucijska strategija vrsta je evolucijskog algoritma kod kojeg je dominantan operator mutacije. Genetski algoritam je poopćenje evolucijskih strategija jer se koristi operator selekcije, te se operator križanja koristi češće od operatora mutacije. Operator selekcije koristi se za odabir roditelja. Operator križanja je operator koji kombinira roditelje (rješenja) i njihovom kombinacijom (nije definirano kako) generira djecu (nova rješenja). Križanje se koristi kako bi se prostor stanja finije pretraživao, tj. kako bi se vršila lokalna pretraga. Operator mutacije djeluje nad jednim djetetom i mijenja izgled te jedinke. Mutacija se koristi kako bi se pretraga pomakla u neki drugi dio prostora stanja i zadužena je za sprečavanje konvergencije u lokalne ekstreme. 

\subsection{Genetski algoritam}

Kao preliminarni dio ovog rada, isprobano je nekoliko vrsta genetskih algoritama. Jednostavni genetski algoritam koristi turnirsku selekciju, operator križanja s jednom točkom prekida, te mutacijom koja slučajno promijeni nekoliko gena u zapisu rješenja. Algoritam se pokazao veoma lošim na problemu optimizacijskog problema bojanja grafova. Ako se kao rješenje koristi niz brojeva, gdje svaki element predstavlja jedan čvor u grafu, a vrijednost elementa boju, tada operator križanja nema previše smisla zbog toga što su čvorovi povezani u određenu strukturu, a križanje s jednom točkom prekida nema znanje o tome. Drugi je problem slučajna mutacija, koja može rješenje staviti u neki drugi dio prostora stanja, ali je teško odrediti njen utjecaj i jako ovisi o konkretnom grafu. Drugi je korak bilo korištenje hibridnog genetskog algoritma u kojem je za operator mutacije korišten pohlepni algoritam. Rezultati u ovom slučaju također nisu bili dobri, tj. algoritam se ponašao kao slučajna pretraga prostora. Najveći je problem podešavanje parametara i njihova osjetljivost. Jedno od mogućih pristupa je kreiranje operatora križanja koji je usko povezan uz domenu problema, jedan od primjera naveden je u \cite{lit17}. Drugi pristup je izbacivanje operatora križanja, čime se efektivno dobiva evolucijska strategija. Takav se pristup koristi u članku \cite{lit12}, gdje je zamijećeno loše ponašanje genetskog algoritma tj. jednostavnih operatora križanja. U ovom radu koristi se evolucijska strategija. Takav je izbor načinjen zbog očekivanog manjeg vremena izvođenja evolucijske strategije, jer se koristi jedan operator manje, za razliku od genetskog algoritma. Mutacija u tom slučaju poprima dvojaku ulogu, tj. potrebno je implementirati više vrsta mutacija - one koje će obavljati lokalnu pretragu i one koje će obavljati globalnu pretragu.

\subsection{Evolucijska strategija}

Odabrana je evolucijska strategija koja se koristi u članku \cite{lit17}. Koristi se ($\mu$, $\lambda$) evolucijska strategija. Oznake $\mu$ i $\lambda$ služe za oznake skupova jedinki (rješenja). Skup $\mu$ je skup roditeljskih jedinki iz kojih se stvara skup djece $\lambda$. Iz toga proizlazi da broj elemenata u skupu $\lambda$ mora biti veći ili jednak broju elemenata u skupu $\mu$. Jedinka je predstavljena kao niz brojeva, gdje svaki element predstavlja neki čvor, a vrijednost elementa je boja čvora. U svakoj iteraciji algoritam uniformno bira $|\lambda|$ jedinki iz skupa roditelja. Može se dogoditi da je neka jedinka više puta odabrana. Za svaku odabranu jedinku koristi se operator mutacije. Slučajnim se odabirom bira između mutacije koja ima lokalni karakter tj. trenutno rješenje nastoji poboljšati lokalnom pretragom prostora stanja i mutacije koja skače iz okoline trenutne točke prostora stanja. Mutacija se implementira pomoću vrsta bojanja. Sve se takve mutiranje jedinke stavljaju u skup $\lambda$. Na kraju postupka najboljih $|\mu|$ jedinki kopira se u $\mu$ skup. Poželjno je koristiti elitizam kako se najbolje rješenje kroz iteracije ne bi izgubilo.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Veličina skupa $\mu$ - $MI\_SIZE$
	\item Veličina skupa $\lambda$ - $LAMBDA\_SIZE$
	\item Ukupan broj iteracija - $N$
	\item Broj mutacija nad jednom jedinkom - $M$
	\item Vjerojatnost mutacije gena pomoću lokalne pretrage - $PROP$
	\item Način bojanja za lokalnu pretragu - $CS\_GLOBAL$
	\item Način bojanja za globalnu pretragu - $CS\_LOCAL$
\end{enumerate}

\subsection{Detalji algoritma}

Kostur algoritma izgleda veoma jednostavno. Kao što je opisano, iz skupa $\mu$ bira se jedinka koja se mutira i stavlja u $\lambda$ skup. Najbolji se kopiraju u skup $\mu$ i brišu se sve stare jedinke. 

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d evolucijske strategije]
		ALGORITHM(MI_SIZE, LAMBDA_SIZE, N, M, PROP, CS_GLOBAL, CS_LOCAL):
			MI[MI_SIZE]
			LAMBDA[LAMBDA_SIZE]
			FOR i = 1 TO MI_SIZE:
				init(MI(i))
			END FOR
			FOR j = 1 TO N:
				LAMBDA.clear()
				FOR i = 1 TO LAMBDA_SIZE:
					unit = SELECT(MI)
					MUTATION(unit, M, PROP, CS_GLOBAL, CS_LOCAL)
					LAMBDA.insert(unit)
				END FOR
				SORT(LAMBDA)
				MI.clear()
				FOR i = 1 TO MI_SIZE:
					MI.insert(LAMBDA[i])
				END FOR
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}

Najvažnija je stvar u algoritmu operator mutacije. Operator mutacije kao argumente prima jedinku koja će se promijeniti, broj gena koji se mijenjaju (čvorova), vjerojatnost lokalne pretrage, vrstu bojanja za lokalnu pretragu i vrstu bojanja za globalnu pretragu. 

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d mutacije evolucijske strategije]
		MUTATION(unit, M, PROP, CS_GLOBAL, CS_LOCAL):
					choice = random()
					FOR i = 1 TO M:
						index = random()
						IF choice < PROP THEN
							SETCOLOR(unit[i], CS_LOCAL)
						ELSE
							SETCOLOR(unit[i], CS_GLOBAL)
						END IF
		END MUTATION
	\end{lstlisting}
\end{singlespace}

\subsection{Karakteristike algoritma}

Algoritam ima relativno velik broj parametara, što ga čini teškim za prilagodbu konkretnom problemu (grafu). Veličine skupova za roditelje i djecu trebali bi biti relativno mali zbog vremena izvođenja. Većina je parametara vezana za mutaciju i to je najosjetljiviji dio algoritma. Potrebno je osigurati čestu lokalnu pretragu, ali i s druge strane, osigurati skakanje iz lokalnih minimuma. Algoritam često zapinje na platoima. Iako konvergencija može biti brža od agentskog algoritma, vrijeme izvođenja je duže.
Vremenska složenost algoritma je ($LS$ je skraćeno za $LAMBDA\_SIZE$): $O(N\cdot(LS \cdot M + LS\cdot log(LS)))=O(N\cdot LS\cdot M + N\cdot LS \cdot log(LS))$. U praksi je čest slučaj: $LS\le M$, pa je vremenska složenost: $O(N\cdot LS \cdot M)$. Algoritam polinomno ovisi o tri parametra, što predstavlja problem ako su oni relativno veliki. S jedne je strane potrebno osigurati dovoljan broj koraka algoritma kako bi se došlo do željene vrijednost funkcije cilja, broj djece $LS$ ne smije biti premalen - kako bi se zadržao genetski kod, a veličina mutacije $M$ ne smije biti prevelika zbog velikog odstupanja, a s druge strane ne smije biti premala zbog spore konvergencije. 

\section{Simulirano kaljenje}

Simulirano kaljenje također spada u skupinu evolucijskih algoritama. Njegova specifičnost je da se koristi samo jedna jedinka koja iz koraka u korak evoluira. Algoritam je inspiriran kaljenjem metala. Rješenje se nužno ne poboljšava iz koraka u korak, ali je vjerojatnost pogoršanja rješenja kako algoritam napreduje sve manja. Dopuštanjem lošijih rješenja nastoji se izbjeći lokalni optimum. Pretpostavka je da s vremenom algoritam dolazi u željeno područje globalnog optimuma. Na početku algoritam vrši globalnu pretragu, da bi s vremenom prostor stanja počeo pretraživati na finiji način. Simulirano kaljenje se često koristi kao alat u rješavanju problema bojanja grafova kao što se to prikazuje u radu \cite{lit13}.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Početna temperatura - $T\_START$
	\item Globalni broj koraka algoritma - $G$
	\item Broj iteracija s istom temperaturom - $E$
	\item Faktor smanjenja temperature - $\alpha$
	\item Vjerojatnost lokalne vrste bojanja - $PROP$
	\item Način bojanja za lokalnu pretragu - $CS\_GLOBAL$
	\item Način bojanja za globalnu pretragu - $CS\_LOCAL$
\end{enumerate}

\subsection{Detalji algoritma}

Algoritam kreće od početnog rješenja (jedinke) koja se označava s $X$. Prikaz rješenja je klasičan, svaki čvor je element u nizu, a vrijednost  elementa je boja čvora. Susjedno rješenje od $X$ u oznaci $S$ je rješenje koje ima sve elemente niza jednake kao i $X$ osim točno jednog elementa. U svakom se koraku algoritma iz rješenja $X$ generira susjedno rješenje $S$. Ako rješenje $S$ ima vrijednost funkcije cilja manju od $X$, tada se $X$ zamjenjuje s $S$. U slučaju da je vrijednost funkcije cilja veća, tada se rješenje prihvaća s vjerojatnošću (ovisi o trenutnoj temperaturi $T$):
 
\begin{equation}
	P(X=S) = e^{-\frac{f(S)-f(X)}{T}}
\end{equation}

Kako temperatura $T$ pada, vjerojatnost prihvaćanja pada u $0$, uz pretpostavku $f(S)\ge f(X)$:

\begin{equation}
	\lim_{T\rightarrow 0 } e^{-\frac{f(S)-f(X)}{T}} = 0	
\end{equation}

U ovoj implementaciji simuliranog kaljenja koriste se dvije petlje. Vanjska, koja služi za smanjivanje temperature i unutarnja koja traži rješenja u susjedstvu s istom temperaturom $T$. Koriste se dvije vrste traženja susjeda: lokalna i globalna. Prvo služi kako bi se našlo bolje rješenje, a druga vrsta traženja služi kako bi se rješenje pogoršalo u svrhu prelaska u novo područje prostora stanja. 

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d simuliranog kaljenja]
		ALGORITHM(T_START, G, E, ALFA, PROP, CS_GLOBAL, CS_LOCAL):
			init(X)
			FOR i = 1 TO G:
				FOR j = 1 TO E:
					S = X
					IF random() < PROP THEN
						SETCOLOR(X[random()], CS_LOCAL)
					ELSE
						SETCOLOR(X[random()], CS_GLOBAL)
					END IF
					dE = f(S) - f(X)
					IF ( dE < 0 OR random() < EXP(-dE/T) ) THEN
						X = S
					END IF
				END FOR
			T = T * ALFA
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}

\subsection{Karakteristike algoritma}

Algoritam je relativno jednostavan za implementaciju. Dobra je strana što je za razliku od drugih promatranih algoritama ima manju memorijsku složenost, zbog toga što koristi samo dvije jedinke ($X$ i $S$). Za parametar početne temperature $T$ nije potrebno ispitivati najbolju vrijednost, već se može izračunati kao: za prvi korak u algoritmu potrebno je uzeti lošije rješenje s $50\%$ vjerojatnosti. Prvi se korak greške procijeni prema problemu i ponašanju algoritma: $\tilde{dE}\sim f(S_1)-f(X_1)$.  

\begin{equation}
\textup{T\_start} = -\frac{dE}{ln(P)} = 1.443 \cdot dE
\end{equation}  

Parametar $\alpha$ potrebno je namjestiti kako temperatura ne bi padala prebrzo - zapinjanje u lokalnim optimumima, ili kako ne bi padala presporo - slaba konvergencija. Vremenska složenost algoritma je: $O(G\cdot E)$, što je veoma dobro svojstvo jer samo dva parametra utječu na vrijeme izvođenja i to polinomno. 

\section{Genetsko kaljenje}

Genetsko kaljenje \cite{lit18} je algoritam koji kombinira dvije ideje: genetski algoritam i simulirano kaljenje. Ideja je ista kao i kod simuliranog kaljenja, samo što se u sustavu nalazi više jedinki (rješenja). Rješenja međudjeluju preko parametra slobodne energije. Na početku je zadana početna energija, koja se ravnomjerno raspoređuje po svim jedinkama. Za svaku se jedinku u sustavu napravi mutacija i dobiva se susjedno stanje. Nova jedinka ima neku vlastitu energiju (funkcija cilja) te se prihvaća kao novo rješenje ako je vlastita energija nove jedinke manja od zbroja stare jedinke i djela slobodne energije koju je stara čestica dobila. Tako slobodna energija utječe na odabir lošijih jedinki.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Ukupan broj iteracija - $G$
	\item Broj jedinki - $N$
	\item Početna energija - $E$
	\item Faktor hlađenja - $\alpha$
	\item Vjerojatnost lokalne vrste bojanja - $PROP$
	\item Način bojanja za lokalnu pretragu - $CS\_GLOBAL$
	\item Način bojanja za globalnu pretragu - $CS\_LOCAL$
\end{enumerate}


\subsection{Detalji algoritma}

Na početku se inicijaliziraju jedinke. Slobodna energija se postavi na početnu energiju i algoritam kreće u rad. Svaka jedinka dobije dio slobodne energije u obliku praga $T$. To znači da jedinka može odstupati od svog roditelja za najviše prag $T$ da bude prihvaćena kao nova jedinka. Ako je prihvaćena, energija koja nije iskorištena, a to je razlika energije stare jedinke i nove jedinke (gdje se prag $T$ nadodaje staroj jedinki), dodaje se u slobodnu energiju za tu iteraciju. Na kraju, da se ne bi dogodila divergencija, slobodna energija se množi s nekim faktorom $\alpha \in [0,1]$.  

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d genetskog kaljenja]
		ALGORITHM(G, N, E, ALFA, PROP, CS_GLOBAL, CS_LOCAL):
			UNITS[N]
			FOR i = 1 TO N:
				init(UNIT[i])
			END FOR
			FREE_ENERGY = E
			FOR j = 1 TO G:
				T = FREE_ENERGY / N
				FREE_ENERGY = 0
				FOR i = 1 TO N:
					new_unit = MUTATION(UNIT[i], PROP, CS_GLOBAL, CS_LOCAL)
					IF f(new_unit) < f(UNIT[i]) + T THEN
						D = f(UNIT[i]) + T - f(new_unit)
						FREE_ENERGY = FREE_ENERGY + D
						UNIT[i] = new_unit
					END IF
				END FOR
			FREE_ENERGY = FREE_ENERGY * ALFA
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}


\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d mutacije genetskog kaljenja]
		MUTATION(unit, PROP, CS_GLOBAL, CS_LOCAL):
			IF random() < PROP THEN
				SETCOLOR(unit[random()], CS_LOCAL)				
			ELSE
				SETCOLOR(unit[random()], CS_GLOBAL)
			END IF
		END MUTATION
	\end{lstlisting}
\end{singlespace}


\subsection{Karakteristike algoritma}

Algoritam izgleda veoma slično kao i simulirano kaljenje, samo što se odluka za prihvaćanje novog rješenja donosi na temelju praga tj. odstupanja funkcije cilja od stare jedinke. Međudjelovanje jedinki temelji se na slobodnoj energiji, koja se u svakoj iteraciji skuplja kao dodatak koji nije potrošen. To znači da ako u nekom koraku ni jedna nova jedinka nije prihvaćena, slobodna energija će biti $0$, a u sljedećoj će se iteraciji prihvaćat samo strogo bolje nove jedinke. S druge strane ako u nekoj iteraciji jedna jedinka postane puno bolja od roditelja, tada u sljedećoj iteraciji algoritam dopušta novim jedinkama da mogu biti puno gore od roditelja, što omogućuje izlaženje iz lokalnih optimuma i globalno pretraživanje prostora stanja. Za rješavanje optimizacijskog problema bojanja grafova koriste se dvije vrste dobivanja susjednog rješenja (mutacije). Kao i za neke prethodne algoritme, koriste se lokalna i globalna vrsta bojanja.  
Vremenska složenost algoritma je: $O(G \cdot N)$ s time da je to nešto veća vremenska složenost od simuliranog kaljenja ako se u obzir uzme računanje funkcije cilja za $N$ jedinki.

\section{Pronalaženje najpogodnijeg pohlepnog algoritma}

Pohlepni se algoritam u ovom radu koristina dva načina. Prvo se koristi kao metoda koja dovodi rješenje u dovoljno dobro početno rješenje, nakon čega minimizaciju funkcije preuzima neka metaheuristika. Drugi način korištenja je kao dio metaheuristike u obliku operatora (npr. mutacija kod genetskog algoritma), metoda za izbjegavanje lokalnog minimuma (tuneliranje) ili pak metoda koja osigurava da postotak promjene boja naspram inicijalnog grafa ne prođe zadani prag. Kod korištenja pohlepnih algoritama u praksi se često koriste \emph{ad-hoc} metode konfiguriranja istog. Prednost je ovakvih metoda što u relativno kratkom vremenu mogu isprobati različite konfiguracije i zatim odabrati najbolju. Nedostatak metode je u tome što ta konfiguracija ne jamči dobar rad nad svim grafovima (\emph{No free lunch} teorem). Kao uvod u hiper-heuristike i postavljanje temelja za budući rad, iz grafova se želi izvući znanje o utjecaju vrsta sortiranja čvorova. Ovaj dio rada ima dva cilja: Prvi je pronaći optimalni operator usporedbe čvorova koji kombinira sve dostupne operatore tj. vrste sortiranja. Drugi cilj je dovesti u vezu vrstu sortiranja i načina bojanja tj. empirijski pokazati koja vrsta sortiranja je najbolja za koji vrstu bojanja. Rezultati bi mogli pokazati određenu vezu između svojstava grafova i vrste sortiranja što bi se moglo koristi kao uvod u istraživanje hiper-heuristika. Metoda pronalaženja pogodnog pohlepnog algoritma sastoji se od koraka:

\begin{enumerate}
	\item Generiranje grafa
	\item Odabira vrste bojanja za pohlepni algoritam
	\item Pokretanje pohlepnog algoritma s vrstom sortiranja \emph{RND}
	\item Iz svih pokretanja pohlepnog algoritma uzeti određen postotak najboljih rezultata
	\item Za svaki čvor izračunati relativnu poziciju kao $\frac{x+1}{N}$ gdje je $x$ indeks u slučajno sortiranom nizu čvorova, a $N$ ukupan broj čvorova u grafu. 
	\item Za svaku relativnu poziciju izračunati svojstva tog čvora (stupanj, zasićenje, koliziju, grešku)
	\item Nekom od metoda regresije pronaći funkciju čiji su argumenti svojstva čvora, a rezultat je relativna pozicija
\end{enumerate}

Tako dobivena funkcija može se koristiti kao vrsta sortiranja. Za neke se vrste regresija veoma lako interpretiraju rezultati, pa je lako odrediti u kojoj mjeri svojstva čvora utječu na dobar rezultat. Za različite vrste bojanja moguće je uspoređivati funkcije i uočiti ovisnosti. Za različite grafove usporedbom funkcija može se izvući znanje o pogodnom algoritmu za pojedine vrste grafova. Ovaj rezultat može se koristiti kao temeljno znanje za proučavanje automatskog odabira algoritama \cite{lit14}.

\section{Tuneliranje}

\emph{Tuneliranje} je tehnika koja se može ugraditi u bilo koji optimizacijski algoritam i služi za izlazak iz lokalnog minimuma. Tehnika je vrlo slična \emph{mutacijama} kod evolucijskih algoritama. Razlika je u tome što ova tehnika ne odabire slučajno novu točku iz prostora pretraživanja stanja, već nastoji odabrati točku koja ima približnu vrijednost funkcije cilja kao i trenutna točka koja se promatra (npr. relativna razlika funkcija cilja mora biti manja od nekog praga). Kako nova točka u prostoru pretrage ima sličnu vrijednost funkcije cilja, algoritam nastoji pronaći minimum u toj okolini, a to teorijski znači da funkcija cilja može samo padati. U praksi se može dogoditi da i poraste jer se za novu točku ne zahtijeva da vrijednosti budu identične, već približno jednake. Nova se točka traži tako što se po redu pretražuje dimenzija po dimenzija linearno. U problemu optimizacije bojanja grafa to znači da se po redu za svaki čvor ispituju boje, i ako za trenutni čvor nova boja za čvor ne utječe na vrijednost greške tada se ta boja ostavlja tome čvoru. Ako se u pohlepnom algoritmu kao vrsta bojanja koristi "\emph{SWAP}" metoda, dobiva se očekivani efekt. 

U navedenom pseudok\^{o}du nova se točka postavlja u trenutnu. Zatim se vanjska petlja vrti po dimenzijama i za svaku se ispituju se svi elementi (npr. boje). Element koji za apsolutno odstupanje daje vrijednost manju od praga $T$, postavlja se kao element za tu dimenziju i potraga kreće na sljedeću dimenziju.

\begin{singlespace}
	\begin{lstlisting}[caption=Metoda tuneliranja - implementacija]
		TUNNELING(f, X)
			NEW_X = X
			FOR i = 1 TO X.length()
				FOR EACH element in DIMENSION(i):
					NEW_X.dimension(i) = element
					IF |f(NEW_X)-f(X)| < f(X)*T:
						 BREAK
					NEX_X.dimension(i) = X.dimension(i)
				END FOR
			END FOR
			RETURN NEW_X
		END TUNNELING
	\end{lstlisting}
\end{singlespace}

\section{Upravljanje postotkom promijenjenih čvorova}

Kako je sekundarni kriterij optimizacije da postotak promijenjenih čvorova naspram inicijalnog stanja ne prođe neku granicu (konkretno 66\%), potrebno je ostvariti mehanizam koji to omogućuje. U ovom se radu koristi pristup težnje boje da postane početna. U vrste bojanja implementira se mehanizam biranje boja koji, ako je početna boja jedna od mogućih, dodjeljuje početne boje vjerojatnije od svih ostalih. 

\chapter{Programsko rješenje}

\section{Uvod}

Za rješavanje zadanog optimizacijskog problema bojanja grafova i ispitivanja navedenih algoritama, odlučeno je da će se izgraditi infrastruktura koja omogućuje brzi razvoj i ispitivanje algoritama. Ideja je izgraditi radnu okolinu u kojoj korisnik može iskoristiti već napisane module za standardne operacije koje se koriste i jednostavno ih uvesti u svoj algoritam. Koristi se jezik \emph{Java} zbog relativno visoke apstrakcije, mogućnosti objektnog oblikovanja aplikacije i prenosivosti. Veoma važan cilj koji se nastoji ostvariti je infrastruktura koja je lako nadopunjiva novim modulima za buduću upotrebu. Moduli aplikacije koji su razvijeni za ovaj rad:

\begin{enumerate}
	\item \emph{main} - glavna metoda za pokretanje algoritama
	\item \emph{common} - generičke strukture podataka
	\item \emph{input} - implementacije različitih ulaznih formata
	\item \emph{output} - implementacija različitih izlaznih formata
	\item \emph{algorithm} - apstrakcija algoritma bojanja grafova
	\item \emph{unit} - jedinka (prikaz rješenja) koja se koristi u populacijskim algoritmima
	\item \emph{algorithmset} - modul za spremanje implementacija algoritama
	\item \emph{greedy} - implementacija pohlepnog algoritma
	\item \emph{color\_selector} - implementacije vrsta bojanja
	\item \emph{order} - implementacija različitih vrsta sortiranja čvorova
	\item \emph{agents} - implementacija agentskog algoritma
	\item \emph{genetic} - implementacija genetskog algoritma (strategije)
	\item \emph{simulated\_annealing} - implementacija simuliranog kaljenja
	\item \emph{structure} - najviša apstrakcija grafa - jednostavni graf
	\item \emph{weight\_graph} - apstrakcija težinskog grafa 
	\item \emph{ericsson\_graph} - graf koji posjeduje strukture pogodne za rješavanje optimizacijskog problema
	\item \emph{stat} - generičke (statičke) metode koje se koriste za računanje statistika ili svojstava koja ne spadaju u druge strukture
	\item \emph{machine\_learning} - modul za izvlačenje značajki iz grafa i pripremu podataka za strojno učenje
\end{enumerate}

U nastavku slijedi detaljni opis nekih modula koji su najvažniji za rad infrastrukture. Detaljne upute o korištenju infrastrukture priložene su u digitalnom obliku uz ovaj rad.

\subsection{Modul \emph{input}}

Funkcija ovog modula je osigurati učitavanja raznih formata zapisa grafa u datotekama. Graf u datoteci može biti zapisan proizvoljnim formatom, pa je cilj modula da obuhvati što više formata. Jedan od formata je specifičan za optimizacijski problem. Implementirani su i neki jednostavni formati. 

\subsection{Modul "\emph{output}"}

Kao što je funkcija prethodnog modula učitavanje, tako je funkcija ovog modula zapis grafa u datoteku. Podržan je jednostavan format koji zapisuje identifikator čvora i njegovu boju. Podržan je zapis koji graf pretvara u format potpun za optimizacijski problem, ali je veličina datoteke koja nastaje duplo manja od originalnog ulaznog formata. Osim zapisa grafa, ovaj modul omogućuje i ispis statistika u drugim formatima koji se mogu koristi u drugim alatima, primjerice alatima za strojno učenje.

\subsection{Modul "\emph{algorithm}"}

Modul implementira strategiju kao oblikovni obrazac. Korisnik pri pokretanju algoritma stvara kontekst u kojem navodi konkretan algoritam. Nakon toga, sučelje prema korisniku je samo kontekst. Svi algoritmi moraju imati implementirano isto sučelje. Kao što se može vidjeti u programskom odsječku \ref{alg:strategija} klasa \emph{GraphAlgorithmContext} ima privatni atribut tj. referencu koja pokazuje na konkretan algoritam. Algoritam se zadaje preko konstruktora. Implementirane su dvije metode istog naziva: \emph{startAlgorithm}, koje kao parametar primaju strukturu podataka graf (\emph{Graph}). Metode se razlikuju u drugom parametru, gdje se kao argument može dati skup identifikatora čvorova koje algoritam ne smije bojati. To nije jednako kao i nepromjenjivi čvorovi (jer to algoritam rješava interno), već se tu zadaju čvorovi koji su možda prije obojeni i s pokretanjem novog algoritma korisnik ih ne želi mijenjati. 

\begin{singlespace}
	\begin{lstlisting}[label=alg:strategija, language=Java, caption=Definicija klase i metoda za oblikovni obrazac strategija]

	public class GraphAlgorithmContext {
	
		private GraphColoringAlgorithm algorithm;
	
		public GraphAlgorithmContext(GraphColoringAlgorithm algorithm){
			this.algorithm = algorithm;
		}
	
		public void startAlgorithm(Graph graph){
			algorithm.startAlgorithm(graph);
		}
	
		public void startAlgorithm(Graph graph, Set<Integer> touchableNodes){
			algorithm.startAlgorithm(graph, touchableNodes);
		}
	
	}

	\end{lstlisting}
\end{singlespace}

U programskom odsječku \ref{alg:algorithm} pokazana je implementacija klase \emph{GraphColoringAlgorithm}. Klasa je apstrakcija algoritma za bojanje grafova. Pri stvaranju novog konkretnog algoritma korisnik je obavezan implementirati metodu \emph{algorithm}, koja je središte implementacije svakog algoritma. Uz to korisnik ima mogućnost ispitivanja smije li pobojati čvor ili ne - \emph{checkNode}. Parametre algoritma korisnik zadaje pri pozivu konstruktora za konkretni algoritam.

\begin{singlespace}
	\begin{lstlisting}[label=alg:algorithm, language=Java, caption=Apstraktna klasa algoritma]

	public abstract class GraphColoringAlgorithm {

		private Set<Integer> touchableNodes = null;
		protected Graph graph;

		protected Set<Integer> getTouchableNodes(){
			return this.touchableNodes;
		}

		protected boolean checkNode(int index){
			int id = graph.getNodeId(index);
			if (touchableNodes == null)
				return true;
			return touchableNodes.contains(id);
		}

		protected abstract void algorithm();

		public void startAlgorithm(Graph graph){
			touchableNodes = null;
			this.graph = graph;
			this.algorithm();
		}


		public void startAlgorithm(Graph graph, Set<Integer> touchNodeId){
			touchableNodes = touchNodeId;
			this.graph = graph;
			this.algorithm();
		}
	}
	\end{lstlisting}
\end{singlespace}

\subsection{Modul "\emph{unit}"}

Modul "\emph{unit}" je generička klasa koja se koristi kao prikaz rješenja u populacijskim algoritmima. Zbog prirode problema koja donosi grafove s velikim brojem čvorova i brojem bridova, neučinkovito je pamtiti više instanci grafa zbog nedostatka memorije. Zbog toga se pamte samo parovi čvor-boja, a struktura grafa zadana je referencom. Klasa \emph{GeneralUnit} pruža operacije: 

\begin{itemize}
	\item Brzo dohvaćanje funkcije cilja - \emph{getError()} - $O(1)$
	\item Dohvaćanje broja čvorova - \emph{getSize()} - $O(1)$
	\item Postavljanje boje čvoru - \emph{setColor(id, color)} - $O(H(v))$
	\item Postavljanje strukture graf u boje jedinke - \emph{updateGraph()} - $O(V(G))$
\end{itemize}

\chapter{Rezultati}

\section{Metode ispitivanja algoritama}

\subsection{Ispitivanje metaheuristika}

Nekoliko je rezultata za metaheuristike bitno kako bi se mogle uspoređivati. Dva svojstva koja najviše utjeću na dobrotu metaheuristike su najmanja postignuta vrijednost funkcije cilja i stvarno vrijeme izvođenja. Osim toga, veoma je bitan dio pronalaženje optimalnih parametara metaheuristika. Zbog toga se na skupu ispitnih grafova jedna metaheuristika ispituje s drugačijim parametrima, te se najbolji dobiveni rezultat neke metaheuristike uspoređuje s ostalim najboljim rezultatima drugih metaheuristika. Rad metaheuristika proučava se kroz iteracije. Pronalazi se ovisnost broja korištenih iteracija i vrijednosti funkcije cilja, ovisnost broja korištenih iteracija i postotka promjene inicijalnih boja te ovisnost promjene inicijalnih boja o vrijednosti funkcije cilja. Takve ovisnosti mogu pokazati neke karakteristike algoritma, kao što su brzina konvergencije, vrijeme zadržavanja u lokalnim minimumima, te dati smjer za korištenje vrsta odabira boja pri nekoj metaheuristici.

Metaheuristike se ispituju tako što se početno stanje grafa dovede pomoću pohlepnog algoritma u neku točku čija funkcija cilja ima puno manju vrijednost od početnog grafa. Cilj je pohlepnog algoritma da osigura valjano bojenje za svaki čvor, te da se greška dovede do manje vrijednosti. Koristi se pohlepni algoritam u pet koraka. Iz iteraciju u iteraciju pohlepni algoritam nastoji bojiti graf pomoću \emph{SDO} sortiranja i \emph{ABW} odabira boja. Ako algoritam zastane u lokalnom minimumu, pomoću \emph{FIT} sortiranja i \emph{MF} odabira boja nastoji se iskočiti iz tog minimuma. Pokazalo se da nakon nekog broja koraka pohlepni algoritam konvergira ili čak u nekim slučajevima divergira. Odabrano je pet koraka jer se eksperimentiranjem to pokazalo kao najbolja opcija, a da bi algoritmi i grafovi bili usporedivi tj. da pohlepni algoritam ne bi utjecao na brzinu kovergencije, za sve slučajeve ispitivanja ostavljena je ta ista inačica.

\section{Grafovi za ispitivanje}

Za ispitivanje koriste se dvije vrste grafova. Prva vrsta su grafovi koji su generirani iz realnih situacija. Druga vrsta su umjetni grafovi koji su generirani kako bi se moglo proučavati ponašanje algoritama i kako bi se mogli donositi općeniti zaključci. Sintetički primjeri generirani su tako što se promatraju različit broj čvorova i različita gustoća povezanosti istih. Za težine između čvorova uzima se distribucija iz grafova koji su generirani iz realnih situacija kako bi rezultati bili što biliži mogućim primjerima iz stvarnoga svijeta. Na slikama \ref{fig:tokai-hist} i \ref{fig:kansai-hist} vide se distribucije težina (po redu veličine) na dva grafa iz realnog svijeta. Vidljivo je da oko pola težina ima malu vrijednost oko $0$, a ostale težine pripadaju većim vrijednostima.

\begin{figure}[H]
	\includegraphics[width=\textwidth]{Slike/tokai-w-hist.pdf}
	\caption{Tokai graf - distribucija težina}
	\label{fig:tokai-hist}
\end{figure}


\begin{figure}[H]
	\includegraphics[width=\textwidth]{Slike/kansai-w-hist.pdf}
	\caption{Kansai graf - distribucija težina}
	\label{fig:kansai-hist}
\end{figure}

\begin{table}[htb]
	\caption{Popis grafova za ispitivanje}
	\label{tbl:random-test}
	\centering
	\begin{tabular}{|l|r|r|c|c|} \hline
	Naziv grafa & Broj čvorova & Broj bridova & Inicijalna pogreška & Slučajno bojanje\\ \hline \hline
		graph\_700\_0.1 & 700 & 30102 & $1.95\cdot 10^{9}$ &$1.25\cdot 10^{6}$ \\ \hline 
		graph\_700\_0.7 & 700 & 194684 & $1.93\cdot 10^{9}$ &$7.26\cdot 10^{6}$ \\ \hline 
		graph\_700\_0.3 & 700 & 89719 & $2.28\cdot 10^{9}$ &$3.30\cdot 10^{6}$ \\ \hline 
		graph\_700\_0.9 & 700 & 234311 & $1.92\cdot 10^{9}$ &$9.22\cdot 10^{6}$ \\ \hline 
		graph\_700\_0.5 & 700 & 144970 & $2.07\cdot 10^{9}$ &$5.80\cdot 10^{6}$ \\ \hline 
		graph\_500\_0.1 & 500 & 15160 & $1.38\cdot 10^{9}$ &$6.61\cdot 10^{5}$ \\ \hline 
		graph\_500\_0.7 & 500 & 99316 & $1.66\cdot 10^{9}$ &$3.70\cdot 10^{6}$ \\ \hline 
		graph\_500\_0.3 & 500 & 45927 & $1.50\cdot 10^{9}$ &$1.88\cdot 10^{6}$ \\ \hline 
		graph\_500\_0.9 & 500 & 119310 & $1.46\cdot 10^{9}$ &$4.83\cdot 10^{6}$ \\ \hline 
		graph\_500\_0.5 & 500 & 73894 & $1.46\cdot 10^{9}$ &$2.74\cdot 10^{6}$ \\ \hline 
		graph\_900\_0.1 & 900 & 50221 & $2.81\cdot 10^{9}$ &$1.99\cdot 10^{6}$ \\ \hline 
		graph\_900\_0.7 & 900 & 321598 & $2.63\cdot 10^{9}$ &$1.23\cdot 10^{7}$ \\ \hline 
		graph\_900\_0.3 & 900 & 147898 & $2.82\cdot 10^{9}$ &$5.44\cdot 10^{6}$ \\ \hline 
		graph\_900\_0.9 & 900 & 386559 & $2.58\cdot 10^{9}$ &$1.64\cdot 10^{7}$ \\ \hline 
		graph\_900\_0.5 & 900 & 239189 & $2.91\cdot 10^{9}$ &$9.90\cdot 10^{6}$ \\ \hline 
		graph\_4000\_0.1 & 4000 & 1008042 & $1.16\cdot 10^{10}$ &$3.79\cdot 10^{7}$ \\ \hline 
		graph\_4000\_0.7 & 4000 & 6346676 & $1.30\cdot 10^{10}$ &$2.41\cdot 10^{8}$ \\ \hline 
		graph\_4000\_0.3 & 4000 & 2924613 & $1.22\cdot 10^{10}$ &$1.12\cdot 10^{8}$ \\ \hline 
		graph\_4000\_0.5 & 4000 & 4733505 & $1.22\cdot 10^{10}$ &$1.80\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.7 & 3000 & 3571396 & $9.51\cdot 10^{9}$ &$1.39\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.6 & 3000 & 3131418 & $9.48\cdot 10^{9}$ &$1.20\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.9 & 3000 & 4297423 & $9.18\cdot 10^{9}$ &$1.63\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.5 & 3000 & 2666916 & $9.15\cdot 10^{9}$ &$1.03\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.8 & 3000 & 3970760 & $9.37\cdot 10^{9}$ &$1.52\cdot 10^{8}$ \\ \hline 
		graph\_2000\_0.7 & 2000 & 1589268 & $6.21\cdot 10^{9}$ &$6.13\cdot 10^{7}$ \\ \hline 
		graph\_2000\_0.6 & 2000 & 1392574 & $6.02\cdot 10^{9}$ &$5.41\cdot 10^{7}$ \\ \hline 
		graph\_2000\_0.9 & 2000 & 1910979 & $6.22\cdot 10^{9}$ &$7.36\cdot 10^{7}$ \\ \hline 
		graph\_2000\_0.5 & 2000 & 1181788 & $6.61\cdot 10^{9}$ &$4.74\cdot 10^{7}$ \\ \hline 
		graph\_2000\_0.8 & 2000 & 1764223 & $6.31\cdot 10^{9}$ &$6.62\cdot 10^{7}$ \\ \hline 
		Kansai-C & 8937 & 2259249 & $1.89\cdot 10^{7}$ &$7.40\cdot 10^{8}$ \\ \hline 
		Tokai-B & 4244 & 915283 & $1.29\cdot 10^{9}$ &$2.38\cdot 10^{8}$ \\ \hline 
		Tokai-A & 17066 & 5298396 & $1.83\cdot 10^{10}$ &$9.52\cdot 10^{8}$ \\ \hline 
		Kansai-B & 4925 & 1283991 & $7.53\cdot 10^{7}$ &$3.15\cdot 10^{8}$ \\ \hline 
		Tokai-C & 10518 & 2557187 & $5.74\cdot 10^{9}$ &$5.43\cdot 10^{8}$ \\ \hline 
		Kansai-A & 18807 & 7359859 & $4.69\cdot 10^{9}$ &$1.38\cdot 10^{9}$ \\ \hline 
	\end{tabular}
\end{table}

\section{Slučajno pretraživanje}

Kako bi se opravdalo traženje optimizacijskog algoritma za ovaj problem, potrebno je pokazati kako uniformna raspodjela boja po grafu ne daje zadovoljavajuće rezultate. Za ovu je svrhu korišten pohlepni algoritam koji za sortiranje čvorova koristi \emph{RND} metodu i također \emph{RND} vrstu bojanja. Efekt je isti kao da se obilaze čvorovi i svakom se da slučajna boja iz njegove domene. Nad svakim se grafom pokreće pohlepni algoritam pokreće deset puta, nakon čega se rezultat usrednjuje i uspoređuje s početnom pogreškom grafa.

Rezultati su prikazani u tablici \ref{tbl:random-test}.
Kako je očekivana greška u svim grafovima reda veličine $10^3$ ili manje, vidljivo je da slučajno bojanje ne daje dobre rezultate, već rezultati imaju jedan do dva reda veličine manje vrijednosti od inicijalnog bojanja. Razlika bi bila još manja kada bi inicjalna bojanja bila validna, ali kako se takvi čvorovi dodatno kažnjavaju (prema funkciji cilja), inicijalna pogreška je veća.

\section{Agentski algoritam}

\section{Simulirano kaljenje}

\section{Genetski algoritam}

\section{Genetsko kaljenje}

\section{Metode strojnog učenja za odair pohlepnog algoritma}

\section{Analiza rezultata}

\chapter{Zaključak}
Zaključak.

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}

U radu se proučava inačica problema bojanja težinskih grafova, gdje je cilj minimizirati sumu težina konfliktnih bridova. Problem je primjenjiv u domeni telekomuniakacija gdje se žele raspodijeliti k\^{o}dovi po mobilnoj mreži. Problem se obrađuje teorijski i praktično. U teorijskom dijelu detaljno se analizira problem i određuju njegove granice rješivosti na računalu. U radu se primjenjuju različiti metaheuristički postupci. Pomoću metoda regresija pokušava se pronaći optimalna svojstva grafova, kako bi konvergencija bila što bolja. Na kraju su prikazani rezultati i zaključci.

\kljucnerijeci{bojanje grafova, metaheursitka, strojno učenje, regresija, simulirano kaljenje, genetska strategija, genetsko kaljenje, agentski algoritam}
\end{sazetak}

% TODO: Navedite naslov na engleskom jeziku.
\engtitle{Adaptive Metaheuristic Methods for Graph Coloring Problem}
\begin{abstract}
In this work we study one instance of the weight graph coloring problem. Goal is to minimize sum of weights of conflicts bridges. Problem come from telecommunication domain where is goal set codes in mobile network. Problem is seen as theoretical problem and also as practical problem. In theory part we analyse the problem and we study a borders of the problem in computability theory. In this work we use a different metaheuristics algorithms. With regression methods we try to find optimal properties of graphs for better convergention of algorithms. On the end of this work we show results and we give conclusions.

\keywords{Keywords.}
\end{abstract}

\end{document}

