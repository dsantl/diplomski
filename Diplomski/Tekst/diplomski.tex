\documentclass[times, utf8, diplomski, numeric]{fer}
\usepackage{booktabs, url, hyperref}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

%dodatak za programski kod
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\small\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2
}
\renewcommand\lstlistingname{Algoritam}
%kraj dodatka za programski kod

\hypersetup{
   colorlinks,
   citecolor=black,
   filecolor=black,
   linkcolor=black,
   urlcolor=black
}


\newtheorem{definition}{Definicija}
\newtheorem{theorem}{Teorem}


\begin{document}

% TODO: Navedite broj rada.
\thesisnumber{656}

% TODO: Navedite naslov rada.
\title{Bojanje grafova prilagodljivim metaheurističkim postupcima}

% TODO: Navedite vaše ime i prezime.
\author{Dino Šantl}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
\izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{Zahvaljujem se roditeljima na podršci, bratu što je izdržao kao cimer te prijateljima na slobodnom vremenu.}

\tableofcontents

\chapter{Uvod}

U ovom radu obrađuje se jedna od inačica matematičkog problema poznatog pod nazivom bojanje grafa \engl{graph coloring}. Motivacija za rješavanje ovog problema dolazi iz domene telekomunikacija. Problem dodjeljivanja frekvencija (k\^{o}dova) s ciljem da ne dolazi do međusobne interferencije može se lako prevesti u problem bojanja grafova. Bojanje grafova poznat je matematički problem i postoji više smjerova za njegovo rješavanje na računalu \cite{lit8}. Specifičnost ovog problema su zadana ograničenja. Za razliku od klasičnog bojanja grafa, ovaj problem modeliran je pomoću težinskog grafa. Cilj je isti, obojiti graf tako da dva susjedna čvora nemaju istu boju. Ograničenja koja se pojavljuju vezana su uz dostupnost boja za svaki čvor i dodatne informacije koje svaki čvor posjeduje. U radu se prvo analizira matematički problem. Kako je problem iz perspektive računarske teorije \emph{NP-težak} i nije poznato postoji li  deterministički algoritam koji bi mogao veće instance problema rješavati u kratkom vremenskom roku, proučavaju se različiti heuristički pristupi. Osim toga analiza problema veoma je važna kako bi se dobila mjera u kojoj je problem rješiv na računalu. Nakon teorijske obrade problema, obrađuju se metaheuristički postupci koji su korišteni u radu. Za ovaj rad posebno je izrađeno okruženje za razvoj algoritama i alata za analizu problema. U radu se daje pogled na izrađenu infrastrukturu. Na kraju su obavljena mjerenja te analiza rezultata. Kako se rad temelji na metaheurističkim postupcima, važno je odrediti ponašanje parametara s različitim vrstama grafova, što daje temeljno znanje o konstrukciji samopodešavajućih metaheuristika. Nakon mjerenja donose se zaključci i smjernice za daljnji rad na problemu.
U praksi potrebno je konstruirati algoritam koji zahtijeva malo vremenskih i memorijskih resursa. Grafovi koji se mogu pojaviti kao ulaz mogu biti veoma veliki i gusti, što znači da je uz samo ispitivanje ponašanja heuristika potrebno razmišljati i o konkretnim implementacijama. Neke heuristike već same po sebi zahtijevaju dosta resursa. Veoma važan dio rada je istražiti isplati li se koristiti heuristike koje su malo zahtjevnije u cilju dobivanja boljeg rješenja. Ovaj rad je uvod u dizajniranje konačnog algoritma koji bi mogao biti primjenjiv u praksi.

\section{Sažetci korištenih znanstvenih članaka}

\textbf{An Efficient GA with Multipoint Guided Mutation for Graph Coloring Problems \cite{lit1}}.
Rad opisuje rješavanje problema bojanja grafova pomoću genetskog algoritma.
Posebna pažnja posvećena je operatoru mutacije.
Jedinke su prikazane nizom cijelih brojeva. Svakom čvoru u grafu pridružen je jedinstveni cijeli broj -- identifikacija.
Jedinka je prikazana nizom u kojem je svakoj identifikaciji (čvoru)
pridružen broj boje. Funkcija cilja je broj korištenih boja.
Inicijalna populacija generira se slučajnim dodjeljivanjem
boja svakom čvoru u grafu.
Dodatno se koristi operator ispravaka koji popravlja jedinku tako da izabere dva susjedna čvora koji imaju istu boju i zatim jednome od njih promijeni boju.
Mutacija se vrši nad jedinkom tako da se prvo reducira broj korištenih boja. To se može napraviti tako da se odaberu dva čvora i pridruži im se boja koja nije jedna od dvije odabrane.
Zatim se primijeni operator ispravaka nad tom jedinkom. To se sve ponavlja sve dok se ne generira legalno pobojani graf.
Rezultati su uspoređivani s klasičnim implementacijama genetskih algoritama i
dobiveni su bolji rezultati, ali u zaključku se navodi kako bi algoritam trebalo poboljšati da bi vrijeme
izvođenja na većim i kompleksnijim grafovima bilo bolje.
Ispitivanje se obavljalo nad nekim primjerima iz DIMACS baze.

\textbf{Efficient Graph Coloring With Parallel Genetic Algorithms \cite{lit2}}.
Koristi se paralelni genetski algoritam, i to migracijski model. Osim toga,
definirani su i novi genetski operatori. Jedinka je prikazana pomoću 
particije skupa. 

Ispitivanje je vršeno nad DIMACS bazom.
Dobiveni su rezultati:
\begin{enumerate}
\item Uvijek je bolje koristiti migraciju od izolacije. Za neke se operatore može odrediti najbolji parametar, dok za većinu drugih to nije pronađeno.

\item U migraciji je bolje koristiti najbolje jedinke. Samo u nekim slučajevima kod CEX operatora bolje je koristiti slučajno odabrane jedinke.

\item First Fit je uvijek bolja mutacija od Transposition mutacije. First Fit najbolje se ponaša uz CEX i GPX operator. Transposition mutacija relativno dobro radi sa SPPX operatorom.

\item CEX i GPX operatori bili su najbolji uz korištenje First Fit mutacije.
Nakon toga slijedi USIX. SPPX je jako brz operator, ali da bi bio uspješan,
potrebno ga je izvršiti u više iteracija.

\item Najbrži operator križanja je CEX s First Fit mutacijom. Najsporiji je UISX.
\end{enumerate}


\textbf{An ACO Algorithm for the Graph Coloring Problem \cite{lit4}}.
Opisuje se jedna inačica ACO \engl{Ant colony optimization} algoritma. Ideja je u svakom koraku bojati 
jednom bojom (odabiru se čvorovi koji će se bojati u zadanu boju). Radi se o 
proširenju ANTCOL-a. Uz kemijske se tragove dodaje heuristika (npr. 
broj čvorova koji su iste boje kao i trenutni korak). Graf koji mravi rješavaju
nije originalni graf koji je zadan, već je to graf gdje su povezana dva čvora
koja u originalnom grafu nisu susjedna. Prema tome se računa vjerojatnost da 
se nekom čvoru pridoda neka boja. 


\textbf{Breaking the Symmetry of the Graph Colouring Problem with Genetic Algorithms \cite{lit5}}.
Razbija se simetrija u klasičnom problemu bojanja grafova. Različite jedinke mogu predstavljati isto pobojane grafove. Problem se pokušava riješiti tako  da se na početku fiksiraju boje za određene čvorove. U našem problemu, članak se može koristiti kod pristupa pri pohlepnom algoritmu.

\textbf{New Graph Coloring Algorithms \cite{lit7}}.
Članak koji opisuje heuristike koje se koriste u pohlepnim algoritmima. Članak donosi ideje koje se lako implementiraju i daju dobre rezultate. Neke vrste bojanja i neke vrste sortiranja ideje vuku iz ovog članka (npr. SDO-LDO).

\textbf{Graph Coloring Algorithms for Assignment Problems in Radio Networks \cite{lit10}}.
Problem koji je veoma sličan praktičnoj primjeni problema koji se rješava. Koriste se različiti algoritmi i uspoređuju se rezultati. Cilj rada je istražiti problem i pokazati koji algoritmi, tj. heuristike, su efikasne.

\textbf{Evolutionary Algorithms for Real-World Instances of the Automatic Frequency Planning Problem in GSM Networks \cite{lit12}}.
Rad koji je vrlo sličan problematici koja se rješava u diplomskom radu. U radu je primijećeno da operator križanja mora biti vrlo napredan ili ga uopće ne koristiti, te se predlaže korištenje evolucijske strategije $(\mu, \lambda)$ 

\textbf{Optimization by Simulated Annealing: An Experimental Evaluation; Part II, Graph Coloring and Number Partitioning \cite{lit13}}.
Opisuje se korištenje simuliranog kaljenja u optimizacijskim algoritmima. Pokazuje se osnovna struktura simuliranog kaljenja i predlažu se nadogradnje kako bi metaheuristika dala bolje rezultate.

\textbf{Genetic Annealing Optimization: Design and Real World Applications \cite{lit18}}.
Jedan od rijetkih članaka koji opisuje metaheuristiku -- genetsko kaljenje. Analizira se metaheuristika u kojoj su uzete dobre strane genetskog algoritma i dobre strane simuliranog kaljenja. Algoritam pokazuje dobre rezultate, ali nedostatak može predstavljati velika populacija za koju je potrebno računati funkcije cilja čija je vremenska složenost velika.


\chapter{Formalni opis problema}

U ovom poglavlju opisuje se problem bojanja grafova i njegova primjena u području telekomunikacija. Opisuje se konkretan problem u telekomunikacijama uz pretpostavke i ograničenja. Zatim se isti problem opisuje pomoću matematičkog modela, tj. problema bojanja grafova. Kreće se od općenitog problema bojanja grafova, a zatim se matematički model prilagođava konkretnom telekomunikacijskom problemu.

\section{Tehnički opis problema}

Za opis problema dovoljno je pretpostaviti da postoji korisnikova oprema (što je najčešće mobilni uređaj) i bazna stanica. Bazne stanice geografski su statične, za razliku od mobilnih uređaja koji to nisu.
Ono što se u ovom radu naziva baznom stanicom je radijska pristupna mreža \engl{Radio Access Network} (\emph{RAN}). \emph{RAN} je dio telekomunikacijskog sustava i nalazi se između opreme korisnika i jezgre mreže. To je sloj u mreži koji je zaslužan za prenošenje komunikacije između mobilnog uređaja do antene i od antene do drugog mobilnog uređaja. 

Za što kvalitetniji rad mreže potrebno je optimirati parametre \emph{RAN}-a. Jedan od parametra je \emph{scrambling} k\^{o}d. \emph{Scrambling} k\^{o}d služi kako bi mobilni uređaj mogao razlikovati bazne stanice. Svakoj baznoj stanici potrebno je pridružiti različit k\^{o}d. Problem je u tome što je dostupno samo 512 različitih kodova. To znači da neke bazne stanice moraju imati isti k\^{o}d (ako se u sustavu nalazi više od 512 baznih stanica). Ako neke dvije bazne stanice imaju isti k\^{o}d i mobilni uređaj se nalazi u dosegu signala od obje stanice, tada uređaj ne može odrediti s kojom baznom stanicom komunicira. Tada može doći do prekida poziva, što uzrokuje pad kvalitete usluge.

Potrebno je dodijeliti \emph{scrambling} k\^{o}dove tako da dvije bazne stanice koje mogu biti istovremeno vezane za jedan mobilni uređaj nemaju isti k\^{o}d ili ako je to nemoguće, dodijeliti k\^{o}dove tako da je negativan utjecaj na kvalitetu usluge što manji. Postoje još neka tehnička ograničenja koja je potrebno uvažiti, a bit će navedena u nastavku.

Iako postoji 512 različitih k\^{o}dova, svaka bazna stanica ima ograničen skup k\^{o}dova koje može koristiti. Za svaku baznu stanicu zadan je skup mogućih k\^{o}dova. Za neke bazne stanice postoji svojstvo nepromjenjivosti, što znači da k\^{o}d koji je trenutno zadan za tu baznu stanicu mora ostati takav. Takve se vrste baznih stanica nazivaju \textbf{nepromjenjivima}. Početno stanje mreže definirano je k\^{o}dovima koji su pridijeljeni nekoj baznoj stanici. Osim toga, za svaku baznu stanicu poznata je njezina vrsta. Vrsta može biti označena slovima: \emph{A, B ili C}. Bazne stanice različitih vrsta ne utječu jedna na drugu.

\subsection{Ulazni i izlazni podaci}

Ulaz algoritma je inicijalno stanje mreže. Za svaku baznu stanicu poznat je trenutni k\^{o}d koji koristi i sva pravila koja moraju biti zadovoljena. Izlaz algoritma je skup uređenih parova, gdje je prvi element identifikator bazne stanice, a drugi element pripadajući k\^{o}d. U navedenom popisu umjesto pojma bazne stanice koristi se čvor, a naziv će biti opravdan u nastavku.

\subsubsection{Ulazni podaci}

\begin{enumerate}
	\item Popis i definicija domene boja (skupova boja)
	\item Popis čvorova (baznih stanica).
		\begin{enumerate}
			\item Oznaka čvora
			\item Vrsta čvora (grupa) -- A, B ili C
			\item Oznaka domene za boju čvora (koji skup boja koristi)
			\item Početna boja za čvor
			\item Oznaka je li čvor nepromjenjiv
		\end{enumerate}
	\item Popis bridova
\end{enumerate} 

\subsubsection{Izlazni podaci}

Kao izlaz algoritma koristi se niz parova brojeva $(i, c)$ gdje je $i$ oznaka za baznu stanicu, a $c$ je k\^{o}d (boja) čvora.

\section{Matematički opis problema}

Potrebno je modelirati problem u kojem postoji \emph{bazna stanica} i veze između istih. Veze predstavljaju mjeru u kojoj jedna bazna stanica utječe na drugu. Jedan od mogućih modela je graf. Čvorovi će predstavljati bazne stanice, a jakost će između dvije bazne stanice biti modelirana pomoću težine brida. U nastavku, bazna stanica nazivat će se čvorom. Nad ovako postavljenim grafom problem je dodijeliti k\^{o}dove tako da nema bridova koji na svojim krajevima imaju čvor s istim k\^{o}dom. Problem je poznat pod nazivom \emph{bojanje grafa}. Kako je uobičajeno pričati o bojama čvora (a ne o k\^{o}dovima), od sad pa nadalje \emph{scrambling} k\^{o}d nazivat će se bojom čvora. U nastavku će prvo biti opisan klasičan problem bojanja grafova, gdje se promatraju bestežinski grafovi (oni čiji bridovi nemaju težine). Nakon toga problem se poopćuje na težinske grafove, čime se modelira prethodno opisan problem.

\subsection{Definicije za klasičan problem bojanja grafova}

Najprije se definiraju matematički pojmovi. Zatim se formalno opisuje problem bojanja grafova. Uz to se nadovezuje teorija izračunljivosti.

\subsubsection{Pojam grafa}

\begin{definition}
Jednostavni graf \textbf{G} sastoji se od nepraznog konačnog skupa \textbf{V(G)}, čije elemente nazivamo čvorovi grafa \textbf{G} i konačnog skupa \textbf{E(G)} različitih dvočlanih podskupova \textbf{V(G)} koje zovemo bridovi.
\end{definition}

\begin{definition}
Skup vrhova koji su susjedni vrhu \textbf{v} zovemo susjedstvo vrha \textbf{v} i označavamo oznakom \textbf{H(v)}.
\end{definition}

\begin{definition}
Stupanj vrha \textbf{v} grafa \textbf{G} jednak je broju bridova koji su vezani na \textbf{v}. Označavamo ga s \textbf{d(v)}.
\end{definition}

\begin{definition}
Neka je \textbf{G} jednostavan graf i $\mathbf{\omega}$ funkcija $\mathbf{\omega : E \rightarrow \mathbb{R}}$. Par \textbf{(G, $\omega$)} naziva se težinski graf. Pri čemu funkcija $\omega$ svakom bridu iz \textbf{G} dodjeljuje jedan element iz skupa realnih brojeva. Neka je \textbf{e} neki brid grafa \textbf{G}, njegova težina označena je s $\omega(\mathbf{\mathit{e}})$.	 
\end{definition}


\subsubsection{Definicija bojanja grafova}

\begin{definition}
Definiramo funkciju $\phi : V(G) \rightarrow \mathbb{N}$, koja svakom čvoru u grafu pridružuje jedan prirodan broj koji $\mathbf{\phi(v)}$, gdje je $\mathbf{v}$ čvor u grafu $\mathbf{G}$. Broj $\mathbf{\phi(v)}$ nazivamo boja čvora, a funkciju $\phi$ nazivamo \textbf{bojanje grafa}. 
\end{definition}

\begin{definition}
Bojanje grafa s najviše \textbf{k} boja nazivamo \textbf{k-bojanje} grafa. 
\end{definition}

\begin{definition}
Ako se graf može obojiti s najviše \textbf{k} boja, tada takvo bojanje nazivamo \textbf{legalno k-bojanje} grafa. 
\end{definition}

\begin{definition}
Graf je \textbf{k-obojiv} akko postoji legalno k-bojanje grafa.
\end{definition}


\begin{definition}
Ako je graf G \textbf{k}-obojiv, ali nije \textbf{(k-1)}-obojiv tada kažemo da je \textbf{k} kromatski broj grafa G, gdje se koristi oznaka $\chi(G)=k$  
\end{definition}


\begin{definition}
Podskup skupa V(G) nazivamo \textbf{nezavisni skup} ako u njemu ne postoje dva čvora koja su susjedna.  
\end{definition}

\begin{definition}
Brid koji spaja dva čvora iste boje nazivamo \textbf{konfliktnim bridom}.
\end{definition}

\begin{definition}
Dva čvora koja spaja konfliktni brid nazivamo \textbf{konfliktnim čvorovima}.
\end{definition}

\begin{definition}
Particiju skupa V(G) na k disjunktnih nepraznih podskupova $V_1,..., V_k$
 tako da vrijedi $V(G) = \bigcup_{j=1}^{k}V_j$ zovemo \textbf{k-dioba} grafa G. Ako su podskupovi  $V_1 ,..., V_k$  ujedno i nezavisni skupovi, onda se to naziva \textbf{legalna k-dioba} grafa G.
\end{definition}

\begin{theorem}
\label{thm:dioba}
Graf \textbf{G} je \textbf{k-obojiv} akko postoji \textbf{legalna k-dioba} grafa \textbf{G}.
\end{theorem}

\begin{proof}
Pretpostavimo da je graf \emph{G} \textbf{k-obojiv}. Definiramo skupove $S_i$ tako da čvor grafa $\mathbf{v}$ pripada skupu $S_i$ ako je obojen bojom $\mathbf{i}$. Takvi skupovi su neprazni i disjunktni, te unija skupova $S_i$ čini skup svih vrhova grafa \emph{G}. Kako je G \textbf{k-obojiv} tada ne postoji boja zbog koje bi neki brid bio konfliktan pa slijedi da je podjela na skupove $S_i$ \textbf{legalna k-dioba} grafa G jer su skupovi $S_i$ nezavisni. 

Drugi smjer dokazuje se tako što se pretpostavi da postoji \textbf{legalna k-dioba} grafa \textbf{G} na skupove $S_i$. Kako je svaki skup indeksiran s indeksom \textbf{i}, tada svakom čvoru koji se nalazi u skupu $S_i$ dodijelimo boju \textbf{i}. Kako su skupovi $S_i$ prema pretpostavci disjunktni, neprazni i nezavisni, ne postoje dva čvora koja bi imala istu boju.
\end{proof}

\subsubsection{Definicije računske teorije složenosti}

\begin{definition}
\textbf{Problem odluke} je problem koji uvijek ima odgovor \textbf{da} ili \textbf{ne}. Primjerice, problem je li je graf točno \textbf{k-obojiv} je problem odluke. Problem traženja kromatskog broja grafa nije problem odluke, jer tražimo točan broj \textbf{k}.
\end{definition}

\begin{definition}
Problem odluke za koje postoje algoritmi koji daju odgovor, a čije vrijeme izvršavanje ovisi polinomno o veličini ulaznih podataka spadaju u \textbf{klasu P}.
\end{definition}

\begin{definition}
\textbf{Problem odluke} spada u klasu \textbf{NP problema} ako se točnost njegovog rješenja može ispitati u polinomnom vremenu. 
\end{definition}

\begin{definition}
\textbf{Problem odluke} spada u klasu \textbf{NP-potpunih problema} ako spada u \textbf{klasu NP} problema i koji ima svojstvo da se svaki drugi problem iz \textbf{klase NP} može polinomno reducirati na njega. 
\end{definition}

\begin{definition}
Kažemo da je problem \textbf{NP-težak} akko postoji \textbf{NP-potpun problem} koji se može polinomno reducirati na njega.
\end{definition}

Problem odluke za koji postoji algoritam čije trajanje ovisi polinomno o veličini ulaznih podataka je \textbf{P problem}. Ako za neki problem odluke ne možemo pronaći algoritam čije vrijeme izvođenja ovisi polinomno o veličini ulaznih podataka, ali točnost rješenja možemo provjeriti u polinomnom vremenu, tada je to \textbf{NP problem}. \textbf{NP-potpun problem} je problem odluke čiji algoritam možemo iskoristiti da bismo riješili sve \textbf{NP probleme} tako da koristimo polinomijalan broj poziva tog algoritma. Općeniti problemi (koji ne moraju biti problemi odluke) nazivaju se \textbf{NP-teški problemi} ako postoji problem u klasi \textbf{NP-potpunih problema} koji se može riješiti pomoću polinomnog broja poziva algoritma za promatrani \textbf{NP-teški} problem. Odnos \textbf{P} i \textbf{NP} klasa još je uvijek otvoren problem ($P=NP$ ili $P\subset NP$). Kada bi se moglo dokazati da je neki \textbf{NP-potpun} problem moguće riješiti u polinomnom vremenu, tada bi se svi \textbf{NP problemi} mogli riješiti u polinomnom vremenu, pa bi klase \textbf{P} i klase \textbf{NP} bile jednake. Ako se pak pokaže da za neki \textbf{NP} problem ne postoji algoritam čije izvršavanje ovisi polinomno o ulaznim podacima, tada bi klasa \textbf{P} bila pravi podskup klase \textbf{NP}.

\subsubsection{\emph{No free lunch} teorem za optimizacijske algoritme}

\begin{definition}
\textbf{Optimizacija} je grana matematike koja proučava pronalaženje ekstrema funkcija.
\end{definition}

\begin{definition}
\textbf{Kombinatorna optimizacija} je grana optimizacije gdje je domena funkcije skup s konačnim brojem elemenata.
\end{definition}

\begin{definition}
Konkretna funkcija koja se proučava naziva se \textbf{funkcija cilja}.
U radu se zbog semantike umjesto funkcije cilja često koristi pojam greške.
\end{definition}

\begin{definition}
Funkcije cilja koje se promatraju imaju diskretnu i konačnu domenu i kodomenu. Iako se kao elementi kodomene mogu pojaviti realni brojevi, zbog toga što su računala diskretni strojevi s konačno mnogo memorije, to je samo konačni podskup realnih brojeva.
\end{definition}

\begin{theorem}
Funkcija cilja definira se kao: $f : \mathbb{X} \rightarrow \mathbb{Y}$, gdje su skupovi $\mathbb{X}$ i $\mathbb{Y}$ diskretni i konačni. Tada je broj svih mogućih funkcija jednak $|\mathbb{F}| = |\mathbb{Y}|^{|\mathbb{X}|}$. 
\end{theorem}

\begin{proof}
Za svaki element domene možemo odabrati točno $|\mathbb{Y}|$ elemenata kodomene. 
\begin{equation}
|\mathbb{F}| = \prod_{j=1}^{|\mathbb{X}|} |\mathbb{Y}| =  |\mathbb{Y}|^{|\mathbb{X}|}
\end{equation}
\end{proof}

\begin{definition}
Vremenski niz $d_m$ je niz parova domene i kodomene.
\begin{equation}
d_m = \left \{ (d_m^x(1), d_m^y(1)), (d_m^x(2), d_m^y(2)), ..., (d_m^x(m), d_m^y(m))\right \}
\end{equation} 
Iz nekog niza $d_m$ može se izvući samo niz elemenata domene i to se označava s $\mathbf{d_m^x}$ ili samo niz elemenata kodomene što se označava s $\mathbf{d_m^y}$.
\end{definition}

\begin{definition}
Prostor svih vremenskih nizova veličine $m$: $\mathbb{D}_m = (\mathbb{X} \times \mathbb{Y})^m$, a prostor svih vremenskih nizova maksimalne veličine $m$ je: $\mathbb{D} = \bigcup_{m\ge0}\mathbb{D}_m$.
\end{definition}

\begin{definition}
Optimizacijski algoritam $a$ definira se kao: $a : d \in \mathbb{D} \rightarrow \left \{x | x \notin d_m^x \right \}$
\end{definition}

Optimizacijski algoritam preslikava neki vremenski niz (podatke iz prethodnih koraka izvođenja) u novu vrijednost domene, pod uvjetom da ta vrijednost domene ne smije biti već viđena. Ovo ograničenje koristi se u dokazu teorema, ali se u praksi često mogu javiti slučajevi gdje se više puta računa vrijednost funkcije za isti element domene.

\begin{definition}
\textbf{Heuristikom} se naziva optimizacijski algoritam koji ne mora kao rezultat dati globalni ekstrem \textbf{funkcije cilja}, ali daje dovoljno dobre rezultate u svrhu kraćeg vremenskog izvođenja. 
\end{definition}

\begin{definition}
\textbf{Metaheuristikom} naziva se familija optimizacijskih algoritama, čije konkretno izvođenje ovisi o njegovim parametrima.
\end{definition}

\begin{definition}
Skup svih dozvoljenih rješenja u optimizaciji nazivamo \textbf{prostor pretrage}.
\end{definition}

\begin{theorem}
\label{thm:nofreelunch}
\textbf{"No free lunch" teorem za optimizaciju} - Neka su $a_1$ i $a_2$ dva različita heuristička algoritma koji traže ekstrem funkcije. Funkcije su predstavljene crnom kutijom. Tada vrijedi ova jednakost:
\begin{equation}
	\sum_{f}P(d_m^y|f,m,a_1) = \sum_{f}P(d_m^y|f,m,a_2)
\end{equation}
\end{theorem}

Dokaz teorema može se pronaći u \cite{lit15}.

Kako se ne zna ništa više o funkcijama (npr. simbolički zapis), već samo ulazni i izlazni parovi, ne može se koristiti nikakvo unutarnje znanje koje bi nekom algoritmu dalo prednost. Ako je poznat broj koraka $m$, tada su za bilo koji algoritam sume vjerojatnosti međusobno jednake, pri čemu se gleda vjerojatnost da se pojavio neki niz izlaznih vrijednosti funkcije $d_m^y$.
Iz niza izlaznih vrijednosti $d_m^y$ može se lako izvući minimalna ili maksimalna vrijednost koja je tada konačan izlaz algoritma. Dakle, ne postoji algoritam koji bi bio dominantniji za sve funkcije cilja $f$. Zbog toga je potrebno svaki optimizacijski problem promatrati veoma usko i koristiti dodatne informacije o samoj funkciji $f$.

Prethodne definicije i teoremi služe kako bi se uskladili nazivi za matematičke pojmove koji će se koristiti u radu. Sve definicije uzete su iz \cite{lit16, lit15, lit19}, gdje se među ostalim mogu naći i druge definicije i teoremi povezani s teorijom grafova, računarskom teorijom složenosti i "\emph{No free lunch}" teoremom.

\subsection{Bojanje težinskih grafova}

Za navedeni telekomunikacijski problem potrebno je odabrati prikladan matematički model. Već je spomenuto da se bazne stanice modeliraju čvorovima u grafu. Postavlja se pitanje što predstavlja brid u tome grafu. Očigledno je da jedna bazna stanice utječe na drugu baznu stanicu, tj. mobilni uređaj istovremeno vidi više baznih stanica. To znači da bi brid mogao predstavljati relaciju vidi li neka bazna stanica drugu. Problem se može razviti i korak dalje. Nije svejedno na kojoj su udaljenosti bazne stanice te koja je njihova snaga. To znači da dvije bliže (ili jače vezane) bazne stanice više utječu jedna na drugo nego što to čine dvije udaljenije. Ideja je svakom bridu dodijeliti težinu koja predstavlja neku mjeru koliko jedna bazna stanica utječe na drugu. To znači da brid između dva čvora daje mjeru međusobnog utjecaja čvorova. Ako je utjecaj premalen (tehnički nevidljiv), tada brid između ta dva čvora ne postoji.

Na tako zadanom težinskom grafu potrebno je napraviti bojanje grafa uz poštivanje svih tehničkih uvjeta. Zato se u ovom radu klasični problem bojanja grafova poopćuje:

\begin{definition}
Bojanje težinskog grafa je optimizacijski problem u kojem se minimizira funkcija cilja:
\begin{equation}
f(\phi) = 2\sum_{i=1}^{E(G)} \omega(e_i) \cdot R(e_i),
\end{equation}
gdje je $\omega(e_i)$ težina brida, a $R$ funkcija koja ima vrijednost $1$ ako je $e_i$ konfliktan brid ili $0$ inače. Funkcija $f$ ovisi o bojanju grafa, tj. funkcija cilja jednaka je dvostrukoj sumi težina konfliktnih bridova.
\end{definition}

Konstanta $2$ koja množi sumu, matematički je nebitna, ali navodi se zbog implementacije funkcije na računalu. Zbog tehničkih ograničenja potrebno je uvesti nekoliko matematičkih detalja koji pokrivaju te slučajeve.

\begin{definition}
Funkcija $\phi$ definira se kao funkcija koja svakom nenepromjenjivom čvoru $v$ grafa \textbf{G} pridružuje prirodan broj iz skupa dopuštenih boja za taj čvor.
\end{definition}

\begin{definition}
Ako su dva \textbf{nepromjenjiva} čvora spojena bridom i imaju iste boje, tada smatramo da taj brid nije \textbf{konfliktan}.
\end{definition}

Razlog ovakvoj definiciji je taj da se bridovi koji spajaju dva nepromjenjiva čvora različitih boja ne mogu nikada poboljšati, pa prema tome neovisni su o funkciji bojanja grafa $\phi$.

\begin{definition}
Ako su dva čvora koja pripadaju u suprotne vrste spojena bridom, tada takav brid ne smatramo \textbf{konfliktnim}.
\end{definition}

Tehnički, takva dva čvora ne utječu jedan na drugog pa nema potrebe  ugrađivati u funkciju cilja te bridove.

U slučaju da je čvor obojen bojom koja nije u njegovoj domeni, tada je potrebno dodati u funkciju cilja kaznu za takav slučaj. Iako po definiciji funkcije bojanja grafa to nije moguće, zbog inicijalnog stanja boja koje algoritam primi kao ulaz, može se dogoditi da boja čvora nije u njegovoj domeni. Stoga se definira proširena funkcija cilja kao:

\begin{definition}
\begin{equation}
\label{equ:funkcija_cilja}
f(\phi) = 2\sum_{i=1}^{E(G)} \omega(e_i) \cdot R(e_i) + \sum_{i=1}^{V(G)} C(v_i)
\end{equation}
Prva suma jednaka je već definiranoj funkciji cilja. Drugi član je suma funkcije $C$ po čvorovima, gdje funkcija $C$ ima vrijednost $\varepsilon$ ako je čvor $v_i$ krivo obojen ili $0$ ako je obojen bojom iz svoje domene.
\end{definition}

Za epsilon se odabire neki veliki pozitivan broj. U konkretnoj implementaciji koja se koristi u radu $\varepsilon=10000000$.

\begin{definition}
Smatra se da je bojanje \textbf{valjano} ako postotak promjene boja inicijalnog stanja ne prelazi prag od $\alpha$ posto.
\end{definition}

U konkretnom problemu $\alpha=66\%$.

Sažetak problema kojeg modeliramo pomoću težinskog grafa glasi:
\begin{itemize}
	\item Svaki čvor može poprimiti jednu boju iz skupa dopuštenih boja za taj čvor.
	\item Svaki čvor spada u jednu grupu tj. vrstu (A, B ili C).
	\item Neki čvorovi su definirani kao nepromjenjivi, njima se boja nikad ne smije mijenjati.
	\item Dodatan uvjet je da postotak promijenjenih čvorova naprema inicijalnom stanju ne smije biti veći od 66\%.
	\item Optimizacija se provodi nad funkcijom cilja definiranom formulom (\ref{equ:funkcija_cilja}).
\end{itemize}

\section{Analiza problema bojanja težinskih grafova}

U ovom odjeljku analizirat će se zadani matematički problem optimizacije. U svakom koraku analize uspoređuje se klasičan problem bojanja grafova i bojanje težinskih grafova. Kreće se od analize prostora pretrage. Zatim se dokazuje u kojoj se klasi problemi nalaze. Na kraju se pokazuje da "\emph{No free lunch}" teorem vrijedi i za bojanje grafova i kakve posljedice donosi.

\subsection{Prostor pretrage stanja}

Kod klasičnog problema bojanja grafova analiziraju se dva problema. Prvi je odrediti može li se graf obojiti s najviše $k$ boja, a drugi problem je odrediti najmanji takav $k$. Pretpostavimo za početak da provjeravano je li graf \textbf{k-obojiv}. Pitanje je na koliko načina se graf može obojiti ako koristimo najviše \textbf{k} boja. Svaki čvor može poprimiti \textbf{k} boja. To znači da je ukupan broj bojanja $N$ jednak: 

\begin{equation}
N = k^{V(G)} 
\end{equation}

Valja primijetiti da u ovom brojanju veličine prostora stanja postoji više jednako vrijednih bojanja. U bojanju nije bitna točna boja, već je bitno da različiti skupovi čvorova imaju različite boje. Točno pitanje je na koliko načina možemo čvorove podijeliti u $k$ skupova (Teorem \ref{thm:dioba}).  

\begin{equation}
N = \sum_{i=1}^{k} S(V(G), i)
\end{equation}

Oznaka $S(m,n)$ je za \emph{Stirlingov} broj druge vrste, gdje je $m$ broj različitih elemenata (čvorovi) koje smještamo u $n$ istovrsnih skupova boja, tako da svaka boja ima barem jedan čvor. Kako je dopušteno da skupovi mogu biti prazni, tada se problem pretvori u disjunktne probleme gdje se koristi samo $i$ skupova. 

Ako se zahtijeva da svaka od $k$ boja mora biti iskorištena, ekvivalentno da nijedan od $k$ skupova ne smije biti prazan, tada je ukupan broj stanja nešto manji:

\begin{equation}
N = S(V(G), k) = \frac{1}{k!}\sum_{i=0}^{k} (-1)^i \binom{k}{i}(k-i)^{V(G)}  
\end{equation}

Ako se čvrsto zahtijeva da svaka boja mora biti barem na jednome čvoru, tada je to \emph{Stirlingov} broj druge vrste, gdje je i navedena formula za izračun $S(m,n)$.

Neka se promatra problem traženja kromatskog broja grafa $\chi(G)$, tj. minimalni broj boja $k$, a da se graf može legalno obojiti. Maksimalni broj za koji je to potrebno provjeriti je broj čvorova u grafu, jer je u tom slučaju svaki čvor povezan sa svakim drugim i svaki čvor mora imati svoju boju. Kromatski broj grafa je dakle ograničen odozgo brojem čvorova. Za svaki broj $k$ do $V(G)$ treba provjeriti je li je graf \textbf{k-obojiv}. Ukupan broj stanja je:

\begin{equation}
N = B(V(G)) = \sum_{i=0}^{V(G)} S(V(G), i)
\end{equation}

Broj $B(n)$ naziva se \emph{Bellov} broj i on predstavlja broj načina na koji se skup od $n$ članova može podijeliti u neprazne podskupove. Za bolji uvid koliko brzo \emph{Bellov} niz raste dane su nejednakosti (za $n\ge 8$): 

\begin{equation}
2^n \le B(n) \le n! 
\end{equation}

\emph{Bellov} broj brže raste od eksponencijalne funkcije, ali sporije od faktorijela. U ovom radu daje se dokaz za tu tvrdnju.

\begin{proof}
Prvo se pokazuje nejednakost: $2^n\le B(n), n \ge 5$.
Dokaz se provodi indukcijom. Koriste se razvoj binoma: 
\[ 2^n=(1+1)^n = \sum_{k=0}^{n}\binom{n}{k} \] 
i svojstvo Bellovog broja: 
\[ B(n+1)=\sum_{k=0}^{n}\binom{n}{k}B(k) \]
	\begin{align}
		2^n \le B(n) \\
		\textup{Baza indukcije: } n = 5, 2^5 \le B(5) \rightarrow 32 \le 52 \\
		\textup{Pretpostavka: } 2^n \le B(n) \\
		2^{(n+1)} \le B(n+1) \\
		2\cdot 2^n \le B(n+1) \\
		\sum_{k=0}^{n} 2\cdot \binom{n}{k} \le \sum_{k=0}^{n}\binom{n}{k}B(k)\\
		\sum_{k=0}^{3} 2\cdot \binom{n}{k} + \sum_{k=4}^{n} 2\cdot \binom{n}{k} \le \sum_{k=0}^{3}\binom{n}{k}B(k) + \sum_{k=4}^{n}\binom{n}{k}B(k) \\
		\textup{Prvo se dokazuje: } \sum_{k=0}^{3} 2\cdot \binom{n}{k} \le \sum_{k=0}^{3}\binom{n}{k}B(k) \\
		2\binom{n}{0} + 2\binom{n}{1} + 2\binom{n}{2} + 2\binom{n}{3} \le \\ \binom{n}{0}B(0) + \binom{n}{1}B(1) + \binom{n}{2}B(2) + \binom{n}{3}B(3) \\
		2+2n+\frac{n(n-1)}{2}2+\frac{1}{3}n(n-1)(n-2) \le \\1 + n + \frac{n(n-1)}{2}2+\frac{n(n-1)(n-2)}{6}5 \\
		1+n \le n(n-1)(n-2)(\frac{5}{6}-\frac{1}{3}) \\
		1+n \le \frac{n(n-1)(n-2)}{3} \\
		3+3n\le n^3 - 3n^2 +3n \\
		3n^2+3 \le n^3 \\
		3 \le n^3 - 3n^2 \\
		3 \le n^2 (n - 3), \textup{istina za } n\ge 5 \\
		\textup{Druge dvije sume: } \sum_{k=4}^{n} 2\cdot \binom{n}{k} \le \sum_{k=4}^{n}\binom{n}{k}B(k) \\
		\textup{Član po član sume: }\binom{n}{k} 2 \le \binom{n}{k} B(k) \\
		2 \le B(k), \textup{za } k \ge 4
	\end{align}
\end{proof}

\begin{proof}
	Potrebno je dokazati $B(n) \le n!$. Dokaz se provodi iz svojstava za Bellov broj \cite{lit20}:
	\[ B(n) \le \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \] 
	i svojstva faktorijela koje slijedi iz analize Stirlingove aproksimacije: \[ n!\ge \left ( \frac{n}{e} \right )^n \]
	\begin{align}
		B(n) \le \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \le \left ( \frac{n}{e} \right )^n \le n! \\
		\textup{Dovoljno je pokazati: } \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \le \left ( \frac{n}{e} \right )^n \\
		\left [ \frac{0.792 n}{ln(1+n)} \right ] \le \left ( \frac{n}{e} \right ) \\
		0.792 n\cdot e \le n \cdot ln(n+1) \\
		0.792\cdot e \le ln(n+1) \\
		e^{0.792\cdot e} \le n+1 \\
		8.61 -1 \le n \\
		7.61 \le n
	\end{align}
\end{proof}

Zaključak prethodne analize je da za relativno veliki graf postoji velik broj stanja koje je nemoguće pretražiti pomoću \emph{iscrpne pretrage}. Analiza prostora stanja za zadani problem malo je drugačija. Kako svaki čvor ima konačan broj boja koje može poprimiti, ukupan broj stanja je:

\begin{equation}
N = \prod_{i=1}^{V(G)} K_i,
\end{equation}
gdje je oznaka $K_i$ ukupan broj boja koje može poprimiti čvor s indeksom $i$. Kako je moguće dodijeliti maksimalno samo $512$ boja, možemo ograničiti $K_i$:
\begin{equation}
K_i \le M = 512
\end{equation}
\begin{equation}
N = \prod_{i=1}^{V(G)} K_i \le \prod_{i=1}^{V(G)} M = M^{V(G)}
\end{equation}

Broj stanja eksponencijalno ovisi o broju čvorova, što je isto kao i za klasičan problem bojanja grafa, jako velik broj stanja. I u ovom je slučaju važno primijetiti da su neka stanja ekvivalentna. Broj jedinstvenih stanja broj je particija skupa čvorova u skupove boja, ali uz ograničenje da barem jedan čvor ima neku od zadanih $M$ boja. Tada vrijedi ova nejednakost za broj različitih stanja:

\begin{equation}
N \le \sum_{i=1}^{M} S(V(G), i)
\end{equation}

Broj stanja je manji jer se poštuje ograničenje da čvorovi mogu poprimiti neku od boja u podskupu ukupnog konstantnog broja boja $M$. Kada je $k\ge M$ tada je broj stanja optimizacijskog problema manji od broja stanja u problemu gdje se traži odgovor na pitanje je li graf \textbf{k-obojiv}. Ovo će razmatranje biti zanimljivo i u sljedećem poglavlju, gdje se problem svrstava u klase računske teorije složenosti.

\subsection{Pozadina problema iz perspektive računske teorije složenosti}

Problem odluke je li graf \textbf{k-obojiv} spada u klasu \textbf{NP-potpunih} problema. Traženje kromatskog broja grafa $\chi(G)$ spada u klasu \textbf{NP-teških} problema. Dokazi se mogu pronaći u \cite{lit16}. Potrebno je pokazati da postavljen optimizacijski problem bojanja grafa spada u klasu \textbf{NP-teških} problema. Problem sigurno ne može spadati u druge spomenute (P, NP, NP-potpun) klase jer to nije problem odluke.
Postupak dokazivanja da problem spada u klasu \textbf{NP-teških} problema ima nekoliko koraka. Prvi korak je pronalaženje nekog \textbf{NP-potpunog} ili \textbf{NP-teškog} problema koji će se koristiti u dokazu. Zatim se pokaže da je taj \emph{postojeći} problem moguće polinomno reducirati na problem za koji se dokazuje da je \textbf{NP-težak}. U ovom radu provodi se dokaz. 

\begin{proof}
Odaberemo \textbf{NP-potpun problem} koji ispituje je li je graf $G$ \textbf{k-obojiv}. Kako bismo riješili taj problem, koristimo zadani optimizacijski problem. Ulaz u optimizacijski algoritam između ostalog su graf $G$ i ograničenja boja za svaki od čvorova. Svakom čvoru daje se skup $\{1,2,...,k\}$ s bojama. Svim bridovima daje se težina $1$. Tada se pokreće jezgra s optimizacijskim problemom koja će riješiti taj problem. Ako je rezultat optimizacije, tj. funkcije cilja, $f=0$, tada je graf \textbf{k-obojiv}, inače nije. U konstantnom vremenu možemo reducirati problem, iz čega slijedi da je optimizacijski problem \textbf{NP-težak}.  
\end{proof}

Zanimljivo je primijetiti da \textbf{NP-potpun} problem k-obojivosti može imati više stanja od \textbf{NP-teškog} problema optimizacije, što znači mogućnost kraćeg vremena izvođenja od vremena provjere k-obojivosti. Kako nije poznat odnos \emph{NP} i \emph{P} klase, za ovaj optimizacijski problem nameće se korištenje heuristika. U ovom tehničkom problemu nije potrebno do kraja minimizirati funkciju cilja, nego dobiti dovoljno malu vrijednost $f$ koja će uzrokovati bolju kvalitetu mobilne mreže. 

\subsection{Posljedica "\emph{No free lunch}" teorema}

U originalnom članku, gdje se dokazuje "\emph{No free lunch}" teorem \cite{lit15}, pretpostavlja se da sve funkcije cilja imaju iste domene i kodomene. Za problem bojanja grafova to nije tako, jer funkcija cilja nema istu kodomenu za sve grafove. Funkcija cilja definirana je kao: $f:\mathbb{X}^{V(G)} \rightarrow \mathbb{R}$, ali kako računalo ima konačnu memoriju, tada je funkcija zapravo definirana kao: $f:\mathbb{X}^{V(G)} \rightarrow \mathbb{Y}$, gdje je $\mathbb{Y}$ konačni podskup realnih brojeva koji se mogu prikazati na računalu, a $\mathbb{X}$ skup boja. Problem za "\emph{No free lunch}" teorem je taj da veličina domene funkcije cilja ovisi o broju čvorova grafa. Broj grafova je beskonačan jer možemo uzeti proizvoljan broj čvorova, što znači da postoji i beskonačan broj mogućih funkcija cilja. Teorem radi samo ako je broj funkcija cilja ograničen (Teorem \ref{thm:nofreelunch}). Kako je na nekom računalu nemoguće prikazati proizvoljno veliki graf, broj čvorova može se ograničiti s nekom granicom $L$. Tada je moguće prebrojati sve funkcije cilja $f$, što je napravljeno u nastavku rada.

\begin{proof}
Pitanje je koliko funkcija postoji, ako je broj članova domene ograničen s $L$.
Broj funkcija koje imaju točno $k$ elemenata u domeni ima:
	\begin{equation}
		|\mathbb{F}_k| = |\mathbb{Y}|^k
	\end{equation}
Ukupan broj funkcija je suma po svim $k$ do granice $L$ (koristi se suma za geometrijski niz):
	\begin{equation}
		|\mathbb{F}| = \sum_{k=1}^{L}|\mathbb{F}_k| = \sum_{k=1}^{L} |\mathbb{Y}|^k = \frac{|\mathbb{Y}|^{L+1}-|\mathbb{Y}|}{|\mathbb{Y}|-1}
	\end{equation}
\end{proof} 

Ako se ograniči broj čvorova, dobije se konačan broj funkcija te je to lako ugraditi u Teorem \ref{thm:nofreelunch}. Teorem govori o tome kako ne postoji nikakvo znanje o funkciji. U ovom problemu, funkcija cilja direktno ovisi o grafu tj. strukturi i to je važna informacija koja treba biti iskorištena kako bi se dobili bolji algoritmi. Glavna je posljedica ovog teorema razvoj pohlepnih algoritama koji koriste znanje o strukturi (grafu) i primjena tih algoritama u metaheurističkim postupcima. 
Važno je uočiti da svaki graf posjeduje vlastitu funkciju cilja. To znači da se korištenjem algoritama na slijepo koji rade na nekim grafovima ne može jamčiti efikasnost na drugim.

U članku \cite{lit9} opisuje se kako postoje slučajevi u kojima hiper-heuristike mogu imati "\emph{Free lunch}" svojstvo. Hiper-heuristike su algoritmi koji traže najbolji algoritam koji može riješiti neki problem, tj. pronaći ekstrem funkcije cilja. Kako je gore opisano, svaki graf ima svoju funkciju cilja. Ako je skup funkcija cilja dovoljno malen, moguće je da hiper-heuristika uvijek pronađe neki algoritam koji je bolji od svih ostalih za konkretnu funkciju cilja. Ovo nije dokazano za bojanje grafova (tako ni za optimizacijski problem bojanja), ali daje motivaciju u razvoju algoritama. U zadnjem dijelu opisa algoritama u ovom radu koriste se metode strojnog učenja kako bi se izvuklo znanje za primjenu u nekim pohlepnim algoritmima, tj. kako bi se odabrao najbolji pohlepan algoritam, što je zapravo jednostavan oblik hiper-heuristike. Osim toga, u implementaciji je otvoren prostor gdje se lako mogu donositi odluke i dinamički birati algoritmi koji u trenutnoj točci u prostoru stanja daju bolje rezultate od drugih algoritama.

\chapter{Algoritmi}

\section{Uvod}

Algoritmi koji su implementirani za ovaj problem podijeljeni su u dva dijela. Prvu skupinu čine pohlepni algoritmi, a drugi su algoritmi s kojima se i rad bavi -- metaheuristike. Proučavaju se četiri metaheuristike: agentski algoritam, simulirano kaljenje, genetski algoritam i genetsko kaljenje. Započinje se s konstruiranjem hiper-heuristike nad pohlepnim algoritmima, gdje se želi pokazati koji je pohlepni algoritam najbolji u raznim slučajevima. Pri ispitivanju algoritama treba biti veoma oprezan. Prethodna razmatranja upućuju na to da neki algoritam (metaheuristika s određenim parametrima) može dati bolje rezultate od drugih algoritama na nekim grafovima, dok je na nekim grafovima obrnuta situacija. To se može usporediti s pojmom \emph{prenaučenosti} iz strojnog učenja. Zbog toga je za ovaj problem potrebno graditi algoritme koji su prilagodljivi.

\subsection{Mogući problemi}

Mogući problemi mogu se podijeliti na dva dijela: problemi vezani uz ograničenja i problemi vezani uz implementaciju. Problemi vezani uz ograničenja su: velik broj čvorova i bridova koji se mogu pojaviti, velika razlika između težina bridova (razlika za više redova veličina), nepromjenjivi čvorovi koji su okruženi promjenjivim čvorovima. Velik broj čvorova i bridova uzrokuje i sporiji rad algoritma. Razlika između težina bridova može kod algoritama koji koriste tu razliku uzrokovati neočekivano ponašanje (npr. dugo zadržavanje na manjim vrijednostima funkcije cilja). Nepromjenjivi čvorovi koji za susjede imaju promjenjive čvorove mogu uzrokovati sporu konvergenciju, a često je zbog takvih čvorova minimum funkcije cilja relativno velika vrijednost, pa je teško razlikovati lokalni od globalnog minimuma. 

Problemi vezani uz implementaciju su zapravo problemi dizajna algoritama i struktura podataka. S jedne je strane potrebno osigurati brze operacije nad grafom, a s druge strane grafovi mogu zauzimati velik dio memorijskog prostora. Zato je potrebno dizajnirati strukturu grafa koja ne zauzima previše memorijskog prostora, a omogućuje brze operacije. Moguće probleme stvaraju i populacijski algoritmi kod kojih je potrebno čuvati više rješenja. Zbog toga se jedinke ne čuvaju kao grafovi, već je svaka jedinka funkcija bojanja grafa (za svaki čvor zna se koja je njegova boja). Sama struktura (bridovi) sadržana je u strukturi grafa, a jedinka posjeduje vezu na taj graf.

\section{Pohlepni algoritam}

Pojam pohlepnog algoritma u ovom radu podrazumijeva sortirati čvorove grafa po nekom svojstvu, zatim obilaziti čvorove tim redoslijedom i na svaki od njih primijeniti odabranu vrstu bojanja čvora. Vrsta bojanja čvora je način odabira boje za neki čvor. Pohlepni se algoritam koristi kao operator kod metaheuristika, tj. kao metoda koja usmjeruje pretragu.
U radu se koriste sljedeće metode za sortiranje i bojanje čvorova (za svaku od metoda koristi se specijalna oznaka):

Vrste sortiranja čvorova:

\begin{itemize}
	\item \emph{COL} -- sortiranje čvorova prema koliziji (broj susjednih čvorova koji imaju istu boju kao i promatrani čvor)
	\item \emph{FIT} -- sortiranje čvorova prema pogrešci koju generiraju (suma težina konfliktnih bridova iz tog čvora)
	\item \emph{LDO} -- sortiranje prema stupnju čvora $H(v)$
	\item \emph{RND} -- slučajan raspored čvorova
	\item \emph{SDO} -- sortiranje prema zasićenju (broj različitih boja susjednih čvorova)
	\item \emph{SDOLDO} -- sortiranje prema zasićenju, a ako dva čvora imaju isto zasićenje drugi kriterij je stupanj čvorova
	\item \emph{STDORD} -- sortiranje prema oznaci čvora (čvorovi su numerirani)
\end{itemize}

Vrste bojanja čvorova su:

\begin{itemize}
	\item \emph{ABW} -- susjedi čvora sortiraju se silazno prema težini brida, obilazi se svaki susjed i uzima se njegova boja. Ako je ta boja jedna od dopuštenih za promatrani čvor, ta boja više ne može biti odabrana. Kada na raspolaganju ostane samo jedna boja ili su svi susjedi posjećeni, uzima se jedna od boja koja je još uvijek na raspolaganju. 
	\item \emph{MC} -- za svaku dopuštenu boju čvora može se izračunati vrijednost kolizije za promatrani čvor. Boja koja minimizira koliziju za neki čvor odabire se kao nova boja za taj čvor.
	\item \emph{MF} -- isto kao i \emph{MC}, samo što se umjesto kolizije računa greška promatranog čvora (suma težina konfliktnih bridova vezanih za taj čvor)
	\item \emph{RND} -- daje se slučajna dopuštena boja
	\item \emph{START} -- čvoru se daje početna boja (ako je dopuštena) ili se boja ne mijenja ako u inicijalnom bojanju boja nije bila dopuštena
	\item \emph{SWAP} -- čvoru se daje neka boja gdje apsolutno odstupanje od greške (sume konfliktnih bridova) naspram trenutne greške nije veće od nekog praga
	\item \emph{TRG} -- čvoru se daje neka boja čija nova greška (suma konfliktnih bridova) ne prelazi neku fiksnu vrijednost. 
\end{itemize}

Način na koji se vrši lokalna pretraga, odnosno donosi odluka o bojanju čvora važan je dio rješavanja problema bojanja grafova. Jedan od takvih načina opisan je u radu \cite{lit11}, što daje motivaciju za proučavanje postupaka bojanja. Za svaki čvor može se reći da ima određen stupanj slobode. Stupanj slobode može se definirati kao mogućnost odabira boja za neki čvor. Svaki čvor ako odabire boju nekom heuristikom, npr. želi minimizirati svoj doprinos greške, odabire boju koja odgovara minimalnoj lokalnoj grešci. Ako čvor ima npr. velik broj susjeda tada je njegov stupanj slobode manji, jer može odabrati manji broj boja kako bi minimizirao lokalnu grešku. Zato se sortiranjem čvorova po svojstvu (svojstvo koje opisuje koliko je čvor slobodan) daje prednost prvenstva bojanja čvorovima koje je teže obojiti tj. imaju manji stupanj slobode. Time se pokušava usrednjiti vrijednost stupnjeva slobode, jer čvorovi koji kasnije odabiru boju mogu odabrati veći skup boja i time bolje se prilagoditi odluci susjeda koji imaju manji stupanj slobode. Takve analize mogu se pronaći u \cite{lit5, lit12}.

\subsection{Neispravnost pohlepnog algoritma}

Važno je pokazati kako pohlepni algoritam neće uvijek pronaći globalni minimum funkcije cilja. Neka je zadan graf na slici \ref{fig:greedy_alg}.
Slika \ref{fig:crown_empty} prikazuje graf koji je potrebno bojati korištenjem samo dvije boje. Neka su težine svih bridova jednake $1$. Slika \ref{fig:crown_normal} prikazuje 2-legalno obojen graf čija je vrijednost funkcije cilja u optimizaciji jednaka $0$. 
Neka pohlepni algoritam poreda prva tri čvora kako je to označeno na slici \ref{fig:crown_wrong}. Tim poretkom čvorovi biraju svoje boje. Čvor $1$ može odabrati proizvoljnu boju, čvor $2$ odabire istu boju kao i čvor $1$, a treći čvor koji je vezan na čvor $1$ odabire neku novu boju. Ostali čvorovi mogu proizvoljnim redoslijedom birati svoje boje, ali više ne postoji način na koji bi čvorovi odabrali boje, a da graf bude 2-legalno obojen. Greška se dogodila pri odabiru boje za čvor $2$, jer ni jedan susjed nije bio obojen i čvor $2$ imao je mogućnost odabira iste boje kao i čvor $1$.

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_empty.pdf}
                \caption{Neobojen graf}
                \label{fig:crown_empty}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_normal.pdf}
                \caption{2-legalno obojen graf}
                \label{fig:crown_normal}
        \end{subfigure}
         
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_wrong.pdf}
                \caption{Odabir prva tri čvora}
                \label{fig:crown_wrong}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_wrong_full.pdf}
                \caption{Pogrešno obojen graf}
                \label{fig:crown_wrong_full}
        \end{subfigure}
        \caption{Prikaz pravilno obojenog grafa i primjer pohlepnog algoritma}
        \label{fig:greedy_alg}
\end{figure}


Moguće bi rješenje navedenog problema moglo biti u pretraživanju susjednih čvorova. Neka su boje označene brojevima, gdje je prva boja označena s $1$. Prvi čvor odabere se slučajno. Za odabrani se čvor odabere boja s minimalnom oznakom, a nema je u susjednim čvorovima. Sljedeći će čvor biti neki od susjeda trenutnog čvora. Ako čvor nema susjeda za odabir, onda se traži čvor koji nije obojen, ali ima obojenog susjeda (pretpostavka je da je graf povezan). Ovako opisan algoritam uvijek će dobro bojati graf na slici \ref{fig:crown_empty}. Potrebno je, ako ima, pronaći graf na kojem ovakav pohlepni algoritam koji se još i naziva \emph{uspinjanje na vrh}, ne radi dobro. Primjer takvog grafa i odabir čvorova može se vidjeti na slici \ref{fig:hill_climbing}. Brojevi u čvorovima predstavljaju poredak obilaženja grafa. Na slici \ref{fig:hill_climbing_ok} odabir čvorova je takav da je ukupan broj boja, a da funkcija cilja bude $0$, jednak $3$. To je ujedno i minimalni broj boja, jer u grafu postoje tri čvora koja su međusobno povezana, što bi značilo da s manjim brojem boja nije moguće legalno bojati graf. Na slici \ref{fig:hill_climbing_wrong} odabir čvorova je bio takav da u zadnjem posjećenom čvoru $8$ bilo potrebno odabrati novu boju da bi graf bio legalno obojen. Kako se pokazalo da je graf moguće bojati s $3$ boje, zaključak je da algoritam ne daje uvijek točan rezultat.

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
                \includegraphics[width=\textwidth]{Slike/hill_climbing_ok.pdf}
                \caption{Dobar odabir čvorova}
                \label{fig:hill_climbing_ok}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.4\textwidth}
                \includegraphics[width=\textwidth]{Slike/hill_climbing_wrong.pdf}
                \caption{Loš odabir čvorova}
                \label{fig:hill_climbing_wrong}
        \end{subfigure}
        \caption{Isti algoritam uz drugačiji odabir čvorova daje različita k-legalna bojanja}
        \label{fig:hill_climbing}
\end{figure}



\section{Agentski algoritam}

Agentski algoritam inspiriran je dobrim rezultatima pohlepnog algoritma. Glavna jedinica algoritma je agent. Agenti se raspoređuju po grafu, gdje se neki agent postavlja na neki čvor grafa. \emph{Globalna iteracija} je jedna iteracija algoritma u kojoj svaki agent svome čvoru pridruži neku boju. Agenti se boduju i to tako da na početku svi imaju $0$ bodova, a nakon globalne iteracije broj bodova je za nekog agenta jednak maksimalnoj pogrešci nekog susjednog čvora, na koji se i agent pomakne. Zatim se agenti sortiraju prema bodovima i u sljedećoj globalnoj iteraciji pravo na bojanje prvo dobiva agent s najviše bodova. Slično kao i kod pohlepnog algoritma, prvo se obrađuju \emph{teški čvorovi}, a to je u ovom algoritmu modelirano pomoću bodovanja. Agenti se, osim akcije pomaka na \emph{najbolji} čvor, mogu pomaknuti na slučajan susjedni čvor ili pak ostati na čvoru na kojem jesu. Tada bodovi za agenta ostaju isti. Algoritam podsjeća na mravlje algoritme \engl{ant colony optimization} \cite{lit3}, ali kako algoritam daje lošije rezultate za klasični problem bojanja grafova u radu je odlučeno koristiti agentski algoritam.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Broj agenata -- $N$
	\item Broj globalnih iteracija -- $G$
	\item Način na koji agenti bojaju čvorove (vrsta bojanja) -- $CS$
	\item Vjerojatnost ostajanja agenta na trenutnom čvoru -- $PR\_NO\_MOVE$
	\item Vjerojatnost pomaka agenta na slučajni čvor u susjedstvu -- $PR\_RND\_MOVE$
\end{enumerate}

\subsection{Detalji algoritma}

Koristi se pseudok\^{o}d kako bi se algoritam opisao formalno. U sustavu se nalazi $N$ agenata koje je prvo potrebno inicijalizirati, odnosno postaviti svakog agenta na neki od čvorova grafa. U svakoj se od $G$ globalnih iteracija, prolazi kroz populaciju agenata i svaki od njih prvo pridruži svome čvoru boju, a nakon toga radi funkciju pomaka. Nakon što se to obavi za svakog agenta, agenti se sortiraju prema bodovima koje su dobili u funkciji pomaka "\emph{MOVE}". U sljedećoj se iteraciji agenti obilaze po bodovima, od onog agenta koji ima najviše bodova do onog s najmanje bodova.

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d agentskog algoritma]
		ALGORITHM(N, G, CS, PR_NO_MOVE, PR_RND_MOVE):
			AGENT[N]
			FOR i = 1 TO N:
				init(AGENT[i])
			END FOR
			FOR j = 1 TO G:
				FOR i = 1 TO N:
					SETCOLOR(AGENT[i], CS)
					MOVE(AGENT[i], PR_NO_MOVE, PR_RND_MOVE)
				END FOR
				SORT(AGENT[N])
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}

Funkcija pomaka ovisi o promatranom agentu i parametrima tj. vjerojatnostima "$PR\_NO\_MOVE$" i "$PR\_RND\_MOVE$". Prvo se radi odabir ostaje li agent na istom čvoru ili ne. Ako ne ostaje, opet se stohastički određuje akcija ide li agent na čvor koji u susjedstvu radi najveću grešku ili ide na slučajnog susjeda. Ako agent odabire pomak prema najboljem susjedu, sljedeći čvor ne može biti isti onaj s kojeg je agent došao na trenutno promatrani, čime se sprječava titranje agenta.

\begin{singlespace}
	\begin{lstlisting}[caption=Detalji funkcije pomaka - MOVE]
		MOVE(AGENT, PR_NO_MOVE, PR_RND_MOVE):
			IF random() < PR_NO_MOVE THEN
				RETURN
			END IF
			NEXT_NODE = AGENT.NODE
			IF random() < PR_RND_MOVE THEN
				NEXT_NODE = AGENT.NODE.NEIGHBOUR[random()]
			ELSE
				FOR k = 1 TO AGENT.NODE.DEGREE:
					IF AGENT.NODE.NEIGHBOUR[k] = AGENT.BLOCK_NODE THEN
						CONTINUE
					ERROR = AGENT.NODE.NEIGHBOUR[k].ERROR
					IF ERROR > MAX_ERROR THEN
						MAX_ERROR = ERROR
						NEXT_NODE = AGENT.NODE.NEIGHBOUR[k]
					END IF
				END FOR
					AGENT.SCORE = MAX_ERROR
			END IF
			AGENT.BLOCK_NODE = AGENT.NODE
			AGENT.NODE = NEXT_NODE
		END MOVE
	\end{lstlisting}
\end{singlespace}

\subsection{Karakteristike algoritma}

Kako je algoritam temeljen na pohlepnom algoritmu, ima nedostatak što lako zapinje u lokalnom minimumu. Dobra je strana algoritma što jedna globalna iteracija može vremenski trajati kraće od jedne iteracije pohlepnog algoritma, jer može posjedovati broj agenata manji od broja čvorova. Algoritam ima ugrađeno određeno znanje, tj. agent cilja na čvorove koje mora popraviti. Prednost dobivaju agenti koji moraju popraviti čvorove s većim greškama. Da bi se izbjegla brza konvergencija u legalni minimum, stohastički način odabira pomicanja omogućuje da agenti šetnjom dođu u područje koje bi trebalo popraviti. Ako je broj agenata veći od broja čvorova, to omogućuje fino traženje minimuma. U tom će slučaju jedan čvor biti više puta obojen (minimiziran), a to znači da mu se prvo može dati neka boja, zatim se bojaju susjedi i onda opet taj isti čvor dolazi na red. Taj efekt propitkivanja starog poteza (koji se u ovom slučaju implicitno događa) omogućuje bolju odluku za pridruživanje boje. Nedostatak je produljenje vremena trajanja globalne iteracije.

Vremenska složenost algoritma ovisi o broju agenata i broju globalnih iteracija. Vremenska složenost je: $O(G\cdot(N+Nlog(N))=O(G\cdot N+G\cdot Nlog(N))=O(G\cdot Nlog(N))$. Kao što je vidljivo, algoritam polinomno ovisi o $G$ i $N$. U ovoj analizi složenosti, kao i ostalim koje slijede zanemarena je složenost izračuna funkcije cilja. Svaki algoritam za svako rješenje koje pamti dodatno koristi broj koraka koji je proporcionalan broju bridova u grafu, jer je vremenska složenost funkcije cilja $O(E(G))$. 

\section{Algoritam evolucijske strategije}

Skupina evolucijskih algoritama veoma je popularna u rješavanju optimizacijskih problema. Takvi algoritmi spadaju u još veću skupinu algoritama koji se nazivaju \emph{metaheuristike}, što znači da konkretno ponašanje algoritma ovisi o postavljenim parametrima. Svim evolucijskim algoritmima zajedničko je što posjeduju populaciju rješenja, te iz koraka u korak evoluiraju rješenje, što nužno ne mora značiti dobivanje boljeg rješenja, već algoritmi provode usmjereno pretraživanje prostora stanja. Evolucijska strategija vrsta je evolucijskog algoritma kod kojeg je dominantan operator mutacije. Genetski algoritam je poopćenje evolucijskih strategija jer se koristi operator selekcije, te se operator križanja koristi češće od operatora mutacije. Operator selekcije koristi se za odabir roditelja. Operator križanja je operator koji kombinira roditelje (rješenja) i njihovom kombinacijom (nije definirano kako) generira djecu (nova rješenja). Križanje se koristi kako bi se prostor stanja finije pretraživao, tj. kako bi se vršila lokalna pretraga. Operator mutacije djeluje nad jednim djetetom i mijenja izgled te jedinke. Mutacija se koristi kako bi se pretraga pomaknula u neki drugi dio prostora stanja i zadužena je za sprječavanje konvergencije u lokalne ekstreme. 

\subsection{Genetski algoritam}

Kao preliminarni dio ovog rada, isprobano je nekoliko vrsta genetskih algoritama. Jednostavni genetski algoritam koristi turnirsku selekciju, operator križanja s jednom točkom prekida te mutaciju koja slučajno promjeni nekoliko gena u zapisu rješenja. Algoritam se pokazao veoma lošim na problemu optimizacijskog problema bojanja grafova. Ako se kao rješenje koristi niz brojeva, gdje svaki element predstavlja jedan čvor u grafu, a vrijednost elementa boju, tada operator križanja nema previše smisla zbog toga što su čvorovi povezani u određenu strukturu, a križanje s jednom točkom prekida nema znanje o tome. Drugi je problem slučajna mutacija, koja može rješenje staviti u neki drugi dio prostora stanja, ali je teško odrediti njezin utjecaj i jako ovisi o konkretnom grafu. Drugi je korak bilo korištenje hibridnog genetskog algoritma u kojem je za operator mutacije korišten pohlepni algoritam. Rezultati u ovom slučaju također nisu bili dobri, tj. algoritam se ponašao kao slučajna pretraga prostora. Najveći je problem podešavanje parametara i njihova osjetljivost. Jedno od mogućih pristupa je kreiranje operatora križanja koji je usko povezan uz domenu problema, jedan od primjera naveden je u \cite{lit17}. Drugi pristup je izbacivanje operatora križanja, čime se efektivno dobiva evolucijska strategija. Takav se pristup koristi u članku \cite{lit12}, gdje je zamijećeno loše ponašanje genetskog algoritma tj. jednostavnih operatora križanja. U ovom radu koristi se evolucijska strategija. Takav je izbor načinjen zbog očekivanog manjeg vremena izvođenja evolucijske strategije, jer se koristi jedan operator manje, za razliku od genetskog algoritma. Mutacija u tom slučaju poprima dvojaku ulogu, tj. potrebno je implementirati više vrsta mutacija -- one koje će obavljati lokalnu pretragu i one koje će obavljati globalnu pretragu.

\subsection{Evolucijska strategija}

Odabrana je evolucijska strategija koja se koristi u članku \cite{lit17}. Koristi se ($\mu$, $\lambda$) evolucijska strategija. Oznake $\mu$ i $\lambda$ služe za oznake skupova jedinki (rješenja). Skup $\mu$ je skup roditeljskih jedinki iz kojih se stvara skup djece $\lambda$. Iz toga proizlazi da broj elemenata u skupu $\lambda$ mora biti veći ili jednak broju elemenata u skupu $\mu$. Jedinka je predstavljena kao niz brojeva, gdje svaki element predstavlja neki čvor, a vrijednost elementa je boja čvora. U svakoj iteraciji, algoritam uniformno bira $|\lambda|$ jedinki iz skupa roditelja. Može se dogoditi da je neka jedinka više puta odabrana. Za svaku odabranu jedinku koristi se operator mutacije. Slučajnim se odabirom bira između mutacije koja ima lokalni karakter, tj. trenutno rješenje nastoji poboljšati lokalnom pretragom prostora stanja, i mutacije koja skače iz okoline trenutne točke prostora stanja. Mutacija se implementira pomoću vrsta bojanja. Sve se takve mutirane jedinke stavljaju u skup $\lambda$. Na kraju postupka najboljih $|\mu|$ jedinki kopira se u $\mu$ skup. Poželjno je koristiti elitizam kako se najbolje rješenje kroz iteracije ne bi izgubilo.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Veličina skupa $\mu$ -- $MI\_SIZE$
	\item Veličina skupa $\lambda$ -- $LAMBDA\_SIZE$
	\item Ukupan broj iteracija -- $N$
	\item Broj mutacija nad jednom jedinkom -- $M$
	\item Vjerojatnost mutacije gena pomoću lokalne pretrage -- $PROP$
	\item Način bojanja za globalnu pretragu -- $CS\_GLOBAL$
	\item Način bojanja za lokalnu pretragu -- $CS\_LOCAL$
\end{enumerate}

\subsection{Detalji algoritma}

Kostur algoritma izgleda veoma jednostavno. Kao što je opisano, iz skupa $\mu$ bira se jedinka koja se mutira i stavlja u $\lambda$ skup. Najbolji se kopiraju u skup $\mu$ i brišu se sve stare jedinke. 

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d evolucijske strategije]
		ALGORITHM(MI_SIZE, LAMBDA_SIZE, N, M, PROP, CS_GLOBAL, CS_LOCAL):
			MI[MI_SIZE]
			LAMBDA[LAMBDA_SIZE]
			FOR i = 1 TO MI_SIZE:
				init(MI(i))
			END FOR
			FOR j = 1 TO N:
				LAMBDA.clear()
				FOR i = 1 TO LAMBDA_SIZE:
					unit = SELECT(MI)
					MUTATION(unit, M, PROP, CS_GLOBAL, CS_LOCAL)
					LAMBDA.insert(unit)
				END FOR
				SORT(LAMBDA)
				MI.clear()
				FOR i = 1 TO MI_SIZE:
					MI.insert(LAMBDA[i])
				END FOR
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}

Najvažnija je stvar u algoritmu operator mutacije. Operator mutacije kao argumente prima jedinku koja će se promijeniti, broj gena koji se mijenjaju (čvorova), vjerojatnost lokalne pretrage, vrstu bojanja za lokalnu pretragu i vrstu bojanja za globalnu pretragu. 

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d mutacije evolucijske strategije]
		MUTATION(unit, M, PROP, CS_GLOBAL, CS_LOCAL):
					choice = random()
					FOR i = 1 TO M:
						index = random()
						IF choice < PROP THEN
							SETCOLOR(unit[i], CS_LOCAL)
						ELSE
							SETCOLOR(unit[i], CS_GLOBAL)
						END IF
		END MUTATION
	\end{lstlisting}
\end{singlespace}

\subsection{Karakteristike algoritma}

Algoritam ima relativno velik broj parametara, što ga čini teškim za prilagodbu konkretnom problemu (grafu). Veličine skupova za roditelje i djecu trebale bi biti relativno male zbog vremena izvođenja. Većina je parametara vezana za mutaciju i to je najosjetljiviji dio algoritma. Potrebno je osigurati čestu lokalnu pretragu, ali i s druge strane, osigurati skakanje iz lokalnih minimuma. Algoritam često zapinje na platoima. Iako konvergencija može biti brža od agentskog algoritma, vrijeme izvođenja je duže.
Vremenska složenost algoritma je ($LS$ je skraćeno za $LAMBDA\_SIZE$): $O(N\cdot(LS \cdot M + LS\cdot log(LS)))=O(N\cdot LS\cdot M + N\cdot LS \cdot log(LS))$. U praksi je čest slučaj: $LS\le M$, pa je vremenska složenost: $O(N\cdot LS \cdot M)$. Algoritam polinomno ovisi o tri parametra, što predstavlja problem ako su oni relativno veliki. S jedne je strane potrebno osigurati dovoljan broj koraka algoritma kako bi se došlo do željene vrijednost funkcije cilja, broj djece $LS$ ne smije biti premalen -- kako bi se zadržao genetski kod, a veličina mutacije $M$ ne smije biti prevelika zbog velikog odstupanja, a s druge strane ne smije biti premala zbog spore konvergencije. 

\section{Simulirano kaljenje}

Simulirano kaljenje također spada u skupinu evolucijskih algoritama. Njegova specifičnost je da se koristi samo jedna jedinka koja iz koraka u korak evoluira. Algoritam je inspiriran kaljenjem metala. Rješenje se nužno ne poboljšava iz koraka u korak, ali je vjerojatnost pogoršanja rješenja kako algoritam napreduje sve manja. Dopuštanjem lošijih rješenja nastoji se izbjeći lokalni optimum. Pretpostavka je da s vremenom algoritam dolazi u željeno područje globalnog optimuma. Na početku algoritam vrši globalnu pretragu, da bi s vremenom prostor stanja počeo pretraživati na finiji način. Simulirano kaljenje se često koristi kao alat u rješavanju problema bojanja grafova kao što se to prikazuje u radu \cite{lit13}.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Početna temperatura -- $T\_START$
	\item Globalni broj koraka algoritma -- $G$
	\item Broj iteracija s istom temperaturom -- $E$
	\item Faktor smanjenja temperature -- $\alpha$
	\item Vjerojatnost lokalne vrste bojanja -- $PROP$
	\item Način bojanja za globalnu pretragu -- $CS\_GLOBAL$
	\item Način bojanja za lokalnu pretragu -- $CS\_LOCAL$
\end{enumerate}

\subsection{Detalji algoritma}

Algoritam kreće od početnog rješenja (jedinke) koja se označava s $X$. Prikaz rješenja je klasičan, svaki čvor je element u nizu, a vrijednost  elementa je boja čvora. Susjedno rješenje od $X$ u oznaci $S$ je rješenje koje ima sve elemente niza jednake kao i $X$ osim točno jednog elementa. U svakom se koraku algoritma iz rješenja $X$ generira susjedno rješenje $S$. Ako rješenje $S$ ima vrijednost funkcije cilja manju od $X$, tada se $X$ zamjenjuje s $S$. U slučaju da je vrijednost funkcije cilja veća, tada se rješenje prihvaća s vjerojatnošću (ovisi o trenutnoj temperaturi $T$):
 
\begin{equation}
	P(X=S) = e^{-\frac{f(S)-f(X)}{T}}
\end{equation}

Kako temperatura $T$ pada, vjerojatnost prihvaćanja pada u $0$, uz pretpostavku $f(S)\ge f(X)$:

\begin{equation}
	\lim_{T\rightarrow 0 } e^{-\frac{f(S)-f(X)}{T}} = 0	
\end{equation}

U ovoj implementaciji simuliranog kaljenja koriste se dvije petlje. Vanjska, koja služi za smanjivanje temperature i unutarnja koja traži rješenja u susjedstvu s istom temperaturom $T$. Koriste se dvije vrste traženja susjeda: lokalna i globalna. Prvo služi kako bi se našlo bolje rješenje, a druga vrsta traženja služi kako bi se rješenje pogoršalo u svrhu prelaska u novo područje prostora stanja. 

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d simuliranog kaljenja]
		ALGORITHM(T_START, G, E, ALFA, PROP, CS_GLOBAL, CS_LOCAL):
			init(X)
			FOR i = 1 TO G:
				FOR j = 1 TO E:
					S = X
					IF random() < PROP THEN
						SETCOLOR(X[random()], CS_LOCAL)
					ELSE
						SETCOLOR(X[random()], CS_GLOBAL)
					END IF
					dE = f(S) - f(X)
					IF ( dE < 0 OR random() < EXP(-dE/T) ) THEN
						X = S
					END IF
				END FOR
			T = T * ALFA
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}

\subsection{Karakteristike algoritma}

Algoritam je relativno jednostavan za implementaciju. Dobra je strana što za razliku od drugih promatranih algoritama ima manju memorijsku složenost, zbog toga što koristi samo dvije jedinke ($X$ i $S$). Za parametar početne temperature $T$ nije potrebno ispitivati najbolju vrijednost, već se može izračunati kao: za prvi korak u algoritmu potrebno je uzeti lošije rješenje s $50\%$ vjerojatnosti. Prvi se korak greške procijeni prema problemu i ponašanju algoritma: $\tilde{dE}\sim f(S_1)-f(X_1)$.  

\begin{equation}
\textup{T\_start} = -\frac{dE}{ln(P)} = 1.443 \cdot dE
\end{equation}  

Parametar $\alpha$ potrebno je namjestiti kako temperatura ne bi padala prebrzo -- zapinjanje u lokalnim optimumima, ili kako ne bi padala presporo -- slaba konvergencija. Vremenska složenost algoritma je: $O(G\cdot E)$, što je veoma dobro svojstvo jer samo dva parametra utječu na vrijeme izvođenja, i to polinomno. 

\section{Genetsko kaljenje}

Genetsko kaljenje \cite{lit18} je algoritam koji kombinira dvije ideje: genetski algoritam i simulirano kaljenje. Ideja je ista kao i kod simuliranog kaljenja, samo što se u sustavu nalazi više jedinki (rješenja). Rješenja međudjeluju preko parametra slobodne energije. Na početku je zadana početna energija, koja se ravnomjerno raspoređuje po svim jedinkama. Za svaku se jedinku u sustavu napravi mutacija i dobiva se susjedno stanje. Nova jedinka ima neku vlastitu energiju (funkcija cilja) te se prihvaća kao novo rješenje ako je vlastita energija nove jedinke manja od zbroja stare jedinke i djela slobodne energije koju je stara čestica dobila. Tako slobodna energija utječe na odabir lošijih jedinki.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Ukupan broj iteracija -- $G$
	\item Broj jedinki -- $N$
	\item Početna energija -- $E$
	\item Faktor hlađenja -- $\alpha$
	\item Vjerojatnost lokalne vrste bojanja -- $PROP$
	\item Način bojanja za globalnu pretragu -- $CS\_GLOBAL$
	\item Način bojanja za lokalnu pretragu -- $CS\_LOCAL$
\end{enumerate}


\subsection{Detalji algoritma}

Na početku se inicijaliziraju jedinke. Slobodna energija postavi se na početnu energiju i algoritam kreće u rad. Svaka jedinka dobije dio slobodne energije u obliku praga $T$. To znači da jedinka može odstupati od svog roditelja za najviše prag $T$ da bude prihvaćena kao nova jedinka. Ako je prihvaćena, energija koja nije iskorištena, a to je razlika energije stare jedinke i nove jedinke (gdje se prag $T$ nadodaje staroj jedinki), dodaje se u slobodnu energiju za tu iteraciju. Na kraju, da se ne bi dogodila divergencija, slobodna energija množi se faktorom $\alpha \in [0,1]$.  

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d genetskog kaljenja]
		ALGORITHM(G, N, E, ALFA, PROP, CS_GLOBAL, CS_LOCAL):
			UNITS[N]
			FOR i = 1 TO N:
				init(UNIT[i])
			END FOR
			FREE_ENERGY = E
			FOR j = 1 TO G:
				T = FREE_ENERGY / N
				FREE_ENERGY = 0
				FOR i = 1 TO N:
					new_unit = MUTATION(UNIT[i], PROP, CS_GLOBAL, CS_LOCAL)
					IF f(new_unit) < f(UNIT[i]) + T THEN
						D = f(UNIT[i]) + T - f(new_unit)
						FREE_ENERGY = FREE_ENERGY + D
						UNIT[i] = new_unit
					ELSE
						FREE_ENERGY = FREE_ENERGY + f(UNIT[i]) + T
					END IF
				END FOR
			FREE_ENERGY = FREE_ENERGY * ALFA
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}


\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d mutacije genetskog kaljenja]
		MUTATION(unit, PROP, CS_GLOBAL, CS_LOCAL):
			IF random() < PROP THEN
				SETCOLOR(unit[random()], CS_LOCAL)				
			ELSE
				SETCOLOR(unit[random()], CS_GLOBAL)
			END IF
		END MUTATION
	\end{lstlisting}
\end{singlespace}


\subsection{Karakteristike algoritma}

Algoritam izgleda veoma slično kao i simulirano kaljenje, samo što se odluka za prihvaćanje novog rješenja donosi na temelju praga, tj. odstupanja funkcije cilja od stare jedinke. Međudjelovanje jedinki temelji se na slobodnoj energiji, koja se u svakoj iteraciji skuplja kao dodatak koji nije potrošen. Ako se nova jedinka ne prihvaća tada slobodna energija ostaje neiskorištena i ostaje u sustavu, što omogućuje veću netoleranciju u idućem koraku. To je mehanizam algoritma za izbjegavanje lokalnih optimuma.
Za rješavanje optimizacijskog problema bojanja grafova koriste se dvije vrste dobivanja susjednog rješenja (mutacije). Kao i za neke prethodne algoritme, koriste se lokalna i globalna vrsta bojanja.  
Vremenska složenost algoritma je: $O(G \cdot N)$, s time da je to nešto veća vremenska složenost od simuliranog kaljenja ako se u obzir uzme računanje funkcije cilja za $N$ jedinki.

\section{Pronalaženje najpogodnijeg pohlepnog algoritma}
\label{sec:ml}
Pohlepni se algoritam u ovom radu koristi na dva načina. Prvo se koristi kao metoda koja dovodi rješenje u dovoljno dobro početno rješenje, nakon čega minimizaciju funkcije preuzima neka metaheuristika. Drugi način korištenja je kao dio metaheuristike u obliku operatora (npr. mutacija kod genetskog algoritma), metoda za izbjegavanje lokalnog minimuma (tuneliranje) ili pak metoda koja osigurava da postotak promjene boja naspram inicijalnog grafa ne prođe zadani prag. Kod korištenja pohlepnih algoritama u praksi se često koriste \emph{ad-hoc} metode konfiguriranja istog. Prednost je ovakvih metoda što u relativno kratkom vremenu mogu isprobati različite konfiguracije i zatim odabrati najbolju. Nedostatak metode je u tome što ta konfiguracija ne jamči dobar rad nad svim grafovima (\emph{No free lunch} teorem). Kao uvod u hiper-heuristike i postavljanje temelja za budući rad, iz grafova se želi izvući znanje o utjecaju vrsta sortiranja čvorova. Ovaj dio rada ima dva cilja. Prvi je pronaći optimalni operator usporedbe čvorova koji kombinira sve dostupne operatore tj. vrste sortiranja. Drugi cilj je dovesti u vezu vrstu sortiranja i način bojanja tj. empirijski pokazati koja vrsta sortiranja je najbolja za koju vrstu bojanja. Rezultati bi mogli pokazati određenu vezu između svojstava grafova i vrste sortiranja, što bi se moglo koristiti kao uvod u istraživanje hiper-heuristika. Metoda pronalaženja pogodnog pohlepnog algoritma sastoji se od koraka:

\begin{enumerate}
	\item Generiranje grafa.
	\item Odabir vrste bojanja za pohlepni algoritam.
	\item Pokretanje pohlepnog algoritma s vrstom sortiranja \emph{RND}.
	\item Iz svih pokretanja pohlepnog algoritma uzeti određen postotak najboljih rezultata.
	\item Za svaki čvor izračunati relativnu poziciju kao $\frac{x+1}{N}$ gdje je $x$ indeks u slučajno sortiranom nizu čvorova, a $N$ ukupan broj čvorova u grafu. 
	\item Za svaku relativnu poziciju izračunati svojstva tog čvora (stupanj, zasićenje, koliziju, grešku).
	\item Nekom od metoda regresije pronaći funkciju čiji su argumenti svojstva čvora, a rezultat je relativna pozicija.
\end{enumerate}

Tako dobivena funkcija može se koristiti kao vrsta sortiranja. Za neke se vrste regresija veoma lako interpretiraju rezultati, pa je lako odrediti u kojoj mjeri svojstva čvora utječu na dobar rezultat. Za različite vrste bojanja moguće je uspoređivati funkcije i uočiti ovisnosti. Za različite grafove usporedbom funkcija može se izvući znanje o pogodnom algoritmu za pojedine vrste grafova. Ovaj rezultat može se koristiti kao temeljno znanje za proučavanje automatskog odabira algoritama \cite{lit14}.

\section{Tuneliranje}

\emph{Tuneliranje} je tehnika koja se može ugraditi u bilo koji optimizacijski algoritam i služi za izlazak iz lokalnog minimuma. Tehnika je vrlo slična \emph{mutacijama} kod evolucijskih algoritama. Razlika je u tome što ova tehnika ne odabire slučajno novu točku iz prostora pretraživanja stanja, već nastoji odabrati točku koja ima približnu vrijednost funkcije cilja kao i trenutna točka koja se promatra (npr. relativna razlika funkcija cilja mora biti manja od nekog praga). Kako nova točka u prostoru pretrage ima sličnu vrijednost funkcije cilja, algoritam nastoji pronaći minimum u toj okolini, a to teorijski znači da funkcija cilja može samo padati. U praksi se može dogoditi da i poraste jer se za novu točku ne zahtijeva da vrijednosti budu identične, već približno jednake. Nova se točka traži tako što se po redu pretražuje dimenzija po dimenzija linearno. U problemu optimizacije bojanja grafa to znači da se po redu za svaki čvor ispituju boje, i ako za trenutni čvor nova boja za čvor ne utječe na vrijednost greške, tada se ta boja ostavlja tome čvoru. Ako se u pohlepnom algoritmu kao vrsta bojanja koristi "\emph{SWAP}" metoda, dobije se očekivani efekt. 

U navedenom pseudok\^{o}du nova se točka postavlja u trenutnu. Zatim se vanjska petlja vrti po dimenzijama i za svaku se ispituju svi elementi (npr. boje). Element koji za apsolutno odstupanje daje vrijednost manju od praga $T$, postavlja se kao element za tu dimenziju i potraga kreće na sljedeću dimenziju.

\begin{singlespace}
	\begin{lstlisting}[caption=Metoda tuneliranja - implementacija]
		TUNNELING(f, X)
			NEW_X = X
			FOR i = 1 TO X.length()
				FOR EACH element in DIMENSION(i):
					NEW_X.dimension(i) = element
					IF |f(NEW_X)-f(X)| < f(X)*T:
						 BREAK
					NEX_X.dimension(i) = X.dimension(i)
				END FOR
			END FOR
			RETURN NEW_X
		END TUNNELING
	\end{lstlisting}
\end{singlespace}

\section{Upravljanje postotkom promijenjenih čvorova}

Kako je sekundarni kriterij optimizacije da postotak promijenjenih čvorova naspram inicijalnog stanja ne prođe neku granicu (konkretno 66\%), potrebno je ostvariti mehanizam koji to omogućuje. U ovom se radu koristi pristup težnje boje da postane početna. U vrste bojanja implementira se mehanizam biranja boja za koji vrijedi da ako je početna boja jedna od mogućih, ona se iskorištava za bojanje čvora.

\chapter{Programsko rješenje}

Za rješavanje zadanog optimizacijskog problema bojanja grafova i ispitivanja navedenih algoritama, odlučeno je da će se izgraditi infrastruktura koja omogućuje brzi razvoj i ispitivanje algoritama. Ideja je izgraditi radnu okolinu u kojoj korisnik može iskoristiti već napisane module za standardne operacije koje se koriste i jednostavno ih uvesti u svoj algoritam. Koristi se jezik \emph{Java} zbog relativno visoke apstrakcije, mogućnosti objektnog oblikovanja aplikacije i prenosivosti. Veoma važan cilj koji se nastoji ostvariti je infrastruktura koja je lako nadopunjiva novim modulima za buduću upotrebu. Moduli aplikacije koji su razvijeni za ovaj rad:

\begin{enumerate}
	\item \emph{main} -- glavna metoda za pokretanje algoritama
	\item \emph{common} -- generičke strukture podataka
	\item \emph{input} -- implementacije različitih ulaznih formata
	\item \emph{output} -- implementacija različitih izlaznih formata
	\item \emph{algorithm} - apstrakcija algoritma bojanja grafova
	\item \emph{unit} -- jedinka (prikaz rješenja) koja se koristi u populacijskim algoritmima
	\item \emph{algorithmset} -- modul za spremanje implementacija algoritama
	\item \emph{greedy} -- implementacija pohlepnog algoritma
	\item \emph{color\_selector} -- implementacije vrsta bojanja
	\item \emph{order} -- implementacija različitih vrsta sortiranja čvorova
	\item \emph{agents} -- implementacija agentskog algoritma
	\item \emph{genetic} -- implementacija genetskog algoritma (strategije)
	\item \emph{simulated\_annealing} -- implementacija simuliranog kaljenja
	\item \emph{structure} -- najviša apstrakcija grafa -- jednostavni graf
	\item \emph{weight\_graph} -- apstrakcija težinskog grafa 
	\item \emph{ericsson\_graph} -- graf koji posjeduje strukture pogodne za rješavanje optimizacijskog problema
	\item \emph{stat} -- generičke (statičke) metode koje se koriste za računanje statistika ili svojstava koja ne spadaju u druge strukture
	\item \emph{machine\_learning} -- modul za izvlačenje značajki iz grafa i pripremu podataka za strojno učenje
\end{enumerate}

U nastavku slijedi detaljni opis nekih modula koji su najvažniji za rad infrastrukture. Detaljne upute o korištenju infrastrukture priložene su u digitalnom obliku uz ovaj rad.

\subsection{Modul \emph{input}}

Funkcija ovog modula je osigurati učitavanja raznih formata zapisa grafa u datotekama. Graf u datoteci može biti zapisan proizvoljnim formatom, pa je cilj modula da obuhvati što više formata. Jedan od formata specifičan je za optimizacijski problem. Implementirani su i neki jednostavni formati. 

\subsection{Modul "\emph{output}"}

Kao što je funkcija prethodnog modula učitavanje, tako je funkcija ovog modula zapis grafa u datoteku. Podržan je jednostavan format koji zapisuje identifikator čvora i njegovu boju. Podržan je zapis koji graf pretvara u format potpun za optimizacijski problem, ali je veličina datoteke koja nastaje duplo manja od originalnog ulaznog formata. Osim zapisa grafa, ovaj modul omogućuje i ispis statistika u drugim formatima koji se mogu koristi u drugim alatima, primjerice alatima za strojno učenje.

\subsection{Modul "\emph{algorithm}"}

Modul implementira strategiju kao oblikovni obrazac. Korisnik pri pokretanju algoritma stvara kontekst u kojem navodi konkretan algoritam. Nakon toga, sučelje prema korisniku je samo kontekst. Svi algoritmi moraju imati implementirano isto sučelje. Kao što se može vidjeti u programskom odsječku \ref{alg:strategija} klasa \emph{GraphAlgorithmContext} ima privatni atribut tj. referencu koja pokazuje na konkretan algoritam. Algoritam se zadaje preko konstruktora. Implementirane su dvije metode istog naziva: \emph{startAlgorithm}, koje kao parametar primaju strukturu podataka graf (\emph{Graph}). Metode se razlikuju u drugom parametru, gdje se kao argument može dati skup identifikatora čvorova koje algoritam smije bojati. One koje ne smije bojati nisu jednaki nepromjenjivim čvorovima (jer to algoritam rješava interno), već se tu čvorovi koji su možda prije obojeni i s pokretanjem novog algoritma korisnik ih ne želi mijenjati, pa zadaje samo skup čvorova koji smiju mijenjati boju. 

\begin{singlespace}
	\begin{lstlisting}[label=alg:strategija, language=Java, caption=Definicija klase i metoda za oblikovni obrazac strategija]

	public class GraphAlgorithmContext {
	
		private GraphColoringAlgorithm algorithm;
	
		public GraphAlgorithmContext(GraphColoringAlgorithm algorithm){
			this.algorithm = algorithm;
		}
	
		public void startAlgorithm(Graph graph){
			algorithm.startAlgorithm(graph);
		}
	
		public void startAlgorithm(Graph graph, Set<Integer> touchableNodes){
			algorithm.startAlgorithm(graph, touchableNodes);
		}
	
	}

	\end{lstlisting}
\end{singlespace}

U programskom odsječku \ref{alg:algorithm} pokazana je implementacija klase \emph{GraphColoringAlgorithm}. Klasa je apstrakcija algoritma za bojanje grafova. Pri stvaranju novog konkretnog algoritma, korisnik je obavezan implementirati metodu \emph{algorithm}, koja je središte implementacije svakog algoritma. Uz to, korisnik ima mogućnost ispitivanja smije li pobojati čvor ili ne -- \emph{checkNode}. Parametre algoritma korisnik zadaje pri pozivu konstruktora za konkretni algoritam.

\begin{singlespace}
	\begin{lstlisting}[label=alg:algorithm, language=Java, caption=Apstraktna klasa algoritma]

	public abstract class GraphColoringAlgorithm {

		private Set<Integer> touchableNodes = null;
		protected Graph graph;

		protected Set<Integer> getTouchableNodes(){
			return this.touchableNodes;
		}

		protected boolean checkNode(int index){
			int id = graph.getNodeId(index);
			if (touchableNodes == null)
				return true;
			return touchableNodes.contains(id);
		}

		protected abstract void algorithm();

		public void startAlgorithm(Graph graph){
			touchableNodes = null;
			this.graph = graph;
			this.algorithm();
		}


		public void startAlgorithm(Graph graph, Set<Integer> touchNodeId){
			touchableNodes = touchNodeId;
			this.graph = graph;
			this.algorithm();
		}
	}
	\end{lstlisting}
\end{singlespace}

\subsection{Modul "\emph{unit}"}

Modul "\emph{unit}" je generička klasa koja se koristi kao prikaz rješenja u populacijskim algoritmima. Zbog prirode problema koja donosi grafove s velikim brojem čvorova i brojem bridova, neučinkovito je pamtiti više instanci grafa zbog nedostatka memorije. Zbog toga se pamte samo parovi čvor-boja, a struktura grafa zadana je referencom. Klasa \emph{GeneralUnit} pruža operacije: 

\begin{itemize}
	\item brzo dohvaćanje funkcije cilja -- \emph{getError()} -- $O(1)$
	\item dohvaćanje broja čvorova -- \emph{getSize()} -- $O(1)$
	\item postavljanje boje čvoru -- \emph{setColor(id, color)} -- $O(|H(v)|)$
	\item postavljanje strukture grafa u boje jedinke -- \emph{updateGraph()} -- $O(|V(G)|)$
\end{itemize}

\chapter{Rezultati}

\section{Karakteristike računala korištenog pri ispitivanju}

\begin{table}[htb]
	\caption{Karakteristike računala}
	\label{tbl:karakteristike-PC}
	\centering
	\begin{tabular}{|l|l|} \hline
		Model & Aspire 5755G \\ \hline
		Operacijski sustav & Linux 3.2.0-23-generic \#36-Ubuntu SMP x86\_64 \\ \hline
		Procesor & Intel(R) Core(TM) i5-2410M CPU \@ 2.30GHz \\ \hline
		Memorija & 8GiB -- 4GiB SODIMM DDR3 Synchronous 1333 MHz (0.8 ns) \\ \hline
		Priručna memorija L1 2x & 32KiB \\ \hline
		Priručna memorija L2 & 256KiB \\ \hline
		Priručna memorija L3 & 3MiB \\ \hline
		Pomoćna memorija & 976MiB Linux swap \\ \hline
		Tvrdi disk & 640GB TOSHIBA MK6465GS \\ \hline
	\end{tabular}
\end{table}

\section{Metode ispitivanja algoritama}


\subsection{Ispitivanje metaheuristika}

Nekoliko je rezultata za metaheuristike bitno kako bi se mogle uspoređivati. Dva svojstva koja najviše utječu na dobrotu metaheuristike su najmanja postignuta vrijednost funkcije cilja i stvarno vrijeme izvođenja. Osim toga, veoma je bitan dio pronalaženje optimalnih parametara metaheuristika. Zbog toga se na skupu ispitnih grafova jedna metaheuristika ispituje s drugačijim parametrima te se najbolji dobiveni rezultat neke metaheuristike uspoređuje s ostalim najboljim rezultatima drugih metaheuristika. Rad metaheuristika proučava se kroz iteracije. Pronalazi se ovisnost broja korištenih iteracija i vrijednosti funkcije cilja, ovisnost broja korištenih iteracija i postotka promjene inicijalnih boja te ovisnost promjene inicijalnih boja o vrijednosti funkcije cilja. Takve ovisnosti mogu pokazati neke karakteristike algoritma, kao što su brzina konvergencije, vrijeme zadržavanja u lokalnim minimumima, te dati smjer za korištenje vrsta odabira boja pri nekoj metaheuristici.

Metaheuristike se ispituju tako da se početno stanje grafa dovede pomoću pohlepnog algoritma u neku točku čija funkcija cilja ima puno manju vrijednost od početnog grafa. Cilj je pohlepnog algoritma da osigura valjano bojenje za svaki čvor, te da se greška dovede do manje vrijednosti. Koristi se pohlepni algoritam u pet koraka. Iz iteracije u iteraciju pohlepni algoritam nastoji bojiti graf pomoću \emph{SDO} sortiranja i \emph{ABW} odabira boja. Ako algoritam zastane u lokalnom minimumu, pomoću \emph{FIT} sortiranja i \emph{MF} odabira boja nastoji se iskočiti iz tog minimuma. Odabrano je pet koraka, jer se eksperimentiranjem to pokazalo kao najbolja opcija, a da bi algoritmi i grafovi bili usporedivi, tj. da pohlepni algoritam ne bi utjecao na brzinu konvergencije, za sve slučajeve ispitivanja ostavljena je ta ista inačica.

\section{Grafovi za ispitivanje}

Za ispitivanje koriste se dvije vrste grafova. Prva vrsta su grafovi koji su generirani iz realnih situacija. Druga vrsta su umjetni grafovi koji su generirani kako bi se moglo proučavati ponašanje algoritama i kako bi se mogli donositi općeniti zaključci. Sintetički primjeri generirani su tako što se promatraju različit broj čvorova i različita gustoća povezanosti istih. Za težine između čvorova uzima se distribucija iz grafova koji su generirani iz realnih situacija kako bi rezultati bili što bliži mogućim primjerima iz stvarnoga svijeta. Na slikama \ref{fig:tokai-hist} i \ref{fig:kansai-hist} vide se distribucije težina (po redu veličine) na dva grafa iz realnog svijeta. Vidljivo je da oko pola težina ima malu vrijednost oko $0$, a ostale težine pripadaju većim vrijednostima.

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/tokai-w-hist.pdf}
	\caption{Tokai graf -- distribucija težina}
	\label{fig:tokai-hist}
\end{figure}


\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/kansai-w-hist.pdf}
	\caption{Kansai graf -- distribucija težina}
	\label{fig:kansai-hist}
\end{figure}

\begin{table}[htb]
	\caption{Popis grafova za ispitivanje}
	\label{tbl:random-test}
	\centering
	\begin{tabular}{|l|r|r|c|c|} \hline
	Naziv grafa & Broj čvorova & Broj bridova & Inicijalna pogreška & Slučajno bojanje\\ \hline \hline
		graph\_700\_0.1 & 700 & 30102 & $1.95\cdot 10^{9}$ &$1.25\cdot 10^{6}$ \\ \hline 
		graph\_700\_0.7 & 700 & 194684 & $1.93\cdot 10^{9}$ &$7.26\cdot 10^{6}$ \\ \hline 
		graph\_700\_0.3 & 700 & 89719 & $2.28\cdot 10^{9}$ &$3.30\cdot 10^{6}$ \\ \hline 
		graph\_700\_0.9 & 700 & 234311 & $1.92\cdot 10^{9}$ &$9.22\cdot 10^{6}$ \\ \hline 
		graph\_700\_0.5 & 700 & 144970 & $2.07\cdot 10^{9}$ &$5.80\cdot 10^{6}$ \\ \hline 
		graph\_500\_0.1 & 500 & 15160 & $1.38\cdot 10^{9}$ &$6.61\cdot 10^{5}$ \\ \hline 
		graph\_500\_0.7 & 500 & 99316 & $1.66\cdot 10^{9}$ &$3.70\cdot 10^{6}$ \\ \hline 
		graph\_500\_0.3 & 500 & 45927 & $1.50\cdot 10^{9}$ &$1.88\cdot 10^{6}$ \\ \hline 
		graph\_500\_0.9 & 500 & 119310 & $1.46\cdot 10^{9}$ &$4.83\cdot 10^{6}$ \\ \hline 
		graph\_500\_0.5 & 500 & 73894 & $1.46\cdot 10^{9}$ &$2.74\cdot 10^{6}$ \\ \hline 
		graph\_900\_0.1 & 900 & 50221 & $2.81\cdot 10^{9}$ &$1.99\cdot 10^{6}$ \\ \hline 
		graph\_900\_0.7 & 900 & 321598 & $2.63\cdot 10^{9}$ &$1.23\cdot 10^{7}$ \\ \hline 
		graph\_900\_0.3 & 900 & 147898 & $2.82\cdot 10^{9}$ &$5.44\cdot 10^{6}$ \\ \hline 
		graph\_900\_0.9 & 900 & 386559 & $2.58\cdot 10^{9}$ &$1.64\cdot 10^{7}$ \\ \hline 
		graph\_900\_0.5 & 900 & 239189 & $2.91\cdot 10^{9}$ &$9.90\cdot 10^{6}$ \\ \hline 
		graph\_4000\_0.1 & 4000 & 1008042 & $1.16\cdot 10^{10}$ &$3.79\cdot 10^{7}$ \\ \hline 
		graph\_4000\_0.7 & 4000 & 6346676 & $1.30\cdot 10^{10}$ &$2.41\cdot 10^{8}$ \\ \hline 
		graph\_4000\_0.3 & 4000 & 2924613 & $1.22\cdot 10^{10}$ &$1.12\cdot 10^{8}$ \\ \hline 
		graph\_4000\_0.5 & 4000 & 4733505 & $1.22\cdot 10^{10}$ &$1.80\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.7 & 3000 & 3571396 & $9.51\cdot 10^{9}$ &$1.39\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.6 & 3000 & 3131418 & $9.48\cdot 10^{9}$ &$1.20\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.9 & 3000 & 4297423 & $9.18\cdot 10^{9}$ &$1.63\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.5 & 3000 & 2666916 & $9.15\cdot 10^{9}$ &$1.03\cdot 10^{8}$ \\ \hline 
		graph\_3000\_0.8 & 3000 & 3970760 & $9.37\cdot 10^{9}$ &$1.52\cdot 10^{8}$ \\ \hline 
		graph\_2000\_0.7 & 2000 & 1589268 & $6.21\cdot 10^{9}$ &$6.13\cdot 10^{7}$ \\ \hline 
		graph\_2000\_0.6 & 2000 & 1392574 & $6.02\cdot 10^{9}$ &$5.41\cdot 10^{7}$ \\ \hline 
		graph\_2000\_0.9 & 2000 & 1910979 & $6.22\cdot 10^{9}$ &$7.36\cdot 10^{7}$ \\ \hline 
		graph\_2000\_0.5 & 2000 & 1181788 & $6.61\cdot 10^{9}$ &$4.74\cdot 10^{7}$ \\ \hline 
		graph\_2000\_0.8 & 2000 & 1764223 & $6.31\cdot 10^{9}$ &$6.62\cdot 10^{7}$ \\ \hline 
		Kansai-C & 8937 & 2259249 & $1.89\cdot 10^{7}$ &$7.40\cdot 10^{8}$ \\ \hline 
		Tokai-B & 4244 & 915283 & $1.29\cdot 10^{9}$ &$2.38\cdot 10^{8}$ \\ \hline 
		Tokai-A & 17066 & 5298396 & $1.83\cdot 10^{10}$ &$9.52\cdot 10^{8}$ \\ \hline 
		Kansai-B & 4925 & 1283991 & $7.53\cdot 10^{7}$ &$3.15\cdot 10^{8}$ \\ \hline 
		Tokai-C & 10518 & 2557187 & $5.74\cdot 10^{9}$ &$5.43\cdot 10^{8}$ \\ \hline 
		Kansai-A & 18807 & 7359859 & $4.69\cdot 10^{9}$ &$1.38\cdot 10^{9}$ \\ \hline 
	\end{tabular}
\end{table}

\section{Slučajno pretraživanje}

Kako bi se opravdalo traženje optimizacijskog algoritma za ovaj problem, potrebno je pokazati kako uniformna raspodjela boja po grafu ne daje zadovoljavajuće rezultate. U ovu je svrhu korišten pohlepni algoritam koji za sortiranje čvorova koristi \emph{RND} metodu i također \emph{RND} vrstu bojanja. Efekt je isti kao da se obilaze čvorovi i svakom se dodijeli slučajna boja iz njegove domene. Nad svakim se grafom pokreće pohlepni algoritam deset puta, nakon čega se rezultat usrednjuje i uspoređuje s početnom pogreškom grafa.

Rezultati su prikazani u tablici \ref{tbl:random-test}.
Kako je očekivana greška u svim grafovima reda veličine $10^3$ ili manje, vidljivo je da slučajno bojanje ne daje dobre rezultate, već rezultati imaju jedan do dva reda veličine manje vrijednosti od inicijalnog bojanja. Razlika bi bila još manja kada bi inicijalna bojanja bila validna, ali kako se takvi čvorovi dodatno kažnjavaju (prema funkciji cilja \ref{equ:funkcija_cilja}), inicijalna pogreška je veća.

\section{Agentski algoritam}

Različite vrste bojanja različito utječu na sam rad agentskog algoritma. Vrsta bojenja \emph{ABW} ima malo vrijeme izvršavanja i daje najbolje rezultate (jedan primjer prikazan je u tablici \ref{tbl:aa-cs1}). Vrsta bojenja \emph{MC} daje najlošije rezultate i koristi puno vremena. Pokazuje se da algoritam ne konvergira kada se koristi \emph{MC} vrsta bojenja. Metoda \emph{MF} također daje malu vrijednost funkcije cilja, ali koristi puno više vremena.

\textbf{Broj agenata} važan je i kritičan parameter u smislu korištenja vremena. Ako ima više agenata konvergencija algoritma je bolja. Za praktične svrhe preporučuje se da broj agenata bude između jedne četvrtine broja čvorova i jedne polovine broja čvorova.

\textbf{Vjerojatnost ostajanja agenta na trenutnom čvoru} mora biti veoma mala. Što je vjerojatnost veća, to algoritam sporije konvergira. Ne preporučuje se premala vrijednost (tj. $0$), jer tada se gubi svojstvo preispitivanja odluke, što daje lošije rezultate. Na slici \ref{fig:agent_alg_move} prikazan je rad algoritma. Što je vjerojatnost manja to je i razlika u radu algoritma manja. 

\textbf{Vjerojatnost pomaka agenta na slučajni čvor u susjedstvu} mora biti dovoljno velika da bi se agenti mogli slučajno raspršiti po grafu, ali ne prevelika kako bi se moglo popravljati susjedstvo. Preporučena vrijednost parametra je oko $0.5$. Na slici \ref{fig:agent_alg_rnd} vidi se da pomak na \emph{najbolji} čvor nije dobar izbor, ali ako se bodovanje koristi u nekom postotku (pomak nije slučajan) tada se mogu dobiti bolji rezultati.


\begin{table}[htb]
	\caption{Vrijeme izvođenja agentskog algoritma uz razne vrste bojanja -- Kansai-C}
	\label{tbl:aa-cs1}
	\centering
	\begin{tabular}{|l||r|r|} \hline
	Vrsta bojenja & Funkcija cilja & Vrijeme izvođenja (s)\\ \hline \hline
	ABW & 40.24 & 893.84 \\ \hline 
	MC & 66681857.46 & 1109.15 \\ \hline
	MF & 40.46 & 1287.86 \\ \hline
	\end{tabular}
\end{table}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/aa/move/move.png}
	\caption{Agentski algoritam -- ovisnost o parametru ostajanja na čvoru -- Kansai-C}
	\label{fig:agent_alg_move}
\end{figure}


\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/aa/rnd/rnd.png}
	\caption{Agentski algoritam -- ovisnost o parametru pomaka na slučajni čvor -- Kansai-C}
	\label{fig:agent_alg_rnd}
\end{figure}

\clearpage



\section{Evolucijska strategija}

Problem evolucijske strategije je sporo izvođenje zbog toga što koristi populaciju. Za svaku jedinku iz populacije potrebno je računati funkciju cilja, što dovodi do sporijeg izvršavanja. Jedan od razloga je implementacija algoritma. Zbog veličine problema i nedostatka memorije na razvojnom računalu, smanjuje se memorijska složenost, ali gubi se na vremenskoj složenosti. Evolucijska strategija ima puno više mogućnosti, ali za to je potrebno i puno više procesorske snage.

U tablici \ref{tbl:es-cs1} prikazano je tipično ponašanje algoritma s različitim vrstama bojenja. Korištenjem \emph{RND} načina bojenja algoritam brže radi, ali su i rješenja lošija. Najbolji izbor je kombinacija \emph{ABW-SWAP} jer za korištenje malo vremena dobivaju se dobri rezultati. Korištenje \emph{MC} lokalnog načina bojenja se ne preporučuje zbog loših rezultata i vremenske neučinkovitosti.

\textbf{Veličina skupa $\mu$} mora biti dovoljno velika kako bi se stvorilo dovoljno jedinki koje mogu evoluirati. Premali skup $\mu$ dovodi rješenje u lokalni minimum iz kojeg je teško izaći. Skup ne smije biti prevelik zbog toga što se vremensko izvođenje povećava. Velik skup zbog uniformne selekcije može dovesti do spore konvergencije, jer se očekuje da se svaka jedinka posjeti jednak broj puta u nekom vremenu.

\textbf{Veličina skupa $\lambda$} svakako mora biti veća od skupa $\mu$. Preporučuje se da skup $\lambda$ bude veličine od $1.5$ do $2$ puta veći od skupa $\mu$. Prevelik skup sporo se obrađuje, ali skup ne smije biti premalen jer može uzrokovati sporu konvergenciju -- mali selekcijski pritisak.

\textbf{Ukupan broj iteracija} ovisi o kompleksnosti grafa, tj. ovisi o tome koliko dobro rješenje se želi dobiti.

\textbf{Broj mutacija nad jednom jedinkom} parametar je koji omogućava nešto bržu konvergenciju. Za grafove s više od $10000$ čvorova, preporuka je koristiti vrijednost parametra reda veličine $10^2$. Ako je parametar prevelik, pretraga algoritma postaje pregruba, tj. algoritam previše skače u prostoru stanja. Na slici \ref{fig:gen_mut} pokazan je rad algoritma s različitim brojem mutacija nad jedinkom. Kao što se vidi na slici ako je mutacija relativno velika, algoritam brzo konvergira na početku, ali je problem što zastane u lokalnom minimumu, tj. algoritam je pregrub. Ako je parametar premalen, tada je konvergencija spora.

\textbf{Vjerojatnost mutacije gena pomoću lokalne pretrage} parametar je koji određuje učestalost korištenja lokalne vrste bojenja. Ponašanje je slično kao i kod drugih algoritama. Parametar bi trebao biti veći od $0.5$ kako bi se naglasak stavio na minimizaciju, ali s druge strane treba osigurati dovoljno veliko skakanje u prostoru stanja. Rezultati su prikazani na slici \ref{fig:gen_cs}.

\begin{table}[htb]
	\caption{Vrijeme izvođenja evolucijske strategije uz razne vrste bojanja -- Kansai-C}
	\label{tbl:es-cs1}
	\centering
	\begin{tabular}{|l||l|r|r|} \hline
	Lokalno bojanje & Globalno bojanje & Funkcija cilja & Vrijeme izvođenja (s)\\ \hline \hline
	ABW & RND & 63.8 & 37.168 \\ \hline 
	ABW & SWAP & 51.79 & 115.04 \\  \hline
	MC & RND & 276.35 & 187.2 \\ \hline
	MC & SWAP & 63.56 &  302.1 \\  \hline 
	MF & RND & 64.43 & 218.4 \\ \hline
	MF & SWAP & 51.34 & 306.39 \\ \hline
	\end{tabular}
\end{table}


\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/ga/mut/mut.png}
	\caption{Evolucijska strategija -- ovisnost o broju mutacija nad jedinkom -- Tokai-C}
	\label{fig:gen_mut}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/ga/cs/cs.png}
	\caption{Evolucijska strategija -- ovisnost o vjerojatnosti lokalnog bojanja -- Tokai-C}
	\label{fig:gen_cs}
\end{figure}


\clearpage

\section{Simulirano kaljenje}

Tablice \ref{tbl:sa-cs1}, \ref{tbl:sa-cs2}, \ref{tbl:sa-cs3} i \ref{tbl:sa-cs4} prikazuju kako različita bojanja utječu na krajnji rezultat (drugi parametri su konstantni). Najmanje vremena troši kombinacija \emph{ABW-RND}, ali isto tako daje najlošije rezultate. Najduže vrijeme izvođenja imaju kombinacije \emph{MC-SWAP} i \emph{MF-SWAP} što je i očekivano zbog implementacije. Gotovo nikad se ne isplati koristiti kao lokalno bojanje \emph{MC}, jer koristi dosta vremena, ali ne daje bolje rezultate. Kombinacija \emph{MF-SWAP} ima dobar učinak, ali troši i puno vremena. Globalna vrsta bojenja \emph{SWAP} daje bolje rezultate od \emph{RND} vrste bojenja, što pokazuje da se isplati provoditi \emph{tuneliranje}. Vrsta bojenja \emph{ABW} troši manje vremena od ostalih vrsta bojenja i daje relativno dobre rezultate. Kao optimalna kombinacija preporučuje se \emph{ABW-SWAP} jer vrijeme izvođenja je relativno malo, a dobivaju se dobri rezultati optimizacije.

\textbf{Početna temperatura} parametar je algoritma koji najviše ovisi o veličini i gustoći grafa. Što je graf kompleksniji, parametar mora biti veći. Osim toga parametar ovisi o konkretnim vrijednostima težina u grafu. Ovaj parametar teorijski se može izračunati, samo u ovoj optimizaciji problem su neuravnotežene težine bridova. Zato je teško odrediti pravu početnu vrijednost. Rezultati pokazuju da vrijednost početne temperature može biti manja od $1$ (za ispitne grafove). Važno je ne staviti preveliku vrijednost, jer tada algoritam može divergirati. Ako se koristi vrsta bojenja \emph{RND} tada je poželjno da taj parametar ima nešto manju vrijednost kako algoritam ne bi divergirao. Ovaj parametar je najvažniji za simulirano kaljenje, jer prevelika vrijednost može dovesti do divergencije kako je to prikazano na slici \ref{fig:sa_big_se}. Na slici \ref{fig:sa_se} prikazan je rad algoritma u ovisnosti različitih vrijednost početne temperature. Iako se razlike teško vide, u prosjeku postoji parametar koji daje bolje rezultate od ostalih. Najveći problem kod korištenja simuliranog kaljenja je uskladiti velike promijene u funkciji cilja (širok spektar vrijednosti bridova) i sprječavanje divergencije (velika početna temperatura). Posljedica ovog problema je što se simulirano kaljenje ponaša više kao slučajno pretraživanje (iako se može uočiti tipično ponašanje simuliranog kaljenja). Na kraju sama vrsta bojanja čvora utječe na poboljšavanje rješenja, a simulirano kaljenje omogućuje dodatnu dimenziju u prolasku kroz prostor stanja.

\textbf{Broj iteracija s istom temperaturom} je parametar koji određuje koliko susjednih rješenja će biti generirano s istom temperaturom. Algoritam nije jako osjetljiv na ovaj parametar, ali ne preporučuje se korištenje velike vrijednosti ($>500$) jer se povećanjem ovog parametra linearno povećava i vrijeme izvođenja algoritma. Preporučena vrijednost je $\sim 100$.

\textbf{Faktor smanjenja temperature} treba imati relativno veliku vrijednost u intervalu $\in[0,1]$. Potrebno je smanjivati temperaturu, ali istovremeno paziti da temperatura ne padne prebrzo. Parametar je vezan za ukupan broj iteracija. Parametar nema velik utjecaj ako se koristi kombinacija \emph{ABW-SWAP}, ali ako je parametar premalen gubi se glavno svojstvo simuliranog kaljenja.

\textbf{Vjerojatnost lokalne vrste bojanja} je parametar koji treba postaviti tako da se osigura dovoljan broj minimizacija, ali istovremeno da se omogući pretraživanje lošijih rješenja. Pokazuje se da parametar mora biti veći od $0.5$ i preporučuje se da bude manji od $0.9$. Slika \ref{fig:sa_cs} prikazuje ponašanje algoritma za različite vjerojatnosti odabira vrste bojenja. Ako je parametar prevelik ili premali tada dolazi do brze konvergencije na početku i do zapinjanja u lokalnom minimumu.


\begin{table}[htb]
	\caption{Vrijeme izvođenja simuliranog kaljenja uz razne vrste bojanja -- Tokai-A}
	\label{tbl:sa-cs1}
	\centering
	\begin{tabular}{|l||l|r|r|} \hline
	Lokalno bojanje & Globalno bojanje & Funkcija cilja & Vrijeme izvođenja (s)\\ \hline \hline
	ABW & RND & 2194.437 & 7.58 \\ \hline 
	ABW & SWAP & 1945.341 & 34.4 \\  \hline
	MC & RND & 2213.458 & 67.48 \\ \hline
	MC & SWAP & 2004.668 & 226.281 \\  \hline 
	MF & RND & 1923.029 & 93.192 \\ \hline
	MF & SWAP & 1823.024 & 134.927 \\ \hline
	\end{tabular}
\end{table}

\begin{table}[htb]
	\caption{Vrijeme izvođenja simuliranog kaljenja uz razne vrste bojanja -- Tokai-C}
	\label{tbl:sa-cs2}
	\centering
	\begin{tabular}{|l||l|r|r|} \hline
	Lokalno bojanje & Globalno bojanje & Funkcija cilja & Vrijeme izvođenja (s)\\ \hline \hline
	ABW & RND & 150.75 & 6.2 \\ \hline 
	ABW & SWAP & 90.0 & 24.6 \\  \hline
	MC & RND & 160.0 & 74.9 \\ \hline
	MC & SWAP & 90.0 & 107.278 \\  \hline 
	MF & RND & 112.26 & 91.6 \\ \hline
	MF & SWAP & 78.0 & 149.82 \\ \hline
	\end{tabular}
\end{table}

\begin{table}[htb]
	\caption{Vrijeme izvođenja simuliranog kaljenja uz razne vrste bojanja -- Kansai-A}
	\label{tbl:sa-cs3}
	\centering
	\begin{tabular}{|l||l|r|r|} \hline
	Lokalno bojanje & Globalno bojanje & Funkcija cilja & Vrijeme izvođenja (s)\\ \hline \hline
	ABW & RND & 6506.88 & 7.7 \\ \hline 
	ABW & SWAP & 5915.60 & 47.0 \\  \hline
	MC & RND & 6570.84 & 39.4 \\ \hline
	MC & SWAP & 5988.07 & 134.35 \\  \hline 
	MF & RND & 5579.18 & 70.1 \\ \hline
	MF & SWAP & 5082.61 & 117.24 \\ \hline
	\end{tabular}
\end{table}

\begin{table}[htb]
	\caption{Vrijeme izvođenja simuliranog kaljenja uz razne vrste bojanja -- Kansai-C}
	\label{tbl:sa-cs4}
	\centering
	\begin{tabular}{|l||l|r|r|} \hline
	Lokalno bojanje & Globalno bojanje & Funkcija cilja & Vrijeme izvođenja (s)\\ \hline \hline
	ABW & RND & 67.0 & 5.68 \\ \hline 
	ABW & SWAP & 50.81 & 36.2 \\  \hline
	MC & RND & 66.46 & 60.1 \\ \hline
	MC & SWAP & 58.99 &  90.15 \\  \hline 
	MF & RND & 60.34 & 79.07 \\ \hline
	MF & SWAP & 50.33 & 115.04 \\ \hline
	\end{tabular}
\end{table}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/sa/cs/cs.png}
	\caption{Simulirano kaljenje -- ponašanje simuliranog kaljenja u ovisnosti vjerojatnosti bojanja -- Kansai-C}
	\label{fig:sa_cs}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/sa/sa_big_se.png}
	\caption{Simulirano kaljenje -- početna temperatura prevelika -- Kansai-C}
	\label{fig:sa_big_se}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/sa/se/se.png}
	\caption{Simulirano kaljenje -- ovisnost algoritma o početnoj temperaturi -- Kansai-C}
	\label{fig:sa_se}
\end{figure}


\section{Genetsko kaljenje}

Genetsko kaljenje pokazalo je veoma loše rezultate. Često zapinje u lokalnim minimumima i potrebno je dosta iteracija da se rješenje izbaci iz te okoline. Iako se koristi i \emph{SWAP} vrsta bojenja (tuneliranje), algoritam pokazuje lošu konvergenciju naspram drugih algoritama. Genetsko kaljenje je populacijski algoritam i ima sličnih problema kao i evolucijska strategija s vremenom izvođenja. Ponašanje genetskog kaljenja prikazano je na slici \ref{fig:ge_normal}. Vidljivo je da se algoritam dugo zadržava u lokalnim minimumima i treba iskoristiti puno iteracija kako bi se iz njih izvukao.

\textbf{Ukupan broj iteracija} je parametar o kojem ovisi kvaliteta rješenja, isto kao i kod drugih algoritama.

\textbf{Broj jedinki} je parametar koji se teško određuje za velike probleme. Preporučuje se korištenje do vrijednosti $20$, jer veće vrijednosti ovog parametra jako utječu na vrijeme izvođenja algoritma.

\textbf{Početna energija} je kritičan parametar algoritma i ovisi o broju čvorova i gustoći grafa. Idealna vrijednost za ovaj parametar nije utvrđena, ali za veće vrijednosti, algoritam divergira.

\textbf{Faktor hlađenja} je parametar koji smanjuje energiju sustava i tako algoritam s vremenom teži k boljim rješenjima. Parametar treba imati veliku vrijednost kako energija sustava ne bi prebrzo pala na $0$.

\textbf{Vjerojatnost lokalne vrste bojanja} ponaša se slično kao i kod drugih algoritama. Treba težiti k lokalnoj vrsti bojenja, što znači da je idealan parametar veći od $0.5$.


\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/ge/ge_normal.png}
	\caption{Ponašanje genetskog kaljenja}
	\label{fig:ge_normal}
\end{figure}


\section{Usporedba metaheuristika}

Svaki algoritam pokreće se u trajanju $10$ min. Parametri algoritama empirijski su pronađeni, gdje se tražio najbolji rezultat funkcije cilja. Nakon što algoritam završi, proučavaju se dva podatka. Najvažniji je vrijednost funkcije cilja koje algoritam postiže, a drugi je broj utrošenih iteracija. Jedna iteracija je ovisna o tipu algoritma. Kod agentskog algoritma je to nakon što se svi agenti obrade. Kod simuliranog kaljenja to je generiranje novog rješenja, kod evolucijske strategije to je trenutak kada se u populaciji traži najbolje rješenje, što je isto kao i kod genetskog kaljenja.

Na slikama \ref{fig:tokai-A-alg}, \ref{fig:tokai-C-alg}, \ref{fig:kansai-A-alg} i \ref{fig:kansai-C-alg} nalaze se vrijednosti funkcije cilja za svaki algoritam. Simulirano kaljenje se pokazalo najbolje na ispitnim grafovima. Vidljivo je da ako je graf manji (relativno mali broj čvorova i bridova) tada su rezultati za algoritme podjednaki. Lošiji rezultati ostalih algoritama mogu se objasniti tablicom \ref{tbl:meta-iter}. Kao što se vidi, agentski algoritam i evolucijska strategija koriste manji broj iteracija (vremenski zahtjevniji). Genetsko kaljenje koristi velik broj iteracija, ali kao što sve vidi, parametre je teško postaviti. Genetsko kaljenje ponekad pokazuje i bolje rezultate od nekih algoritama, kao što je to prikazano na slici \ref{fig:tokai-C-alg}, ali to se događa samo na manjim grafovima. Evolucijska strategija bi mogla dati bolje rezultate, samo što pri korištenju populacije, vrijeme izvršavanja se naglo povećava (broj iteracija pada).

\begin{table}[htb]
	\caption{Broj iteracija algoritama}
	\label{tbl:meta-iter}
	\centering
	\begin{tabular}{|l||r|r|r||r|} \hline
	& Tokai-A	& Tokai-C	& Kansai-A & Kansai-C \\ \hline \hline
	Agentski algoritam	& 65 & 82	& 25 & 54 \\ \hline
	Simulirano kaljenje	& 613872	& 873840	& 1039262	& 1149619 \\ \hline
	Evolucijska strategija & 715 & 1209	& 739	& 1249 \\ \hline
	Genetsko kaljenje	& 20055	& 34388	& 20064	& 42320 \\ \hline
	\end{tabular}
\end{table}


\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/tokai-A.pdf}
	\caption{Tokai-A graf -- usporedba algoritama}
	\label{fig:tokai-A-alg}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/tokai-C.pdf}
	\caption{Tokai-C graf -- usporedba algoritama}
	\label{fig:tokai-C-alg}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/kansai-A.pdf}
	\caption{Kansai-A graf -- usporedba algoritama}
	\label{fig:kansai-A-alg}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/kansai-C.pdf}
	\caption{Kansai-C graf -- usporedba algoritama}
	\label{fig:kansai-C-alg}
\end{figure}


\section{Minimizacija postotka promijenjenih čvorova}

Umjesto korištenja višekriterijske optimizacije (sume težina konfliktnih bridova i postotka promjene početne boje) koristi se kombinacija algoritama. Prvo se pokreće algoritam koji koristi agresivne metode, tj. metode bojenja koje uopće ne paze na postotak promjene početne boje. Nakon toga za vrstu bojenja postavljaju se iste metode, ali koje preferiraju početnu boju. U ispitivanju koje je prikazano slikama \ref{fig:per_error}, \ref{fig:per_parent} i \ref{fig:per_per}, korišteno je simulirano kaljenje s vrstama bojenja \emph{ABW} kao lokalno i \emph{SWAP} kao globalno bojenje. Ukupno je izvršeno $100000$ iteracija nad \emph{Tokai-C} grafom. Nakon izvršenja pola iteracija tj. $50000$ pokrenuto je simulirano kaljenje s metodama koje preferiraju početnu boju. Rezultat je veoma zanimljiv, jer iz grafa koji prikazuje ovisnost funkcije cilja o broju iteracija nije moguće vizualno odrediti u kojem trenutku je pokrenut drugi algoritam. Ako se promatra ovisnost postotka promjene početne boje i funkcije cilja, može se uočiti veliki pad postotka pri vrijednosti oko $120$. Algoritam je došao do te vrijednosti baš pri promjeni algoritama. Posebno je zanimljiv graf koji prikazuje ovisnost postotka o broju iteracija. Prvi agresivni algoritam prvo postupno povećava postotak promjena do neke vrijednosti s time da asimptota prolazi kroz vrijednost $100\%$. Nakon što se pokrene drugi algoritam, postotak promjena počinje naglo padati, ali što je još važnije funkcija cilja također pada. Ovakav pristup pokazao se vrlo dobrom strategijom upravljanja postotkom promjene početne boje.

U praksi, pri implementaciji algoritma, preporučuje se korištenje agresivnih metoda do nekog kritičnog trenutka. Kritičan trenutak može se odrediti kao trenutak u kojem je vrijednost funkcije cilja dovoljno mala, a preostalo vrijeme koje algoritam može koristiti je dovoljno veliko da algoritam spusti vrijednost postotka promijenjenih čvorova. Kako postotak veoma brzo pada, preporučuje se korištenje blagih metoda na tri četvrtine vremena izvođenja agresivnih metoda.

Na slikama \ref{fig:per_error}, \ref{fig:per_parent} i \ref{fig:per_per} nalazi se ispitivanje kombinacije algoritma koji koristi obične vrste bojanja (agresivne metode) i metode koje pokušavaju sačuvati početnu boju čvora. Ova metoda ne jamči sa sigurnošću da će postotak biti manji od $66\%$ (kako to definicija problema zahtijeva), ali kako pokazuje dobre rezultate u minimizaciji, na kraju je potrebno provjeriti da li je postotak zadovoljen. Ako postotak nije zadovoljen, tada je potrebno prisilno na čvorove koji daju najmanju grešku postaviti početnu boju.

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/per_error.png}
  \caption{Ovisnost funkcije cilja o iteracijama}
  \label{fig:per_error}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/per_parent.png}
  \caption{Ovisnost postotka promjene početne boje o funkciji cilja}
	\label{fig:per_parent}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/per_per.png}
	\caption{Ovisnost postotka promjene o broju iteracija}
	\label{fig:per_per}
\end{figure}


\section{Metode strojnog učenja za odabir pohlepnog algoritma}

U poglavlju \ref{sec:ml} opisan je način generiranja značajki iz različitih grafova. Za generiranje rezultata koriste se dva programska alata: \emph{RapidMiner} i \emph{Eureqa}. \emph{RapidMiner} je programski alat koji nudi mnogobrojne metode strojnog učenja uz dodatne mogućnosti parsiranja datoteka i sl. U ovom poglavlju taj alat se koristi kako bi se nad podacima iz grafa provela regresija i kako bi se iz generiranih izraza moglo iščitati znanje o tim podacima. Alat \emph{Eureqa} je alat koji koristi metode simboličke regresije. Simbolička regresija vrsta je regresije gdje model nije unaprijed zadan, već se pomoću genetskog programiranja i sl. metoda generiraju funkcije. U ovom poglavlju alat \emph{Eureqa} prikazuje se kao moguća metoda za dobivanje znanja i pokazuje se primjer izvođenja.

Kao obična regresija koristi se model polinoma drugog stupnja. Ovakav model izabran je iz nekoliko razloga. Kada bi se koristio linearan model, tada bi se informacije iz dobivenog polinoma mogle iščitati samo iz koeficijenata. Polinomi višeg stupnja unose previše parametara i previše mogućnosti za interpretaciju podataka. Polinom drugog stupnja nudi mogućnost potiskivanja parametara jer ako parametar koji je u intervalu od $0$ do $1$ ima potenciju $2$, a neki drugi parametar potenciju $1$, tada veći utjecaj ima parametar s manjom potencijom. Ako pak postoje parametri s istom potencijom, tada koeficijenti određuju koji parametar ima veći utjecaj.

Kako je u središtu ovog istraživanja čvor, tada nije bitno koliko graf sadrži čvorova, već koliko je graf gust (koliko ima bridova). Zbog toga se koriste grafovi s manjim brojem čvorova (kako bi generiranja rezultata oduzelo manje vremena). Za svaki graf i svako bojanje pohlepni algoritam pokreće se $2000$ puta. Od $2000$ rezultata uzima se $10\%$ najboljih. Iz takvih podataka uzimaju se svi čvorovi koji su obojivi sa svojim parametrima -- jedan čvor u jednom pohlepnom algoritmu predstavlja jedan uzorak.

Model regresije:
\begin{equation}
	f(\textup{COL, FIT, LDO, SDO}) = a\cdot \textup{COL}^{k_1} + b\cdot \textup{FIT}^{k_2} + c\cdot \textup{LDO}^{k_3} + d\cdot \textup{SDO}^{k_4} + e
\end{equation}

Velikim troslovnim oznakama označene su metode sortiranja, malim slovima označeni su koeficijenti koje je potrebno naučiti, te oznakama $k_i$ označene su potencije, gdje je $k_i \in \left \{ 1, 2 \right \} $.
Dobiveni rezultati prikazani su u tablicama \ref{tbl:regresija-ABW}, \ref{tbl:regresija-MC} i \ref{tbl:regresija-MF}. Za svaki parametar prikazana su dva broja. Broj koji je u zagradi je potencija za parametar, a broj desno od njega je vrijednost koeficijenta.


\begin{table}[htb]
	\caption{Regresija nad grafovima -- ABW vrsta bojanja}
	\label{tbl:regresija-ABW}
	\centering
	\begin{tabular}{|l|r|r|r|r|r|} \hline
	Naziv grafa & COL & FIT & LDO & SDO & $e$ \\ \hline \hline
graph\_500\_0.1 & $ -0.196\; (2) $ & $ 0.005\; (2) $ & $ -0.279\; (2) $ & $ 0.230\; (1) $ & $ 0.478 $\\ \hline
graph\_500\_0.3 & $ 0.078\; (2) $ & $ -0.099\; (2) $ & $ 0.526\; (1) $ & $ -0.851\; (1) $ & $ 0.764 $\\ \hline
graph\_500\_0.5 & $ 0.009\; (1) $ & $ 0.126\; (2) $ & $ 0.205\; (2) $ & $ -0.246\; (1) $ & $ 0.570 $\\ \hline
graph\_500\_0.7 & $ 0.031\; (2) $ & $ 0.103\; (1) $ & $ 2.205\; (1) $ & $ -3.077\; (1) $ & $ 1.381 $\\ \hline
graph\_500\_0.9 & $ 0.206\; (2) $ & $ 0.100\; (2) $ & $ 16.834\; (1) $ & $ -28.285\; (1) $ & $ 11.872 $\\ \hline
graph\_700\_0.1 & $ 0.036\; (2) $ & $ 0.041\; (2) $ & $ 0.441\; (2) $ & $ -0.656\; (1) $ & $ 0.737 $\\ \hline
graph\_700\_0.3 & $ 0.221\; (2) $ & $ 0.148\; (2) $ & $ 0.204\; (2) $ & $ -0.261\; (1) $ & $ 0.574 $\\ \hline
graph\_700\_0.5 & $ 0.135\; (2) $ & $ -0.238\; (2) $ & $ 0.688\; (1) $ & $ -1.102\; (1) $ & $ 0.882 $\\ \hline
graph\_700\_0.7 & $ 0.030\; (2) $ & $ -0.239\; (1) $ & $ 2.803\; (2) $ & $ -8.294\; (1) $ & $ 6.011 $\\ \hline
graph\_700\_0.9 & $ 0.218\; (2) $ & $ 0.004\; (2) $ & $ 16.080\; (1) $ & $ -31.888\; (1) $ & $ 16.203 $\\ \hline
graph\_900\_0.1 & $ 0.043\; (2) $ & $ 0.120\; (2) $ & $ 0.632\; (2) $ & $ -0.825\; (1) $ & $ 0.757 $\\ \hline
graph\_900\_0.3 & $ -0.027\; (1) $ & $ 0.032\; (2) $ & $ -0.376\; (2) $ & $ 0.795\; (1) $ & $ 0.079 $\\ \hline
graph\_900\_0.5 & $ 0.012\; (2) $ & $ -0.047\; (2) $ & $ 0.766\; (2) $ & $ -1.964\; (1) $ & $ 1.713 $\\ \hline
graph\_900\_0.7 & $ 0.030\; (2) $ & $ -0.239\; (1) $ & $ 2.803\; (2) $ & $ -8.294\; (1) $ & $ 6.011 $\\ \hline
graph\_900\_0.9 & $ 0.143\; (2) $ & $ -0.126\; (2) $ & $ 18.861\; (1) $ & $ -49.868\; (1) $ & $ 31.369 $\\ \hline
	\end{tabular}
\end{table} 

\begin{table}[htb]
	\caption{Regresija nad grafovima -- MC vrsta bojanja}
	\label{tbl:regresija-MC}
	\centering
	\begin{tabular}{|l|r|r|r|r|r|} \hline
	Naziv grafa & COL & FIT & LDO & SDO & $e$ \\ \hline \hline
graph\_500\_0.1 & $ 0.104\; (2) $ & $ -0.105\; (2) $ & $ 0.307\; (2) $ & $ -0.460\; (1) $ & $ 0.653 $\\ \hline
graph\_500\_0.3 & $ 0.234\; (2) $ & $ 0.086\; (2) $ & $ -1.001\; (1) $ & $ 1.036\; (1) $ & $ 0.435 $\\ \hline
graph\_500\_0.5 & $ 0.039\; (1) $ & $ 0.018\; (2) $ & $ 1.177\; (1) $ & $ -1.547\; (1) $ & $ 0.857 $\\ \hline
graph\_500\_0.7 & $ -0.047\; (1) $ & $ 0.283\; (2) $ & $ 2.597\; (1) $ & $ -3.913\; (1) $ & $ 1.811 $\\ \hline
graph\_500\_0.9 & $ 0.319\; (2) $ & $ 0.013\; (2) $ & $ 17.227\; (1) $ & $ -28.663\; (1) $ & $ 11.839 $\\ \hline
graph\_700\_0.1 & $ -0.069\; (2) $ & $ 0.439\; (1) $ & $ -0.385\; (2) $ & $ 0.497\; (1) $ & $ 0.343 $\\ \hline
graph\_700\_0.3 & $ -0.010\; (1) $ & $ -0.188\; (2) $ & $ -0.219\; (2) $ & $ 0.536\; (1) $ & $ 0.213 $\\ \hline
graph\_700\_0.5 & $ -0.084\; (1) $ & $ 0.125\; (2) $ & $ 0.634\; (1) $ & $ -0.935\; (1) $ & $ 0.801 $\\ \hline
graph\_700\_0.7 & $ -0.269\; (2) $ & $ 0.091\; (1) $ & $ 2.175\; (2) $ & $ -6.504\; (1) $ & $ 4.853 $\\ \hline
graph\_700\_0.9 & $ 0.074\; (2) $ & $ -0.071\; (2) $ & $ 16.715\; (1) $ & $ -32.657\; (1) $ & $ 16.363 $\\ \hline
graph\_900\_0.1 & $ 0.079\; (2) $ & $ -0.246\; (2) $ & $ -0.525\; (2) $ & $ 0.593\; (1) $ & $ 0.337 $\\ \hline
graph\_900\_0.3 & $ -0.055\; (2) $ & $ -0.158\; (2) $ & $ -0.097\; (2) $ & $ 0.191\; (1) $ & $ 0.412 $\\ \hline
graph\_900\_0.5 & $ 0.046\; (2) $ & $ 0.114\; (2) $ & $ 0.172\; (2) $ & $ -0.452\; (1) $ & $ 0.772 $\\ \hline
graph\_900\_0.7 & $ 0.010\; (2) $ & $ 0.144\; (2) $ & $ 3.253\; (2) $ & $ -11.790\; (1) $ & $ 8.905 $\\ \hline
graph\_900\_0.9 & $ 0.032\; (2) $ & $ -0.060\; (2) $ & $ 19.066\; (1) $ & $ -50.029\; (1) $ & $ 31.339 $\\ \hline
	\end{tabular}
\end{table} 

\begin{table}[htb]
	\caption{Regresija nad grafovima -- MF vrsta bojanja}
	\label{tbl:regresija-MF}
	\centering
	\begin{tabular}{|l|r|r|r|r|r|} \hline
	Naziv grafa & COL & FIT & LDO & SDO & $e$ \\ \hline \hline
graph\_500\_0.1 & $ 0.023\; (1) $ & $ 0.347\; (2) $ & $ -0.201\; (2) $ & $ 0.118\; (1) $ & $ 0.504 $\\ \hline
graph\_500\_0.3 & $ -0.188\; (2) $ & $ -0.154\; (1) $ & $ 0.025\; (1) $ & $ 0.001\; (1) $ & $ 0.487 $\\ \hline
graph\_500\_0.5 & $ -0.009\; (1) $ & $ 0.044\; (2) $ & $ 0.125\; (1) $ & $ -0.257\; (1) $ & $ 0.619 $\\ \hline
graph\_500\_0.7 & $ 0.037\; (2) $ & $ -0.222\; (2) $ & $ 1.631\; (1) $ & $ -2.488\; (1) $ & $ 1.352 $\\ \hline
graph\_500\_0.9 & $ 0.111\; (2) $ & $ 0.451\; (2) $ & $ 16.637\; (1) $ & $ -28.226\; (1) $ & $ 12.003 $\\ \hline
graph\_700\_0.1 & $ 0.039\; (2) $ & $ -0.256\; (1) $ & $ -0.071\; (2) $ & $ 0.031\; (1) $ & $ 0.511 $\\ \hline
graph\_700\_0.3 & $ 0.041\; (1) $ & $ 0.165\; (2) $ & $ -0.136\; (1) $ & $ -0.060\; (1) $ & $ 0.638 $\\ \hline
graph\_700\_0.5 & $ -0.017\; (1) $ & $ -0.108\; (1) $ & $ 0.256\; (2) $ & $ -0.574\; (1) $ & $ 0.829 $\\ \hline
graph\_700\_0.7 & $ -0.062\; (2) $ & $ 0.070\; (2) $ & $ 2.352\; (2) $ & $ -6.515\; (1) $ & $ 4.711 $\\ \hline
graph\_700\_0.9 & $ 0.186\; (2) $ & $ 0.272\; (2) $ & $ 15.036\; (1) $ & $ -31.817\; (1) $ & $ 17.135 $\\ \hline
graph\_900\_0.1 & $ -0.039\; (2) $ & $ 0.146\; (2) $ & $ 0.180\; (2) $ & $ -0.242\; (1) $ & $ 0.580 $\\ \hline
graph\_900\_0.3 & $ 0.067\; (1) $ & $ 0.103\; (2) $ & $ -0.164\; (2) $ & $ 0.524\; (1) $ & $ 0.180 $\\ \hline
graph\_900\_0.5 & $ -0.007\; (2) $ & $ 0.004\; (2) $ & $ 0.436\; (2) $ & $ -1.157\; (1) $ & $ 1.223 $\\ \hline
graph\_900\_0.7 & $ 0.032\; (1) $ & $ -0.018\; (2) $ & $ 5.044\; (1) $ & $ -10.473\; (1) $ & $ 5.769 $\\ \hline
graph\_900\_0.9 & $ 0.190\; (2) $ & $ -0.093\; (2) $ & $ 18.498\; (1) $ & $ -49.369\; (1) $ & $ 31.216 $\\ \hline
	\end{tabular}
\end{table} 

Može se očekivati da funkcija usporedbe pri sortiranju čvorova nije jednostavna tj. da nije polinom. Zato se ideja proširuje na simboličku regresiju. Ovo ispitivanje je ilustrativno i prikazuje dodatnu mogućnost pri istraživanju sortiranja čvorova. Graf za ispitivanje je "\emph{graph\_700\_0.5}". Odabrana je vrsta bojanja \emph{ABW}. Skup elementarnih operatora i funkcija:

\begin{itemize}
	\item $c$  konstanta
	\item $+$ operator zbrajanja
	\item $-$ operator oduzimanja
	\item $\cdot $ operator množenja
	\item $/$ operator dijeljenja
	\item $sin$
	\item $cos$
	\item $e^x$
	\item $ln$ 
	\item logistička funkcija
\end{itemize} 

U tablici \ref{tbl:sym-reg} su prikazana dva rješenja koja su se pojavila. Prvo rješenja je jednostavnije, ali ima veću empirijsku pogrešku. Za drugo rješenje vrijedi obrnuto.

\begin{table}[htb]
	\caption{Simbolička regresija nad grafom}
	\label{tbl:sym-reg}
	\centering
	\begin{tabular}{|l|r|} \hline
	Izraz & Empirijska pogreška (MSE)\\ \hline \hline
	$f = 0.348/SDO + 4.756\cdot COL \cdot SDO - 4.178\cdot COL$ & 0.085474763\\ \hline
	$f = \textup{logistic}(0.637\cdot cos(112.588/SDO) - 0.057 - FIT)$ & 0.07911826 \\ \hline
	\end{tabular}
\end{table}

Pri interpretaciji ovog rezultata treba biti veoma oprezan. Podaci sigurno pokazuju određeno ponašanje algoritama, ali njihov krajnji cilj, a to je dobivanje metode za sortiranje, ne treba uzimati kao gotovo rješenje. Kvaliteta rješenja ovisi o broju pokretanja algoritma i broju čvorova za učenje. Teorijski broj pokretanja algoritama bi trebao biti $V(G)!$ tako da se pokriju sva moguća sortiranja i onda iz najboljih izvući čvorove. Ovo je u praksi nemoguće jer je broj čvorova relativno velik broj. Drugi problem vezan je za broj čvorova tj. broj uzoraka. U tablicama \ref{tbl:regresija-ABW}, \ref{tbl:regresija-MC} i \ref{tbl:regresija-MF} prikazani su dobiveni rezultati za neke grafove. Za \emph{ABW} vrstu bojenja vidljivo je da najveći utjecaj ima \emph{SDO} vrsta sortiranja, jer su sve potencije u stupcu \emph{SDO} jednake $1$ (za razliku od drugih stupaca). Kod nekih grafova usporedno se pojavljuje i relativno velik koeficijent, što znači da i \emph{LDO} utječe na krajnji rezultat pohlepnog algoritma. Ostala svojstva, kao što je vidljivo u tablici \ref{tbl:regresija-ABW}, mogu se zanemariti. Ovo je veoma sličan rezultat kao u članku \cite{lit7}, gdje je isproban algoritam koji kao prvo svojstvo sortiranja koristi \emph{SDO}, a kao drugo \emph{LDO}.

Za \emph{MC} vrstu bojenja, \emph{SDO} način sortiranja je također dominantan, \emph{LDO} ima malo veći utjecaj, a moguće je da za neke grafove i \emph{FIT} daje dodatan doprinos (za graf "\emph{graph\_700\_0.1}"). Za \emph{MF} vrstu bojanja rezultati su nešto zanimljivi. Za manje gušće grafove kao dominantno svojstvo pojavljuje se \emph{FIT} sortiranje. U drugim slučajevima \emph{SDO} ostaje kao dominantno svojstvo.

U većini slučajeva (za sve vrste bojenja) \emph{SDO} i \emph{LDO} su dominantna svojstva. Razlog može biti u tome što su kolizija (\emph{COL}) i greška čvora (\emph{FIT}) parametri koji se minimiziraju, pa su te vrijednosti često jednake $0$ i zbog toga gube utjecaj u provođenju regresije.

U tablici \ref{tbl:sym-reg} prikazana su dva rezultata provođenja simboličke regresije. Pri korištenju simboličke regresije treba biti oprezan jer rezultati na kraju ponekad mogu biti teški za tumačenje. Ako promatramo prvi red u tablici, vidimo jednostavan zapis formule koji se može donekle tumačiti. U drugom redu nalazi se malo kompliciranija funkcija koja i nema previše smisla. Na primjer, teško je protumačiti što točno znači funkcija kosinus. Što je funkcija kompliciranija to se dobiva manja empirijska pogreška. Zbog toga se može dogoditi da se funkcija generirala na temelju šuma što nije dobro za generalizaciju. Ovim rezultatima želi se pokazati kako je istraživanje ovog područja moguće ostvariti na relativno jednostavan način pomoću dostupnih alata.


\section{Ispitivanje nad \emph{DIMACS} bazom grafova}

Za klasičan problem bojanja grafova, kao referenca pri ispitivanju učinkovitosti algoritma koriste se poznati grafovi, najčešće iz \emph{DIMACS} baze. Kako u ovom radu već postoji programsko prilagodljivo rješenje, ispituju se neki grafovi iz navedene baze. U klasičnom problemu grafovi nisu težinski, pa sve metode pohlepnog pristupa nije moguće koristiti. Odlučeno je da se ispitivanje provodi nad simuliranim kaljenjem jer je algoritam pokazao najbolje rezultate za težinske grafove. Naziv grafova nalazi se u tablici \ref{tbl:dimacs}.

\begin{table}[htb]
	\caption{Popis DIMACS grafova}
	\label{tbl:dimacs}
	\centering
	\begin{tabular}{|l||r|r|r|} \hline
	Naziv grafa & $\chi$ - kromatski broj & Broj čvorova & Broj bridova\\ \hline \hline
	dsjr500.1c.col & 84 & 500 & 121275 \\ \hline 
	le450\_25c.col & 25 & 450 & 17343 \\  \hline
	r1000.5.col & 234 & 1000 & 238267 \\ \hline
	dsjr500.5.col & 122 & 500 & 58862 \\  \hline 
	le450\_25d.col & 25 & 450 & 17425 \\ \hline
	r250.5.col & 65 & 250 & 14849 \\ \hline
	\end{tabular}
\end{table}

Za svaki graf pokreće se simulirano kaljenje u kombinaciji s pohlepnim algoritmom. Prvo se pokreće pohlepni algoritam s parametrima \emph{SDO} za sortiranje i \emph{MC} za bojanje grafova. Zatim se pokreće simulirano kaljenje, nakon čega se provodi \emph{tuneliranje} i zatim opet simulirano kaljenje. Traži se prvi broj boja $k$ s kojima se graf može legalno obojiti. Kako je poznati kromatski broj, može se utvrditi efikasnost algoritma. Na kraju se za svaki graf pokreće simulirano kaljenje koje koristi najviše $\chi$ boja i utvrđuje se razlika. U tablici \ref{tbl:dimacs-sa} prikazani su grafovi, njihovi kromatski brojevi i minimalni kromatski broj pronađen pomoću simuliranog kaljenja. Uz to nalazi se broj konfliktnih bridova nakon optimizacije koja koristi točno kromatski broj za ispitivanje $k$-legalnog bojanja (uzima se median).

\begin{table}[htb]
	\caption{Bojenje DIMACS grafova pomoću simuliranog kaljenja}
	\label{tbl:dimacs-sa}
	\centering
	\begin{tabular}{|l||r|r|r|} \hline
	Naziv grafa & $\chi$ - kromatski broj & Minimalno $k$-bojanje & Broj konfliktnih bridova \\ \hline \hline
	dsjr500.1c.col & 84 & 87 & 3 \\ \hline 
	le450\_25c.col & 25 & 28 & 20 \\  \hline
	r1000.5.col & 234 & 266 & 36 \\ \hline
	dsjr500.5.col & 122 & 133 & 11 \\  \hline 
	le450\_25d.col & 25 & 28 & 20 \\ \hline
	r250.5.col & 65 & 69 & 4 \\ \hline
	\end{tabular}
\end{table}

U tablici \ref{tbl:dimacs-sa-time} prikazana su vremena izvođenja simuliranog kaljenja s istim parametrima za različite grafove. Uzima se srednje vrijeme izvođenja.

\begin{table}[htb]
	\caption{Bojenje DIMACS -- vremena izvođenja za kromatski broj i minimalno $k$-legalno bojenje}
	\label{tbl:dimacs-sa-time}
	\centering
	\begin{tabular}{|l||r|r|} \hline
	Naziv grafa & Vrijeme za kromatski broj (s) & Vrijeme za $k$-legalno bojanje (s) \\ \hline \hline
	dsjr500.1c.col & 74.0916 & 75.811 \\ \hline 
	le450\_25c.col & 8.187 & 8.9182 \\  \hline
	r1000.5.col & 181.67 & 206.095 \\ \hline
	dsjr500.5.col & 44.239 & 47.276  \\  \hline 
	le450\_25d.col &  8.187 & 8.422  \\ \hline
	r250.5.col & 17.3896 & 17.6512 \\ \hline
	\end{tabular}
\end{table}

Na slikama \ref{fig:r250.5}, \ref{fig:r1000.5}, \ref{fig:dsjr500.1c}, \ref{fig:le450_25c} i \ref{fig:le450_25d} prikazana su ponašanja algoritma za neke grafove.

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/test_65_all.png}
	\caption{Graf r250.5 -- korištenje $65$, $67$ i $69$ boja sa simuliranim kaljenjem}
	\label{fig:r250.5}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/test234_all.png}
	\caption{Graf r1000.5 -- korištenje $234$, $266$ i $270$ boja sa simuliranim kaljenjem}
	\label{fig:r1000.5}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/test_84_all.png}
	\caption{Graf dsjr500.1c -- korištenje $84$, $85$ i $86$ i $87$ boja sa simuliranim kaljenjem}
	\label{fig:dsjr500.1c}
\end{figure}


\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/test_25c.png}
	\caption{Graf le450\_25c -- korištenje $25$, $26$, $27$ i $28$ boja sa simuliranim kaljenjem}
	\label{fig:le450_25c}
\end{figure}

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{Slike/test_25d.png}
	\caption{Graf le450\_25d -- korištenje $25$, $26$, $27$ i $28$ boja sa simuliranim kaljenjem}
	\label{fig:le450_25d}
\end{figure}


Cilj je ispitivanja algoritma nad \emph{DIMACS} bazom pokazati kako se algoritmi mogu koristiti i za rješavanje klasičnog problema bojenja grafova. Rezultati pokazuju kako je mali postotak bridova na kraju konfliktan (ako se koristi minimalan broj boja). Rezultati heuristika koje se koriste za klasičan problem daju bolje rezultate nego pokazani algoritam u ovom radu, ali to je i očekivano, jer nije puno vremena utrošeno na dobivanje idealnih parametara za klasičan problem. Slike \ref{fig:r250.5} i \ref{fig:r250.5} prikazuje kako je simulirano kaljenje u kombinaciji s pohlepnim algoritmom vrlo agresivna metoda za postizanje minimalne kolizije na samom početku. U sredini izvršavanja algoritma radi se metoda \emph{tuneliranja}, što se može zamijetiti na rezultatima jer se često nakon toga kolizija smanji. Da bi se rezultati poboljšali potrebno je za svaki graf namjestiti idealne parametre. Osim toga bilo bi poželjno razviti determinističke metode koje rješavaju konfliktne bridove na kraju izvršavanja metaheuristika, jer kao što se iz rezultata vidi takvih bridova na kraju izvršavanja nema puno. Vremena izvršavanja ovise o veličini grafa, tj. o njegovoj gustoći. Vidljivo je da kada se koristi više boja, vrijeme izvršavanja je veće, što se može objasniti implementacijom metoda za odabir boja.


\chapter{Zaključak}

U ovom radu prikazana je mogućnost rješavanja optimizacijskog problema bojanja težinskih grafova pomoću metaheurističkih postupaka. Pokazalo se da metaheuristike mogu efikasno rješavati zadani problem. Najvažnije svojstvo je korištenje kombinacije pohlepnog algoritma i metaheuristika. Pohlepni algoritmi mogu dovesti rješenje u dovoljno dobro, ali zato metaheuristike mogu takvo rješenje poboljšati. Nakon izvršavanja metaheuristika ostaje mali broj konfliktnih bridova. Metode pokazuju da mogu rješavati i klasičan problem bojanja grafova, što daje dodatnu motivaciju za nastavak istraživanja problema.

Glavna stavka rada s metaheuristikama je pogađanje dobrih parametara. Pokazuje se da su ključni samo neki parametri u radu metaheuristika. Najveća ovisnost parametara je s gustoćom grafa. Važno je koristiti vrste bojanja koje minimiziraju lokalnu pogrešku i koje mogu pretraživati veći prostor stanja. Ako postoje dvije vrste bojanja čvorova čiji se rezultati ne razlikuju za red veličine, tada treba koristiti onu koja koristi manje vremena.

Kako pohlepni algoritam ima važnu ulogu, važno je istražiti da li postoji neko sortiranje čvorova koje koristi kombinaciju svojstava čvorova. Rezultati su pokazali kako je dominantno svojstvo \emph{SDO} i u većini slučajeva potiskuje druga svojstva. Istraživanje ovog područja ne bi trebalo završiti na tome, već bi trebalo probati povećati skup za učenje i izvršiti isprobane metode na boljim procesorskim sustavima. Kao nastavak rada na ovom problemu, predlaže se paralelno korištenje računala, gdje svako računalo izvršava po jedan algoritam (s različitim parametrima), te kombinirati dobivena rješenja. 

\bibliography{literatura}

\bibliographystyle{fer}
%\bibliographystyle{ieeetr}

\begin{sazetak}

U radu se proučava inačica problema bojanja težinskih grafova, gdje je cilj minimizirati sumu težina konfliktnih bridova. Problem je primjenjiv u domeni telekomunikacija gdje se žele raspodijeliti k\^{o}dovi po mobilnoj mreži. Problem se obrađuje teorijski i praktično. U teorijskom dijelu detaljno se analizira problem i određuju granice njegove rješivosti na računalu. U radu se primjenjuju različiti metaheuristički postupci. Pomoću metoda regresija pokušavaju se pronaći optimalna svojstva grafova, kako bi konvergencija bila što bolja. Na kraju su prikazani rezultati i zaključci.

\kljucnerijeci{bojanje grafova, metaheuristika, strojno učenje, regresija, simulirano kaljenje, evolucijska strategija, genetsko kaljenje, agentski algoritam}
\end{sazetak}

% TODO: Navedite naslov na engleskom jeziku.
\engtitle{Graph coloring with adaptive metaheuristics}
\begin{abstract}

In this work we study one instance of the weight graph coloring problem. The goal is to minimize the weighted sum of conflict edges. Problem can be applied in telecommunication domain, where the goal is to set codes in a mobile network. Problem can be observed as a theoretical problem and also as a practical problem. We study the problem in detail in the theoretical part and we determine the borders of the problem in computability theory. In this work we apply different metaheuristics algorithms. With regression methods we try to find the optimal graph properties for better convergention of algorithms. On the end of this work we show results and give a conclusions.

\keywords{graph coloring, metaheuristics, machine learning, regression,  simulated annealing, evolution strategy, genetic annealing, agent algorithm}

\end{abstract}

\end{document}

