\documentclass[times, utf8, diplomski, numeric]{fer}
\usepackage{booktabs, url, hyperref}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

%dodatak za programski kod
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\small\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2
}
\renewcommand\lstlistingname{Algoritam}
%kraj dodatka za programski kod

\hypersetup{
   colorlinks,
   citecolor=black,
   filecolor=black,
   linkcolor=black,
   urlcolor=black
}


\newtheorem{definition}{Definicija}
\newtheorem{theorem}{Teorem}


\begin{document}

% TODO: Navedite broj rada.
\thesisnumber{656}

% TODO: Navedite naslov rada.
\title{Bojanje grafova prilagodljivim metaheurističkim postupcima}

% TODO: Navedite vaše ime i prezime.
\author{Dino Šantl}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
\izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}
Uvod rada. Nakon uvoda dolaze poglavlja u kojima se obrađuje tema.

\section{Sažetci korištenih znanstvenih članaka}

\chapter{Formalni opis problema}

U ovom poglavlju opisuje se problem bojanja grafova i njegova primjena u telekomunikacijskom problemu koji se rješava. Najprije se predstavlja problem u telekomunikacijama uz pretpostavke i ograničenja. Zatim se isti problem opisuje pomoću matematičkog modela tj. problema bojanja grafova. Prvo se objašnjava općeniti problem bojanja grafova, a zatim se matematički model prilagodi konkretnom problemu.

\section{Tehnički opis problema}

Za shvaćanje problema dovoljno je pretpostaviti da postoji korisnikova oprema (što je najčešće mobilni uređaj) i bazna stanica. Bazne stanice geografski su statične, za razliku od mobilnih uređaja.
Ono što se u ovom radu naziva baznom stanizom je radio pristupna mreža \engl{Radio Access Network} (\emph{RAN}). \emph{RAN} dio je telekomunikacijskog sustava i nalazi se između opreme korisnika i jezgre mreže. To je sloj u mreži koji je zaslužan za prenošenje komunikacije između mobilnog uređaja do antene i od antene do drugog mobilnog uređaja. 

Za što kvalitetnji rad mreže potrebno je optimirati parametre \emph{RAN}-a. Jedan od parametra je \emph{scrambling} k\^{o}d. \emph{Scrambling} k\^{o}d međuostalim služi kako bi mobilni uređaj mogao razlikovati bazne stanice. Zbog toga je potrebno svakoj baznoj stanici pridružiti različit k\^{o}d. Problem je u tome što je dostupno samo 512 različitih kodova. To znači da neke bazne stanice moraju imati isti k\^{o}d (ako se u sustavu nalazi više od 512 baznih stanica). Ako neke dvije bazne stanice imaju isti k\^{o}d i mobilni uređaj se nalazi u dosegu signala od obje stanice, tada ne zna s kojom baznom stanicom komunicira te pada kvaliteta usluge.

Potrebno je dodjeliti \emph{scrambling} k\^{o}dove tako da dvije bazne stanice koje mogu biti istovremeno vezane za jedan mobilni uređaj nemaju isti k\^{o}d ili ako je to nemoguće smanjiti, dodjeliti k\^{o}dove tako da je negativan utjecaj na kvalitetu usluge što manji. Postoje još neka tehnička ograničenja koja je potrebno uvažiti, a biti će navedena u nastavku.

Iako postoji 512 različitih k\^{o}dova, svaka bazna stanica ima ograničen skup k\^{o}dova koje može koristiti. Dakle, za svaku baznu stanicu zadan je skup k\^{o}dova. Za neke bazne stanice postoji svojstvo nepromjenjivost, što znači da k\^{o}d koji je trenutno zadan za tu baznu stanicu mora ostati takav. Takve se vrste baznih stanica nazivaju \textbf{nepromjenjivima}. Početno stanje mreže definirano je k\^{o}dovima koji su pridjeljeni nekoj baznoj stanici. Osim toga za svaku baznu stanicu poznata je njezina vrsta. Vrsta može biti označena sa slovima: \emph{A, B ili C}. Bazne stanice različitih vrsta ne utjeću jedna na drugu.

\subsection{Ulazni i izlazni podaci}

Kao ulaz algoritam dobije inicjalno stanje mreže. Odnosno za svaku baznu stanicu poznat je trenutni k\^{o}d koji koristi i sva pravila koja moraju biti zadana. Izlaz algoritma je popis oznaka baznih stanica i za svaku od oznaka pripadajući k\^{o}d.

\subsubsection{Ulazni podaci}

\begin{enumerate}
	\item Popis i definicija domene boja (skupova boja)
	\item Popis čvorova (baznih stanica)
		\begin{enumerate}
			\item Oznaka čvora
			\item Vrsta čvora (grupa) - A, B ili C
			\item Oznaka domene za boju čvora (koji skup boja koristi)
			\item Početna boja za čvor
			\item Oznaka da li je čvor nepromjenjiv
		\end{enumerate}
\end{enumerate} 

\subsubsection{Izlazni podaci}

Kao izlaz algoritma koristi se par brojeva $(i, c)$ gdje je $i$ oznaka za čvor, a $c$ je boja čvora.

\section{Matematički opis problema}

Potrebno je modelirati problem u kojem postoji \emph{bazna stanica} i veze između istih, koje predstavljaju mjeru u kojoj jedna bazna stanica utjeće na drugu. Jedan od mogućih modela je graf. Čvorovi će predstavljati bazne stanice, a jakost između dvije bazne stanice biti će modelirano pomoću težine brida. U nastavku bazna stanica nazivat će se čvorom. Nad ovako postavljenim grafom problem je dodjeliti k\^{o}dove tako da ako je moguće nema bridova koji na svojim krajevima imaju čvor s istim k\^{o}dom. Problem je poznat pod nazivom \emph{bojanje grafa}. Kako je uobičajeno pričati o bojama čvora (a ne o k\^{o}dovima) od sad pa nadalje \emph{scrambling} k\^{o}d nazivat će se bojom čvora. U nastavku će prvo biti opisan klasičan problem bojanja grafova, gdje se promatraju beztežinski grafovi (oni čiji bridovi nemaju težine). Nakon toga problem se poopćuje na težinske grafove, čime se modelira predhodno opisan problem.

\subsection{Definicije za klasičan problem bojanja grafova}

Najprije se definiraju matematički pojmovi. Nakon toga formalno je opisan problem bojanja grafova. Uz to se nadovezuje teorija izračunljivosti.

\subsubsection{Pojam grafa}

\begin{definition}
Jednostavni graf \textbf{G} sastoji se od nepraznog konačnog skupa \textbf{V(G)}, čije elemente nazivamo čvorovi grafa \textbf{G} i konačnog skupa \textbf{E(G)} različitih dvočlanih podskupova \textbf{V(G)} koje zovemo bridovi.
\end{definition}

\begin{definition}
Skup vrhova koji su susjedni vrhu \textbf{v} zovemo susjedstvo vrha \textbf{v} i označavamo s oznakom \textbf{H(v)}.
\end{definition}

\begin{definition}
Stupanj vrha \textbf{v} grafa \textbf{G} jednak je broju bridova koji su incidentni s \textbf{v}. Označavamo ga s \textbf{d(v)}.
\end{definition}

\begin{definition}
Neka je \textbf{G} jednostavan graf i $\mathbf{\omega}$ funkcija $\mathbf{\omega : E \rightarrow \mathbb{R}}$. Par \textbf{(G, $\omega$)} naziva se težinski graf. Pri čemu funkcija $\omega$ svakom bridu iz \textbf{G} dodjeljuje jedan element iz skupa realnih brojeva. Neka je \textbf{e} neki brid grafa \textbf{G}, njegova težina označena je s $\omega(\mathbf{\mathit{e}})$.	 
\end{definition}


\subsubsection{Definicija bojanja grafova}

\begin{definition}
Definiramo funkciju $\phi : V(G) \rightarrow \mathbb{N}$, koja svakom čvoru u grafu pridružuje jedan prirodan broj koji $\mathbf{\phi(v)}$, gdje je $\mathbf{v}$ čvor u grafu $\mathbf{G}$. Broj $\mathbf{\phi(v)}$ nazivamo boja čvora, a funkciju $\phi$ nazivamo \textbf{bojanje grafa}. 
\end{definition}

\begin{definition}
Bojanje grafa s najviše \textbf{k} boja nazivamo \textbf{k-bojanje} grafa. 
\end{definition}

\begin{definition}
Ako se graf može obojati s najviše \textbf{k} boja tada takvo bojanje nazivamo \textbf{legalno k-bojanje} grafa. 
\end{definition}

\begin{definition}
Graf je \textbf{k-obojiv} akko postoji legalno k-bojanje grafa.
\end{definition}


\begin{definition}
Ako je graf G \textbf{k}-obojiv, ali nije \textbf{(k-1)}-obojiv tada kažemo da je \textbf{k} kromatski broj grafa G, gdje se koristi oznaka $\chi(G)=k$  
\end{definition}


\begin{definition}
Podskup skupa V(G) nazivamo \textbf{nezavisni skup} ako u njemu ne postoje dva čvora koja su susjedna.  
\end{definition}

\begin{definition}
Brid koji spaja dva čvora iste boje nazivamo \textbf{konfliktni brid}.
\end{definition}

\begin{definition}
Dva čvora koja spaja konfliktni brid nazivamo \textbf{konfliktnim čvorovima}.
\end{definition}

\begin{definition}
Particiju skupa V(G) na k disjunktnih nepraznih podskupova $V_1,..., V_k$
 tako da vrijedi $V(G) = \bigcup_{j=1}^{k}V_j$ zovemo \textbf{k-dioba} grafa G. Ako su podskupovi  $V_1 ,..., V_k$  ujedno i nezavisni skupovi onda se to naziva \textbf{legalna k-dioba} grafa G.
\end{definition}

\begin{theorem}
\label{thm:dioba}
Graf \textbf{G} je \textbf{k-obojiv} akko postoji \textbf{legalna k-dioba} grafa \textbf{G}.
\end{theorem}

\begin{proof}
Pretpostavimo da je graf \emph{G} \textbf{k-obojiv}. Definiramo skupove $S_i$ tako da čvor grafa $\mathbf{v}$ pripada skupu $S_i$ ako je obojan bojom $\mathbf{i}$. Takvi skupovi su neprazni i disjunktni, te unija skupova $S_i$ čini skup svih vrhova grafa \emph{G}. Kako je G \textbf{k-obojiv} tada ne postoji boja zbog koje bi neki brid bio konfliktan pa sljedi da je podjela na skupove $S_i$ \textbf{legalna k-dioba} grafa G jer su skupovi $S_i$ nezavisni. 

Drugi smjer dokazuje se tako što se pretpostavi da postoji \textbf{legalna k-dioba} grafa \textbf{G} na skupove $S_i$. Kako je svaki skup indeksiran s indeksom \textbf{i}, tada svakom čvoru koji se nalazi u skupu $S_i$ dodjelimo boju \textbf{i}. Kako su skupovi $S_i$ prema pretpostavci disjunktni, neprazni i nezavisni tada ne postoje dva čvora koja bi imala istu boju. Q.E.D
\end{proof}

\subsubsection{Definicije računske teorije složenosti}

\begin{definition}
\textbf{Problem odluke} je problem koji uvijek ima odgovor \textbf{da} ili \textbf{ne}. Primjerice, problem da li je graf točno \textbf{k-obojiv} je problem odluke. Problem traženja kromatskog broja grafa nije problem odluke, jer tražimo točan broj \textbf{k}.
\end{definition}

\begin{definition}
Problem odluke za koje postoje algoritmi koji daju odgovor, a čije vrijeme izvršavanje ovisi polinomno o veličini ulaznih podataka spadaju u \textbf{klasu P}.
\end{definition}

\begin{definition}
\textbf{Problem odluke} spada u klasu \textbf{NP problema} ako se točnost njegovog rješenja može ispitati u polinomnom vremenu. 
\end{definition}

\begin{definition}
\textbf{Problem odluke} spada u klasu \textbf{NP-potpunih problema} ako spada u \textbf{klasu NP} problema i koji ima svojstvo da se svaki drugi problem iz \textbf{klase NP} može polinomno reducirati na njega. 
\end{definition}

\begin{definition}
Kažemo da je problem \textbf{NP-težak} akko postoji \textbf{NP-potpun problem} koji se može polinomno reducirati na njega.
\end{definition}

Problem odluke za koji postoji algoritam čije trajanje ovisi polinomno o veličini ulaznih podataka tada je to \textbf{P problem}. Ako za neki problem odluke ne možemo pronaći algoritam čije vrijeme izvođenja ovisi polinomno o veličini ulaznih podataka, ali točnost rješenja možemo provjeriti u polinomnom vremenu tada je to \textbf{NP problem}. \textbf{NP-potpun problem} je problem odluke čiji algoritam možemo iskoristiti da bi rješili sve \textbf{NP probleme} tako da koristimo polinoman broj poziva tog algoritma. Općeniti problemi (koji ne moraju biti problemi odluke) nazivaju se \textbf{NP-teški problemi} ako postoji problem u klasi \textbf{NP-potpunih problema} koji se može rješiti pomoću polinomnog broja poziva algoritma za promatrani \textbf{NP-teški} problem. Odnost \textbf{P} i \textbf{NP} klasa još je uvijek otvoren problem ($P=NP$ ili $P\subset NP$). Kada bi se moglo dokazati da je neki \textbf{NP-potpun} problem moguće rješiti u polinomnom vremenu, tada bi se svi \textbf{NP problemi} mogli rješiti u polinomnom vremenu, pa bi klase \textbf{P} i klase \textbf{NP} bile jednake. Ako se pak pokaže da za neki \textbf{NP} problem ne postoji algoritam čije izvršavanje ovisi polinomno o ulaznim podacima, tada bi klasa \textbf{P} bila pravi podskup od klase \textbf{NP}.  

\subsubsection{\emph{No free lunch} teorem za optimizacijske algoritme}

\begin{definition}
\textbf{Optimizacija} je grana matematike koja proučava pronalaženje ekstrema funkcija.
\end{definition}

\begin{definition}
\textbf{Kombinatorna optimizacija} je grana optimizacije, gdje je domena funkcije skup s konačnim brojem elemenata.
\end{definition}

\begin{definition}
Konkretna funkcija koja se proučava naziva se \textbf{funkcija cilja}.
U radu se zbog semantike umjesto funkcije cilja često koristi pojam greške.
\end{definition}

\begin{definition}
Funkcije cilja koje se promatraju imaju diskretnu i konačnu domenu i kodomenu. Iako se kao elementi koodomene mogu pojaviti realni brojevi, zbog toga što su računala diskretni strojevi s konačno mnogo memorije, to je samo konačni podskup realnih brojeva.
\end{definition}

\begin{theorem}
Funkcija cilja definira se kao: $f : \mathbb{X} \rightarrow \mathbb{Y}$, gdje su skupovi $\mathbb{X}$ i $\mathbb{Y}$ diskretni i konačni. Tada je broj svih mogućih funkcija jednak $|\mathbb{F}| = |\mathbb{Y}|^{|\mathbb{X}|}$. 
\end{theorem}

\begin{proof}
Za svaki element domene možemo odabrati točno $|\mathbb{Y}|$ elemenata koodomene. 
\begin{equation}
|\mathbb{F}| = \prod_{j=1}^{|\mathbb{X}|} |\mathbb{Y}| =  |\mathbb{Y}|^{|\mathbb{X}|}
\end{equation}
\end{proof}

\begin{definition}
Vremenski niz $d_m$ je niz parova domene i kodomene.
\begin{equation}
d_m = \left \{ (d_m^x(1), d_m^y(1)), (d_m^x(2), d_m^y(2)), ..., (d_m^x(m), d_m^y(m))\right \}
\end{equation} 
Iz nekog niza $d_m$ može se izvući samo niz elemenata domene i to se označava s $\mathbf{d_m^x}$ ili samo niz elemenata kodomene što se označava s $\mathbf{d_m^y}$.
\end{definition}

\begin{definition}
Prostor svih vremenskih nizova veličine $m$: $\mathbb{D}_m = (\mathbb{X} \times \mathbb{Y})^m$, a prostor svih vremenskih nizova maksimalne veličine $m$ je: $\mathbb{D} = \bigcup_{m\ge0}\mathbb{D}_m$.
\end{definition}

\begin{definition}
Optimizacijski algoritam $a$ definira se kao: $a : d \in \mathbb{D} \rightarrow \left \{x | x \notin d_m^x \right \}$
\end{definition}

Optimizacijski algoritam preslikava neki vremenski niz (podatke iz predhodnih koraka izvođenja) u novu vrijednost domene. S time da ta vrijednost domene ne smije biti već viđena. Ovo ograničenje koristi se u dokazu teorema, ali u praksi se često mogu javiti slučajevi gdje se više puta računa vrijednost funkcije za isti element domene.

\begin{definition}
\textbf{Heuristikom} se naziva optimizacijski algoritam koji ne mora kao rezultat dati globalni ekstram \textbf{funkcije cilja}, ali daje dovoljno dobre rezultate u svrhu bržeg kraćeg vremenskog izvođenja. 
\end{definition}

\begin{definition}
\textbf{Metaheuristikom} naziva se familija optimizacijskih algoritama, čije konkretno izvođenje ovisi o njegovim parametrima.
\end{definition}

\begin{definition}
Skup svih dozvoljenih rješenja u optimizaciji nazivamo \textbf{prostor pretrage}.
\end{definition}

\begin{theorem}
\label{thm:nofreelunch}
\textbf{"No free lunch" teorem za optimizaciju} - Neka su $a_1$ i $a_2$ dva različita heuristička algoritma koji traže ekstrem funkcije. Funkcije su predstavljene crnom kutijom. Tada vrijedi ova jednakost:
\begin{equation}
	\sum_{f}P(d_m^y|f,m,a_1) = \sum_{f}P(d_m^y|f,m,a_2)
\end{equation}
\end{theorem}

Dokaz teorema može se pronaću u [literatura].

Kako se ne zna ništa više o funkcijama (npr. simbolički zapis) već samo ulazni i izlazni parovi ne može se koristiti nikakvo unutarnje znanje koje bi nekom algoritmu dalo prednost. Ako je poznat broj koraka $m$ tada za bilo koji algoritam, sume vjerojatnosti su međusobno jednake, pri čemu se gleda vjerojatnost da se pojavio neki niz izlaznih vrijednosti funkcije $d_m^y$.
Iz niza izlaznih vrijednost $d_m^y$ može se lako izvući minimalna ili maksimalna vrijednost koja je tada konačan izlaz algoritma. Dakle ne postoji algoritam koji bi bio dominantniji za sve funkcije cilja $f$. Zbog toga je potrebno svaki optimizacijski problem promatrati veoma usko i koristiti dodatne informacije o samoj funkciji $f$.

Predhodne definicije i teoremi služe kako bi se uskladili nazivi za matematičke pojmove koji će se koristiti u radu. Sve definicije uzete su iz [literatura], gdje se međuostalim mogu naći i druge definicije i teoremi vezani za teoriju grafova, računsku teoriju složenosti i "\emph{No free lunch}" teorem.

\subsection{Bojanje težinskih grafova}

Za navedeni telekomunikacijski problem potrebno je odabrati prikladan matematički model. Već je spomenuto da se bazne stanice modeliraju čvorovima u grafu. Postavlja se pitanje što predstavlja brid u tome grafu. Očigledno je da jedna bazna stanice utjeće na drugu baznu stanicu, tj. mobilni uređaj istovremeno vidi više baznih stanica. To znači da bi brid mogao predstavljati relaciju da li neka bazna stanica vidi drugu baznu stanicu. Ali problem se može razviti i korak dalje. Nije svejedno na kojoj su udaljenosti bazne stanice, te koja je njihova snaga. To znači da dvije bliže (ili jače) bazne stanice više utjeću jedna na drugo nego što to čine dvije udaljenije. Idaja je svakom bridu dodijeliti težinu koja predstavlja neku mjeru koliko jedna bazna stanica utjeće na drugu. To znači da brid između dva čvora daje mjeru međusobnog utjecaja čvorova. Ako je utjecaj premali (tehnički nevidljiv), tada brid između ta dva čvora ne postoji.

Na tako zadanom težinskom grafu potrebno je napraviti bojanje grafa tako da se poštuju tehnički uvjeti. Sad se pojavio problem jer bojanje težinskog grafa nije dobro definiran problem. Zato se klasični problem bojanja grafova poopćuje:

\begin{definition}
Bojanje težinskog grafa je optimizacijski problem u kojem se minimizira funkcija cilja:
\begin{equation}
f(\phi) = \sum_{i=1}^{E(G)} \omega(e_i) \cdot R(e_i)
\end{equation}
, gdje je $\omega(e_i)$ težina brida, a $R$ funkcija koja ima vrijednost $1$ ako je $e_i$ konfliktan brid ili $0$ inače. Funkcija $f$ ovisi o bojanju grafa, tj. funkcija cilja jednaka je sumi težina konfliktnih bridova.
\end{definition}

Zbog tehničkih ograničenja potrebno je uvesti još malo matematičkih detalja koji pokrivaju te slučajeve.

\begin{definition}
Funkcija $\phi$ definira se kao funkcija koja svakom ne nepromjenjivom čvoru $v$ grafa \textbf{G} pridružuje prirodan broj iz skupa dopuštenih boja za taj čvor.
\end{definition}

\begin{definition}
Ako su dva čvora \textbf{nepromjenjiva} spojena bridom i imaju iste boje, tada smatramo da taj brid nije \textbf{konfliktan}.
\end{definition}

Razlog ovakvoj definiciji je to što bridovi koji spajaju dva nepromjenjiva čvora različitih boja ne mogu se nikada poboljšati, pa shodno tome neovisni su o funkciji bojanja grafa $\phi$.

\begin{definition}
Ako su dva čvora koja spadaju u suprotne vrste spojena bridom, tada se takav brid ne smatramo \textbf{konfliktnim}.
\end{definition}

Tehnički takva dva čvora ne utjeću jedan na drugog pa tada nema potrebe to ugrađivati u funkciju cilja.

U slučaju da je čvor obojan bojom koja nije u njegovoj domeni tada je potrebno dodati u funkciju cilja kaznu za takav slučaj. Iako po definiciji funckije bojanja grafa to nije moguće, zbog inicjalnog stanja boja koje algoritam primi kao ulaz može se dogoditi da boja čvora nije u njegovoj domeni. Stoga se definira proširena funkcija cilja kao:

\begin{definition}
\begin{equation}
\label{equ:funkcija_cilja}
f(\phi) = \sum_{i=1}^{E(G)} \omega(e_i) \cdot R(e_i) + \sum_{i=1}^{V(G)} C(v_i)
\end{equation}
Prva suma jednaka je već definiranoj funkciji cilja. Drugi član je suma funkcije $C$ po čvorovima, gdje funkcija $C$ ima vrijednst $\varepsilon$ ako je čvor $v_i$ krivo obojan ili $0$ ako je obojan bojom iz svoje domene.
\end{definition}

Za epsilon se odabire neki veliki pozitivan broj. U konkretnoj implementaciji koja se koristi u radu $\varepsilon=10000000$.

\begin{definition}
Smatra se da je bojanje \textbf{valjano} ako postotak promjene boja inicjalnog stanja ne prelazi prag od $\alpha$ posto.
\end{definition}

U konkretnom problemu $\alpha=66\%$.

Sažetak problema kojeg modeliramo pomoću težinskog grafa glasi:
\begin{itemize}
	\item Svaki čvor može poprimiti jednu boju iz skupa dopuštenih boja za taj čvor
	\item Svaki čvor spada u jednu grupu tj. vrstu (A, B ili C)
	\item Neki čvorovi su definirani kao nepromjenjivi, njima se boja nikad ne smije mjenjati
	\item Dodatan uvijet je da postotak promjenjenih čvorova naprema inicijalnom stanju ne smije biti veća od 66\%
	\item Optimizacija se provodi nad funkcijom cilja definiranom formulom (\ref{equ:funkcija_cilja}).
\end{itemize}

\section{Analiza problema bojanja težinskih grafova}

U ovom odjelku biti će analiziran zadani matematički problem optimizacije. U svakom koraku analize uspoređuju se klasičan problem bojanja grafova i bojanje težinskih grafova. Kreće se od analize prostora pretrage. Zatim se dokazuje u kojoj se klasi problemi nalaze. Na kraju se pokazuje da "\emph{No free lunch}" teorem vrijedi i za bojanje grafova i kakve posljedice donosi.

\subsection{Prostor pretrage stanja}

Kod klasičnog problema bojanja grafova analiziraju se dva problema. Prvi je odrediti da li se graf može pobojati s najviše $k$ boja, a drugi problem je odrediti najmanji takav $k$. Pretpostavimo za početak da provjeravano da li je graf \textbf{k-obojiv}. Pitanje je na koliko načina se graf može pobojati ako koristimo najviše \textbf{k} boja. Svaki čvor može poprimiti \textbf{k} boja. To znači da je ukupan broj bojanja $N$ jednak: 

\begin{equation}
N = k^{V(G)} 
\end{equation}

Valja primjetiti da u ovom brojanju veličine prostora stanja postoji više jednako vrijednih bojanja. U bojanju nije bitna točna boja, već je bitno da različiti skupovi čvorova imaju različite boje. Točno pitanje je na koliko načina možemo čvorove podijeliti u $k$ skupova (teorem \ref{thm:dioba}).  

\begin{equation}
N = \sum_{i=1}^{k} S(V(G), i)
\end{equation}

Oznaka $S(m,n)$ je za \emph{Stirlingov} broj druge vrste, gdje je $m$ broj različitih elemenata (čvorovi) koje smještamo u $n$ istovrsnih skupova boja, tako da svaka boja ima barem jedan čvor. Kako je dopušteno da kutije mogu biti prazne, tada se problem pretvori u disjunktne probleme gdje se koristi samo $i$ kutija. 

Ako se zahtjeva da svaka od $k$ boja mora biti iskorištena, ekvivalentno da ni jedan od $k$ skupova ne smije biti prazan, tada je ukupan broj stanja nešto manji:

\begin{equation}
N = S(V(G), k) = \frac{1}{k!}\sum_{i=0}^{k} (-1)^i \binom{k}{i}(k-i)^{V(G)}  
\end{equation}

Ako se čvrsto zahtjeva da svaka boja mora biti barem na jednome čvoru, tada je to \emph{Stirlingov} broj druge vrste, gdje je i navedena formula za izračun $S(m,n)$.

Neka se promatra problem traženja kromatskog broja grafa $\chi(G)$, tj. minimalni broj boja $k$, a da se graf može legalno obojiti. Maksimalni broj za koji je to potrebno provjeriti je broj čvorova u grafu, zato jer u tom slučaju svaki čvor povezan je sa svakim drugim i svaki čvor mora imati svoju boju. Kromatski broj grafa je dakle ograničen odozgo s brojem čvorova. Za svaki broj $k$ do $V(G)$ treba provjeriti da li je graf \textbf{k-obojiv}. Ukupan broj stanja je:

\begin{equation}
N = B(V(G)) = \sum_{i=0}^{V(G)} S(V(G), i)
\end{equation}

Broj $B(n)$ naziva se \emph{Bellov} broj i on predstavlja broj načina na koje se skup od $n$ članova može podijeliti u neprazne podskupove. Za bolji uvid koliko brzo \emph{Bellov} niz raste dane su nejednakosti (za $n\ge 8$): 

\begin{equation}
2^n \le B(n) \le n! 
\end{equation}

\emph{Bellov} broj brže raste od eksponencijalne funkcije, ali sporije od faktorijela.

\begin{proof}
Prvo se pokazuje nejednakost: $2^n\le B(n), n \ge 5$.
Dokaz se provodi indukcijom. Koriste se razvoj binoma: 
\[ 2^n=(1+1)^n = \sum_{k=0}^{n}\binom{n}{k} \] 
i svojstvo Bellovog broja: 
\[ B(n+1)=\sum_{k=0}^{n}\binom{n}{k}B(k) \]
	\begin{align}
		2^n \le B(n) \\
		\textup{Baza indukcije: } n = 5, 2^5 \le B(5) \rightarrow 32 \le 52 \\
		\textup{Pretpostavka: } 2^n \le B(n) \\
		2^{(n+1)} \le B(n+1) \\
		2\cdot 2^n \le B(n+1) \\
		\sum_{k=0}^{n} 2\cdot \binom{n}{k} \le \sum_{k=0}^{n}\binom{n}{k}B(k)\\
		\sum_{k=0}^{3} 2\cdot \binom{n}{k} + \sum_{k=4}^{n} 2\cdot \binom{n}{k} \le \sum_{k=0}^{3}\binom{n}{k}B(k) + \sum_{k=4}^{n}\binom{n}{k}B(k) \\
		\textup{Prvo se dokazuje: } \sum_{k=0}^{3} 2\cdot \binom{n}{k} \le \sum_{k=0}^{3}\binom{n}{k}B(k) \\
		2\binom{n}{0} + 2\binom{n}{1} + 2\binom{n}{2} + 2\binom{n}{3} \le \\ \binom{n}{0}B(0) + \binom{n}{1}B(1) + \binom{n}{2}B(2) + \binom{n}{3}B(3) \\
		2+2n+\frac{n(n-1)}{2}2+\frac{1}{3}n(n-1)(n-2) \le \\1 + n + \frac{n(n-1)}{2}2+\frac{n(n-1)(n-2)}{6}5 \\
		1+n \le n(n-1)(n-2)(\frac{5}{6}-\frac{1}{3}) \\
		1+n \le \frac{n(n-1)(n-2)}{3} \\
		3+3n\le n^3 - 3n^2 +3n \\
		3n^2+3 \le n^3 \\
		3 \le n^3 - 3n^2 \\
		3 \le n^2 (n - 3), \textup{istina za } n\ge 5 \\
		\textup{Druge dvije sume: } \sum_{k=4}^{n} 2\cdot \binom{n}{k} \le \sum_{k=4}^{n}\binom{n}{k}B(k) \\
		\textup{Član po član sume: }\binom{n}{k} 2 \le \binom{n}{k} B(k) \\
		2 \le B(k), \textup{za } k \ge 4
	\end{align}
\end{proof}

\begin{proof}
	Potrebno je dokazati $B(n) \le n!$. Dokaz se provodi iz svojstava za Bellov broj (Berend, D.; Tassa, T. (2010)): 
	\[ B(n) \le \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \] 
	i svojstvo faktorijela koja slijedi iz analize Stirlingove aproksimacije: \[ n!\ge \left ( \frac{n}{e} \right )^n \]
	\begin{align}
		B(n) \le \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \le \left ( \frac{n}{e} \right )^n \le n! \\
		\textup{Dovoljno je pokazati: } \left [ \frac{0.792 n}{ln(1+n)} \right ]^n \le \left ( \frac{n}{e} \right )^n \\
		\left [ \frac{0.792 n}{ln(1+n)} \right ] \le \left ( \frac{n}{e} \right ) \\
		0.792 n\cdot e \le n \cdot ln(n+1) \\
		0.792\cdot e \le ln(n+1) \\
		e^{0.792\cdot e} \le n+1 \\
		8.61 -1 \le n \\
		7.61 \le n
	\end{align}
\end{proof}

Zaključak predhodne alanize je da za relativno veliki graf postoji velik broj stanja koje je nemoguće pretražiti pomoću \emph{brute force} algoritama. Analiza prostora stanja za zadani problem malo je drugačija. Kako svaki čvor ima konačan broj boja koje može poprimiti ukupan broj stanja je:

\begin{equation}
N = \prod_{i=1}^{V(G)} K_i
\end{equation}
, gdje je oznaka $K_i$ ukupan broj boja koje može poprimiti čvor s indeksom $i$. Kako je moguće dodijeliti maksimalno samo $512$ boja, možemo ograničiti $K_i$:
\begin{equation}
K_i \le M = 512
\end{equation}
\begin{equation}
N = \prod_{i=1}^{V(G)} K_i \le \prod_{i=1}^{V(G)} M = M^{V(G)}
\end{equation}

Broj stanja eksponencijalno ovisi o broju čvorova, što je isto kao i za klasičan problem bojanja grafa jako velik broj stanja. I u ovom slučaju važno je primjetiti da su neka stanja ekvivalentna. Broj jedinstvenih stanja je broj particija skupa čvorova u skupove boja, ali uz ograničenje da barem jedan čvor ima neku od zadanih $M$ boja, tada vrijedi ova nejednakost za broj različitih stanja:

\begin{equation}
N \le \sum_{i=1}^{M} S(V(G), i)
\end{equation}

Broj stanja je manji jer se poštuje ograničenje da čvorovi mogu poprimiti neku od boja u podskupu od ukupnog konstantnog broja boja $M$. Kada je $k\ge M$ tada broj stanja optimizacijskog problema je manji od broja stanja u problemu gdje se traži odgvor na pitanje da li je graf \textbf{k-obojiv}. Ovo razmatranje biti će zanimljivo i u sljedećem poglavlju gdje se problem svrstava u klase računske teorije složenosti.

\subsection{Pozadina problema iz perspektive računske teorije složenosti}

Problem odluke da li je graf \textbf{k-obojiv} spada u klasu \textbf{NP-potpunih} problema. Traženje kromatskog broja grafa $\chi(G)$ spada u klasu \textbf{NP-teških} problema. Dokazi se mogu pronaći u \cite{Garey:1974:SNP:800119.803884}. Potrebno je pokazati da postavljen optimizacijski problem bojanja grafa spada u klasu \textbf{NP-teških} problema. Problem sigurno ne može spadati u druge spomenute (P, NP, NP-potpun) klase zato jer to nije problem odluke.
Postupak dokazivanja da problem spada u klasu \textbf{NP-teških} problema ima nekoliko koraka. Prvi korak je pronalaženje nekog \textbf{NP-potpunog} ili \textbf{NP-teškog} problema koji će se koristiti u dokazu. Zatim se pokaže da je taj \emph{stari} problem moguće polinomno reducirati na problem za koji se dokazuje da je \textbf{NP-težak}. 

\begin{proof}
Odaberemo \textbf{NP-potpun problem} koji ispituje da li je graf $G$ \textbf{k-obojiv}. Da bismo rješili taj problem koristimo zadani optimizacijski problem. Ulaz u optimizacijski algoritam međuostalim su graf $G$ i ograničenja boja za svaki od čvorova. Svakom čvoru daje se skup $\{1,2,...,k\}$ s bojama. Svim bridovima daje se težina $1$. Sada se pokreće crna kutija s optimizacijskim problemom koja će rješiti taj problem. Ako je rezultat optimizacije tj. funkcije cilja $f=0$, tada je graf \textbf{k-obojiv}, inače nije. U konstantnom vremenu možemo reducirati problem, iz čega sljedi da je optimizacijski problem \textbf{NP-težak}.  
\end{proof}

Zanimljivo je primjetiti da \textbf{NP-potpun} problem k-obojivosti može imati više stanja od \textbf{NP-teškog} problema optimizacije. Što znači da je moguće da vrijeme izvršavanja optimizacije bue manje od vremena provjere k-obojivosti. Kako nije poznat odnos \emph{NP} i \emph{P} klase, za ovaj optimizacijski problem nameće se korištenje heuristika. U ovom tehničkom problemu nije potrebno do kraja minimizirati funkciju cilja, nego dobiti dovoljno malu vrijednost $f$ što će uzrokovati bolju kvalitetu mobilne mreže. 

\subsection{Posljedica "\emph{No free lunch}" teorema}

U originalnom članku, gdje se dokazuje "\emph{No free lunch}" teorem [literatura], pretpostavlja se da sve funkcije cilja imaju iste domene i kodomene. Za problem bojanja grafova to nije tako. Funkcija cilja definirana je kao: $f:V(G) \rightarrow \mathbb{R}$, ali kako računalo ima konačnu memoriju tada je funkcija zapravo definirana kao: $f:V(G) \rightarrow \mathbb{Y}$, gdje je $\mathbb{Y}$ konačni podskup realnih brojeva koji se mogu prikazati na računalu. Problem za "\emph{No free lunch}" teorem je to da veličina domene funkcije cilja ovisi o broju čvorova grafa. Broj grafova je beskonačan, jer možemo uzeti proizvoljan broj čvorova, što znači da postoji i beskonačan broj mogućih funkcija cilja. Teorem radi samo ako je broj funkcija cilja ograničen (teorem \ref{thm:nofreelunch}). Kako je na nekom računalu nemoguće prikazati proizvoljno veliki graf, broj čvorova može se ograničiti s nekom granicom $M$. Sada je moguće prebrojati sve funkcije cilja $f$.

\begin{proof}
Pitanje je koliko funkcija postoji, ako je broj članova domene ograničen s $M$.
Broj funkcija koje imaju točno $k$ elemenata u domeni ima:
	\begin{equation}
		|\mathbb{F}_k| = |\mathbb{Y}|^k
	\end{equation}
Ukupan broj funkcija je suma po svim $k$ do granice $M$ (koristi se suma za geometrijski niz):
	\begin{equation}
		|\mathbb{F}| = \sum_{k=1}^{M}|\mathbb{F}_k| = \sum_{k=1}^{M} |\mathbb{Y}|^k = \frac{|\mathbb{Y}|^{M+1}-|\mathbb{Y}|}{|\mathbb{Y}|-1}
	\end{equation}
\end{proof} 

Ako se ograniči broj čvorova, dobije se konačan broj funkcija te je to lako ugraditi u teorem \ref{thm:nofreelunch}. Teorem govori o tome da nemamo nikakvo zanje o funkciji. U ovom problemu funkcija cilja direktno ovisi o grafu tj. strukturi i to je važna informacija koja treba biti iskorištena da bi se dobili bolji algoritmi. Glavna posljedica ovog teorema je razvoj pohlepnih algoritama koji koriste znanje o strukturi (grafu) i primjena tih algoritama u metaheurističkim postupcima. 
Važno je uočiti da je svaki graf posjeduje vlastitu funkciju cilja. To znači da korištenjem algoritama na sljepo koji rade na nekim grafovima ne mogu jamčiti efikasnost na drugim.

U članku \cite{conf/eurogp/PoliG09} opisuje se kako postoji slučajevi u kojima hiper-heuristike mogu imati "\emph{Free lunch}" svojstvo. Hiper-heuristike su algoritmi koji traže najbolji algoritam koji može rješiti neki problem, tj. pronaći ekstrem funkcije cilja. Kako je gore opisano, svaki graf ima svoju funkciju cilja. Ako je skup funkcija cilja dovoljno malen, moguće je da hiper-heuristika uvijek pronađe neki algoritam koji je bolji od svih ostalih za konkretnu funkciju cilja. Ovo nije dokazano za bojanje grafova (tako ni za optimizacijski problem bojanja), ali daje motivaciju u razvoju algoritama. U zadnjem dijelu opisa algoritama u ovom radu koriste se metode strojnog učenja kako bi se izvuklo znanje za primjenu u nekim pohlepnim algoritmima, tj. kako bi se odabrao najbolji pohlepan algoritam, što je zapravo jednostavan oblik hiper-heuristike. Osim toga u implementaciji je otvoren prostor gdje se lako mogu donostiti odluke i dinamički birati algoritmi koji u trenutnoj točci u prostoru stanja daju bolje rezultate od drugih algoritama.

\chapter{Algoritmi}

\section{Uvod}

Algoritmi koji su implementirani za ovaj problem podijeljeni su u dva dijela. Prva skupina su pohlepni algoritmi, a drugi algoritmi s kojima se i rad bavi su meta heuristike. Proučavaju se tri metaheuristike: agentski algoritam, genetski algoritam i genetsko kaljenje. Započinje se s konstruiranjem hiper-heuristike nad pohlepnim algoritmima, gdje se želi pokazati koji pohlepni algoritam je najbolji u raznim ovisnostima. Pri testiranju algoritama treba biti veoma oprezan. Predhodna razmatranja upućuju na to da neki algoritam (metaheuristika s određenim parametrima) može dati bolje rezultate od drugih algoritama na nekim grafovima, dok je na nekim grafovima obrnuta situacija. To se može usporediti s pojmom \emph{prenaučenosti} iz strojnog učenja. Zbog toga je za ovaj problem potrebno graditi algoritme koji su prilagodljivi.

\section{Pohlepni algoritam}

Pojam pohlepnog algoritma u ovom radu znači sortirati čvorove grafa po nekom svojstvu. Zatim obilaziti čvorove tim redosljedom i na svaki od njih primjeniti odabranu vrstu bojanja čvora. Vrsta bojanja čvora je način odabira boje za neki čvor. Pohlepni algoritam se koristi kao operator kod meta heuristika, tj. kao metoda koja usmjeruje pretragu.
U radu se koriste slijedeće metode za sortiranje i bojanje čvorova (za svaku od metoda koristi se specjalna oznaka):

Vrste sortiranja čvorova:

\begin{itemize}
	\item \emph{COL} - sortiranje čvorova prema koliziji (broj susjednih čvorova koji imaju drugačiju boju od promatranog čvora)
	\item \emph{FIT} - sortiranje čvorova prema pogrešci koju generiraju (suma težina konfliktnih bridova iz tog čvora)
	\item \emph{LDO} - sortiranje prema stupnju čvora $H(v)$
	\item \emph{RND} - slučajan raspored čvorova
	\item \emph{SDO} - sortiranje prema zasićenju (broj različitih boja susjednih čvorova)
	\item \emph{SDOLDO} - sortiranje prema zasićenju, a ako dva čvora imaju isto zasićenje drugi kriterij je stupan čvorova [članak]
	\item \emph{STDORD} - sortiranje prema oznaci čvora (čvorovi su numerirani)
\end{itemize}

Vrste bojanja čvorova su:

\begin{itemize}
	\item \emph{ABW} - susjedi čvora sortiraju se prema težini brida, obilazi se svaki susjed i uzima se njegova boja. Ako je ta boja jedna od dopuštenih za promatrani čvor, ta boja više ne može biti odabrana. Kada na raspolaganju ostane samo jedna boja ili su svi susjedi posjećeni, uzima se jedna od boja koja je još uvijek na raspolaganju. 
	\item \emph{MC} - traži se dopuštena boja koja trenutnom čvoru daje minimalnu vrijednost kolizije
	\item \emph{MF} - traži se dopuštena boja koja trenutnom čvoru daje minimalnu sumu konfliktnih bridova
	\item \emph{RND} - daje se slučajna dopuštena boja
	\item \emph{START} - čvoru se daje početna boja (ako je dopuštena) ili se boja ne mjenja ako u inicjalnom bojanju boja nije bila dopuštena
	\item \emph{SWAP} - čvoru se daje neka boja gdje apsolutno odstupanje od greške (sume konfliktnih bridova) naspram trenutne greške nije veće od nekog praga
	\item \emph{TRG} - čvoru se daje neka boja čija nova greška (suma konfliktnih bridova) ne prelazi neku fiksnu vrijednst. 
\end{itemize}

\subsection{Neispravnost pohlepnog algoritma}

Važno je pokazati kako pohlepni algoritam neće pronaći globalni minimum funkcije cilja. Neka je zadan graf na slici \ref{fig:greedy_alg}.
Slika \ref{fig:crown_empty} prikazuje graf koji je potrebno obojati korištenjem samo dvije boje. Neka su težine svih bridova jednake $1$. Slika \ref{fig:crown_normal} prikazuje 2-legalno obojan graf čija je vrijednost funckije cilja u optimizaciji jednaka $0$. Ako se u postupku sortiranja čvorova dogodi poredak prva tri čvora kako je to prikazano na slici \ref{fig:crown_wrong}, bez obzira na to kako je drugi dio čvorova sortiran ni jedan algoritam više ne može doći do globalnog minimum funkcije cilja, zato jer prva dva koraka su čvorove koji sigurno moraju biti u različitim bojama svrstao u isti skup, a posljedica je bojanje trećeg čvora drugom bojom (jer je susjedan drugo odabranom), a nakon toga cijelo rješenje je pogrešno.


\begin{figure}
        \centering
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_empty.pdf}
                \caption{Neobojan graf}
                \label{fig:crown_empty}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_normal.pdf}
                \caption{2-legalno obojan graf}
                \label{fig:crown_normal}
        \end{subfigure}
         
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_wrong.pdf}
                \caption{Odabir prva tri čvora}
                \label{fig:crown_wrong}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.33\textwidth}
                \includegraphics[width=\textwidth]{Slike/crown_wrong_full.pdf}
                \caption{Pogrešno obojan graf}
                \label{fig:crown_wrong_full}
        \end{subfigure}
        \caption{Prikaz pravilno obojanog grafa i primjer pohlepnog algoritma}
        \label{fig:greedy_alg}
\end{figure}


Moguće rješenje navedenog problema moglo bi biti u pretraživanju susjednih čvorova. Neka su boje označene brojevima, gdje je prva boja označena s $1$. Prvi čvor odabere se slučajno. Za odabrani čvor odabere se boja s minimalnom oznakom, a nema je u susjednim čvorovima. Sljedeći čvor biti će neki od susjeda trenutnog čvora. Ako čvor nema susjeda za odabir onda se traži čvor koji nije obojan ali ima obojanog susjeda (pretpostavka je da je graf povezan). Ovako opisan algoritam uvijek će dobro obojati graf na slici \ref{fig:crown_empty}. Potrebno je ako ima, pronaći graf na kojem ovakav pohlepni algoritam koji se još i naziva \emph{uspinjanje na vrh} ne radi dobro. Primjer takvog grafa i odabir čvorova može se vidjeti na slici \ref{fig:hill_climbing}. Brojevi u čvorovima predstavljaju poredak obilaženja grafa. Na slici \ref{fig:hill_climbing_ok} odabir čvorova je takav da je ukupan broj boja, a da funkcija cilja bude $0$ jednak $3$. To je ujedno i minimalni broj boja, jer u grafu postoje tri čvora koja su međusobno povezana, dakle s manjim brojem boja nije moguće legalno obojati graf. Na slici \ref{fig:hill_climbing_wrong} odabir čvorova je bio takav da u zadnjem posjećenom čvoru $8$ bilo potrebno odabrati novu boju da bi graf bio legalno obojen. Kako se pokazalo da je graf moguće obojati s $3$ boje, zaključak je da algoritam ne daje uvijek točan rezultat.

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
                \includegraphics[width=\textwidth]{Slike/hill_climbing_ok.pdf}
                \caption{Dobar odabir čvorova}
                \label{fig:hill_climbing_ok}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.4\textwidth}
                \includegraphics[width=\textwidth]{Slike/hill_climbing_wrong.pdf}
                \caption{Loš odabir čvorova}
                \label{fig:hill_climbing_wrong}
        \end{subfigure}
        \caption{Isti algoritam uz drugačiji odabir čvorova daje različita k-legalna bojanja}
        \label{fig:hill_climbing}
\end{figure}



\section{Agentski algoritam}

Agentski algoritam inspiriran je dobrim rezultatima pohlepnog algoritma. Glavna jedinica algoritma je agent. Agenti se rasporede po grafu, gdje se neki agent postavi na neki čvor grafa. \emph{Globalna iteracija} je jedna iteracija algoritma u kojoj svaki agent svome čvoru pridruži neku boju. Agenti se boduju i to tako da na početku svi imaju $0$ bodova, a nakon globalne iteracije, broj bodova za nekog agenta je jednak maksimalnoj pogrešci nekog susjednog čvora, na koji se i agent pomakne. Zatim se agenti sortiraju prema bodovima i u sljedećoj globalnoj iteraciji pravo na bojanje prvo dobija agent s najviše bodova. Slično kao i kod pohlepnog algoritma, prvo se obrađuju \emph{teški čvorovi}, a to je u ovom algoritmu modelirano pomoću bodovanja. Agenti osim akcije pomaka na \emph{najbolji} čvor, mogu se pomaknuti na slučajan susjedni čvor ili pak ostati na čvoru na kojem jesu, tada bodovi za agenta ostaju isti.

\subsection{Parametri algoritma}

\begin{enumerate}
	\item Broj agenata - $N$
	\item Broj globalnih iteracija - $G$
	\item Način na koji agenti bojaju čvorove (vrsta bojanja) - $CS$
	\item Vjerojatnost ostajanja agenta na trenutnom čvoru - $PR\_NO\_MOVE$
	\item Vjerojatnost pomaka agenta na slučajni čvor u susjedstvu - $PR\_RND\_MOVE$
\end{enumerate}

\subsection{Detalji algoritma}

Koristi se pseudok\^{o}d kako bi se algoritam opisao formalno. U sustavu se nalazi $N$ agenata koje je prvo potrebno inicjalizirati, odnosno postaviti svakog agenta na neki od čvorova grafa. U svakoj od $G$ globalnih iteracija, prolazi se kroz populaciju agenata i svaki od njih prvo pridruži svome čvoru boju, a nakon toga radi funkciju pomaka. Nakon što se to obavi za svakog agenta, agenti se sortiraju prema bodovima koje su dobili u funkciji pomaka "\emph{MOVE}". U sljedećoj iteraciji agenti se obilaze po bodovima, od onog agenta koji ima najviše bodova do onog s najmanje bodova.

\begin{singlespace}
	\begin{lstlisting}[caption=Pseudok\^{o}d agentskog algoritma]
		ALGORITHM(N, G, CS, PR_NO_MOVE, PR_RND_MOVE):
			AGENT[N]
			FOR i = 1 TO N:
				init(AGENT(i))
			END FOR
			FOR j = 1 TO G:
				FOR i = 1 TO N:
					SETCOLOR(AGENT(i), CS)
					MOVE(AGENT(i), PR_NO_MOVE, PR_RND_MOVE)
				END FOR
				SORT(AGENT[N])
			END FOR
		END ALGORITHM
	\end{lstlisting}
\end{singlespace}

Funkcija pomaka ovisi o promatranom agentu i parametrima tj. vjerojatnostima "$PR\_NO\_MOVE$" i "$PR\_RND\_MOVE$". Prvo se radi odabir da li agent ostaje na istom čvoru ili ne. Ako ne ostaje opet se stohastički određuje akcija da li agent ide na čvor koji u susjedstvu radi najveću grešku ili ide na slučajnog susjeda. Ako agent odabire pomak prema najboljem susjedu, sljedeći čvor ne može biti isti onaj s kojeg je agent došao na trenutno promatrani, čime se sprječava titranje agenta.

\begin{singlespace}
	\begin{lstlisting}[caption=Detalji funkcije pomaka - MOVE]
		MOVE(AGENT, PR_NO_MOVE, PR_RND_MOVE):
			IF random() < PR_NO_MOVE THEN
				RETURN
			END IF
			NEXT_NODE = AGENT.NODE
			IF random() < PR_RND_MOVE THEN
				NEXT_NODE = AGENT.NODE.NEIGHBOUR[random()]
			ELSE
				FOR k = 1 TO AGENT.NODE.DEGREE:
					IF AGENT.NODE.NEIGHBOUR[k] = AGENT.BLOCK_NODE THEN
						CONTINUE
					ERROR = AGENT.NODE.NEIGHBOUR[k].ERROR
					IF ERROR > MAX_ERROR THEN
						MAX_ERROR = ERROR
						NEXT_NODE = AGENT.NODE.NEIGHBOUR[k]
					END IF
				END FOR
					AGENT.SCORE = MAX_ERROR
			END IF
			AGENT.BLOCK_NODE = AGENT.NODE
			AGENT.NODE = NEXT_NODE
		END MOVE
	\end{lstlisting}
\end{singlespace}

\subsection{Karakteristike algoritma}

Kako je algoritam temeljen na pohlepnom algoritmu ima nedostatak što lako zapinje u lokalnom minumumu. Dobra strana algoritma je što jedna globalna iteracija može vremenski trajati kraće od jedne iteracije pohlepnog algoritma, jer može posjedovati broj agenata manji od broja čvorova. Algoritam ima ugrađeno određeno znanje, tj. agent cilja na čvorove koje mora popraviti. Prednost dobijaju agenti koji moraju popraviti čvorove s većim greškama. Da bi se izbjegla brza konvergencija u logalni minimum, stohastički način odabira pomicanja omogućuje da agenti šetnjom dođu u područje koje bi trebalo popraviti. Ako je broj agenata veći od broja čvorova to omogućuje fino traženje minimuma. U tom slučaju jedan čvor biti će više puta obojan (minimiziran), a to znači da mu se prvo može dati neka boja, zatim se bojaju susjedi i onda opet taj isti čvor dolazi na red. Taj efekt propitkivanja starog poteza (koji se u ovom slučaju implicitno događa) omogućuje bolju odluku za pridruživanje boje. Nedostatak je povećanje vremena trajanja globalne iteracije.

Vremenska složenost algoritma ovisi o broju agenata i broju globalnih iteracija. Vremenska složenost je: $O(G\cdot(N+Nlog(N))=O(G\cdot N+G\cdot Nlog(N))=O(G\cdot Nlog(N))$. Kao što je vidljivo algoritam polinomno ovisi o $G$ i $N$.

\section{Genetski algoritam}



\section{Genetsko kaljenje}


\section{Pronalaženje najpogodnjeg pohlepnog algoritma}

Pohlepni algoritma u ovom radu koristi se na dva načina. Prvo se koristi kao metoda koja dovodi rješenje u neko dovoljno dobro rješenje, nakon čega minimizaciju funkcije preuzima neka metaheuristika. Druga način korištenja je kao dio metaheuristike u obliku operatora (npr. mutacija kod genetskog algoritma), metoda za izbjegavanje lokalnog minimuma (tuneliranje) ili pak metoda koja osigurava da postotak promjene boja naspram inicjalnog grafa ne prođe zadani prag. Kod korištenja pohlepnih algoritama u praksi se često koriste \emph{ad-hoc} metode konfiguriranja istog. Prednost ovakvih metoda je što u relativno kratkom vremenu mogu isprobati različite konfiguracije i zatim odabrati najbolju. Nedostatak metode je u tome što ta konfiguracija ne jamči dobar rad nad svim grafovima (\emph{No free lunch} teorem). Kao uvod u hiper-heuristike i postavljanje temelja za budući rad, iz grafova se želi izvući znanje o utjecaju vrsta sortiranja čvorova. Ovaj dio rada ima dva cilja: pronaći optimalni operator usporedbe čvorova koji kombinira sve dostupne operatore tj. vrste sortiranja. Drugi cilj je dovesti u vezu vrstu sortiranja i načina bojanja tj. empirijski pokazati koja vrsta sortiranja je najbolja za koji vrstu bojanja. Rezultati bi mogli pokazati određenu vezu između svojstava grafova i vrste sortiranja što bi se moglo koristi kao uvod u istraživanje hiper-heuristika. Metoda pronalaženja pogodnog pohlepnog algoritma sastoji se od koraka:

\begin{enumerate}
	\item Generiranje grafa
	\item Odabira vrste bojanja za pohlepni algoritam
	\item Pokretanje pohlepnog algoritma s vrstom sortiranja \emph{RND}
	\item Iz svih pokretanja pohlepnog algoritma uzeti određen postotak najboljih rezultata
	\item Za svaki čvor izračunati relativnu poziciju kao $\frac{x+1}{N}$ gdje je $x$ indeks u slučajno sortiranom nizu čvorova, a $N$ ukupan broj čvorova u grafu. 
	\item Za svaku relativnu poziciju izračunati svojstva tog čvora (stupanj, zasićenje, koliziju, grešku)
	\item Nekom od metoda regresije pronaći funkciju čiji su argumenti svojstva čvora, a rezultat je relativna pozicija
\end{enumerate}

Tako dobivena funkcija može se koristiti kao vrsta sortiranja. Za neke vrste regresija veoma lako se interpretiraju rezultati pa je lako odrediti u kojoj mjeri svojstva čvora utjeću na dobar rezultat. Za različite vrste bojanja moguće je uspoređivati funkcije i uočiti ovisnosti. Za različite grafove usporedbom funkcija može se izvući znanje o pogodnom algoritmu za pojedine vrste grafova. 

\section{Tuneliranje}

\emph{Tuneliranje} je tehnika koja se može ugraditi u bilo koji optimizacijski algoritam i služi za izlazak iz lokalnog minimuma. Tehnika je vrlo slična \emph{mutacijama} kod evolucijskih algoritama. Razlika je u tome što ova tehnika ne odabire slučajno novu točku iz prostora pretraživanja stanja, već nastoji odabrati točku koja ima približnu vrijednost funkcije cilja kao i trenutna točka koja se promatra (npr. relativna razlika funkcija cilja mora biti manja od nekog praga). Kako nova točka u prostoru pretrage ima sličnu vrijednost funkcije cilja, algoritam nastoji pronaći minimum u toj okolini, teorijski to znači da funkcija cilja može samo padati. U praksi se može dogoditi da i poraste jer se za novu točku ne zahtjeva da vrijednosti budu identične već približno jednake. Nova točka traži se tako što se po redu pretražuje dimenzija po dimenzija linearno. U problemu optimizacije bojanja grafa to znači da se po redu za svaki čvor ispituju boje, i ako za trenutni čvor nova boja za čvor ne utjeće na vrijednost greške tada se ta boja ostavlja tome čvoru. Ako se u pohlepnom algoritmu kao vrsta bojanja koristi "\emph{SWAP}" metoda dobiva se očekivani efekt. 

U navedenom pseudok\^{o}du nova točka postavlja se u trenutnu. Zatim se vanjska petlja vrti po dimenzijama i za svaku se ispituju se svi elementi (npr. boje). Element koji za apsolutno odstupanje daje vrjednost manju od praga $T$, postavlja se kao element za tu dimenziju i potraga kreće na sljedeću dimenziju.

\begin{singlespace}
	\begin{lstlisting}[caption=Metoda tuneliranja - implementacija]
		TUNNELING(f, X)
			NEW_X = X
			FOR i = 1 TO X.length()
				FOR EACH element in DIMENSION(i):
					NEW_X.dimension(i) = element
					IF |f(NEW_X)-f(X)| < f(X)*T:
						 BREAK
					NEX_X.dimension(i) = X.dimension(i)
				END FOR
			END FOR
			RETURN NEW_X
		END TUNNELING
	\end{lstlisting}
\end{singlespace}

\chapter{Infrastruktura}

\section{Uvod}

%TODO po modulima

\chapter{Rezultati}

\section{Metode testiranja algoritama}
\section{Slučajno pretraživanje}
\section{Agentski algoritam}

\section{Genetski algoritam}
\section{Genetsko kaljenje}

\section{Metode strojnog učenja za odair pohlepnog algoritma}

\chapter{Zaključak}
Zaključak.

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Sažetak na hrvatskom jeziku.

\kljucnerijeci{Ključne riječi, odvojene zarezima.}
\end{sazetak}

% TODO: Navedite naslov na engleskom jeziku.
\engtitle{Title}
\begin{abstract}
Abstract.

\keywords{Keywords.}
\end{abstract}

\end{document}
